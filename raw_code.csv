"File","Class","Function","Docstring","Function Calls"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_lowpass","Creates a low-pass filter  >>> filter = make_lowpass(1000, 48000) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,  0.008555138626189618, 0.004277569313094809]","sin, cos, IIRFilter, filt.set_coefficients, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_highpass","Creates a high-pass filter  >>> filter = make_highpass(1000, 48000) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,  -1.9914448613738105, 0.9957224306869052]","sin, cos, IIRFilter, filt.set_coefficients, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_bandpass","Creates a band-pass filter  >>> filter = make_bandpass(1000, 48000) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,  0, -0.06526309611002579]","sin, cos, IIRFilter, filt.set_coefficients, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_allpass","Creates an all-pass filter  >>> filter = make_allpass(1000, 48000) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,  -1.9828897227476208, 1.0922959556412573]","sin, cos, IIRFilter, filt.set_coefficients, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_peak","Creates a peak filter  >>> filter = make_peak(1000, 48000, 6) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,  -1.9828897227476208, 0.8696284974398878]","sin, cos, IIRFilter, filt.set_coefficients, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_lowshelf","Creates a low-shelf filter  >>> filter = make_lowshelf(1000, 48000, 6) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,  -5.591841778072785, 2.5201667380627257]","sin, cos, IIRFilter, filt.set_coefficients, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\butterworth_filter.py","","make_highshelf","Creates a high-shelf filter  >>> filter = make_highshelf(1000, 48000, 6) >>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE [2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,  -7.922740859457287, 3.6756456963725253]","sin, cos, IIRFilter, filt.set_coefficients, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\iir_filter.py","IIRFilter","","N-Order IIR filter Assumes working with float samples normalized on [-1, 1]  ---  Implementation details: Based on the 2nd-order function from https://en.wikipedia.org/wiki/Digital_biquad_filter, this generalized N-order function was made.  Using the following transfer function     .. math:: H(z)=\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+...+b_{k}z^{-k}}               {a_{0}+a_{1}z^{-1}+a_{2}z^{-2}+...+a_{k}z^{-k}}  we can rewrite this to     .. math:: y[n]={\frac{1}{a_{0}}}               \left(\left(b_{0}x[n]+b_{1}x[n-1]+b_{2}x[n-2]+...+b_{k}x[n-k]\right)-               \left(a_{1}y[n-1]+a_{2}y[n-2]+...+a_{k}y[n-k]\right)\right)",""
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\iir_filter.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\iir_filter.py","","set_coefficients","Set the coefficients for the IIR filter. These should both be of size `order` + 1. :math:`a_0` may be left out, and it will use 1.0 as default value.  This method works well with scipy's filter design functions  >>> # Make a 2nd-order 1000Hz butterworth lowpass filter >>> import scipy.signal >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000, ...                                          btype='lowpass', ...                                          fs=48000) >>> filt = IIRFilter(2) >>> filt.set_coefficients(a_coeffs, b_coeffs)","len, len, ValueError, len, ValueError, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\iir_filter.py","","process","Calculate :math:`y[n]`  >>> filt = IIRFilter(2) >>> filt.process(0) 0.0","range"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\show_response.py","FilterType","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\show_response.py","","get_bounds","Get bounds for printing fft results  >>> import numpy >>> array = numpy.linspace(-20.0, 20.0, 1000) >>> get_bounds(array, 1000) (-20, 20)","min, max, np.min, np.max"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\show_response.py","","show_frequency_response","Show frequency response of a filter  >>> from audio_filters.iir_filter import IIRFilter >>> filt = IIRFilter(4) >>> show_frequency_response(filt, 48000)","np.abs, plt.xlim, plt.xlabel, plt.xscale, get_bounds, plt.ylim, plt.ylabel, plt.plot, plt.show, filter_type.process, np.fft.fft, np.log10, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\show_response.py","","show_phase_response","Show phase response of a filter  >>> from audio_filters.iir_filter import IIRFilter >>> filt = IIRFilter(4) >>> show_phase_response(filt, 48000)","np.angle, plt.xlim, plt.xlabel, plt.xscale, plt.ylim, plt.ylabel, plt.plot, plt.show, filter_type.process, np.fft.fft, np.unwrap"
"C:/Users/Joseph Dania/Desktop/python_repo\audio_filters\show_response.py","","process","Calculate y[n]  >>> issubclass(FilterType, Protocol) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_combinations.py","","combination_lists","Generates all possible combinations of k numbers out of 1 ... n using itertools.  >>> combination_lists(n=4, k=2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]","list, combinations, range"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_combinations.py","","generate_all_combinations","Generates all possible combinations of k numbers out of 1 ... n using backtracking.  >>> generate_all_combinations(n=4, k=2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> generate_all_combinations(n=0, k=0) [[]] >>> generate_all_combinations(n=10, k=-1) Traceback (most recent call last):     ... ValueError: k must not be negative >>> generate_all_combinations(n=-1, k=10) Traceback (most recent call last):     ... ValueError: n must not be negative >>> generate_all_combinations(n=5, k=4) [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]] >>> generate_all_combinations(n=3, k=3) [[1, 2, 3]] >>> generate_all_combinations(n=3, k=1) [[1], [2], [3]] >>> generate_all_combinations(n=1, k=0) [[]] >>> generate_all_combinations(n=1, k=1) [[1]] >>> from itertools import combinations >>> all(generate_all_combinations(n, k) == combination_lists(n, k) ...     for n in range(1, 6) for k in range(1, 6)) True","create_all_state, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_combinations.py","","create_all_state","Helper function to recursively build all combinations.  >>> create_all_state(1, 4, 2, [], result := []) >>> result [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> create_all_state(1, 3, 3, [], result := []) >>> result [[1, 2, 3]] >>> create_all_state(2, 2, 1, [1], result := []) >>> result [[1, 2]] >>> create_all_state(1, 0, 0, [], result := []) >>> result [[]] >>> create_all_state(1, 4, 0, [1, 2], result := []) >>> result [[1, 2]] >>> create_all_state(5, 4, 2, [1, 2], result := []) >>> result []","range, total_list.append, current_list.append, create_all_state, current_list.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_permutations.py","","generate_all_permutations","","create_state_space_tree, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_permutations.py","","create_state_space_tree","Creates a state space tree to iterate through each branch using DFS. We know that each state has exactly len(sequence) - index children. It terminates when it reaches the end of the given sequence.  :param sequence: The input sequence for which permutations are generated. :param current_sequence: The current permutation being built. :param index: The current index in the sequence. :param index_used: list to track which elements are used in permutation.  Example 1: >>> sequence = [1, 2, 3] >>> current_sequence = [] >>> index_used = [False, False, False] >>> create_state_space_tree(sequence, current_sequence, 0, index_used) [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]  Example 2: >>> sequence = [""A"", ""B"", ""C""] >>> current_sequence = [] >>> index_used = [False, False, False] >>> create_state_space_tree(sequence, current_sequence, 0, index_used) ['A', 'B', 'C'] ['A', 'C', 'B'] ['B', 'A', 'C'] ['B', 'C', 'A'] ['C', 'A', 'B'] ['C', 'B', 'A']  Example 3: >>> sequence = [1] >>> current_sequence = [] >>> index_used = [False] >>> create_state_space_tree(sequence, current_sequence, 0, index_used) [1]","range, len, print, len, current_sequence.append, create_state_space_tree, current_sequence.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_subsequences.py","","generate_all_subsequences","","create_state_space_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\all_subsequences.py","","create_state_space_tree","Creates a state space tree to iterate through each branch using DFS. We know that each state has exactly two children. It terminates when it reaches the end of the given sequence.  :param sequence: The input sequence for which subsequences are generated. :param current_subsequence: The current subsequence being built. :param index: The current index in the sequence.  Example: >>> sequence = [3, 2, 1] >>> current_subsequence = [] >>> create_state_space_tree(sequence, current_subsequence, 0) [] [1] [2] [2, 1] [3] [3, 1] [3, 2] [3, 2, 1]  >>> sequence = [""A"", ""B""] >>> current_subsequence = [] >>> create_state_space_tree(sequence, current_subsequence, 0) [] ['B'] ['A'] ['A', 'B']  >>> sequence = [] >>> current_subsequence = [] >>> create_state_space_tree(sequence, current_subsequence, 0) []  >>> sequence = [1, 2, 3, 4] >>> current_subsequence = [] >>> create_state_space_tree(sequence, current_subsequence, 0) [] [4] [3] [3, 4] [2] [2, 4] [2, 3] [2, 3, 4] [1] [1, 4] [1, 3] [1, 3, 4] [1, 2] [1, 2, 4] [1, 2, 3] [1, 2, 3, 4]","create_state_space_tree, current_subsequence.append, create_state_space_tree, current_subsequence.pop, len, print"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\coloring.py","","valid_coloring","For each neighbour check if the coloring constraint is satisfied If any of the neighbours fail the constraint return False If all neighbours validate the constraint return True  >>> neighbours = [0,1,0,1,0] >>> colored_vertices = [0, 2, 1, 2, 0]  >>> color = 1 >>> valid_coloring(neighbours, colored_vertices, color) True  >>> color = 2 >>> valid_coloring(neighbours, colored_vertices, color) False","any, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\coloring.py","","util_color","Pseudo-Code  Base Case: 1. Check if coloring is complete     1.1 If complete return True (meaning that we successfully colored the graph)  Recursive Step: 2. Iterates over each color:     Check if the current coloring is valid:         2.1. Color given vertex         2.2. Do recursive call, check if this coloring leads to a solution         2.4. if current coloring leads to a solution return         2.5. Uncolor given vertex  >>> graph = [[0, 1, 0, 0, 0], ...          [1, 0, 1, 0, 1], ...          [0, 1, 0, 1, 0], ...          [0, 1, 1, 0, 0], ...          [0, 1, 0, 0, 0]] >>> max_colors = 3 >>> colored_vertices = [0, 1, 0, 0, 0] >>> index = 3  >>> util_color(graph, max_colors, colored_vertices, index) True  >>> max_colors = 2 >>> util_color(graph, max_colors, colored_vertices, index) False","range, len, valid_coloring, util_color"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\coloring.py","","color","Wrapper function to call subroutine called util_color which will either return True or False. If True is returned colored_vertices list is filled with correct colorings  >>> graph = [[0, 1, 0, 0, 0], ...          [1, 0, 1, 0, 1], ...          [0, 1, 0, 1, 0], ...          [0, 1, 1, 0, 0], ...          [0, 1, 0, 0, 0]]  >>> max_colors = 3 >>> color(graph, max_colors) [0, 1, 0, 2, 0]  >>> max_colors = 2 >>> color(graph, max_colors) []","util_color, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\combination_sum.py","","backtrack","A recursive function that searches for possible combinations. Backtracks in case of a bigger current combination value than the target value.  Parameters ---------- previous_index: Last index from the previous search target: The value we need to obtain by summing our integers in the path list. answer: A list of possible combinations path: Current combination candidates: A list of integers we can use.","answer.append, range, path.copy, len, path.append, backtrack, path.pop, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\combination_sum.py","","combination_sum",">>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([-8, 2.3, 0], 1) Traceback (most recent call last):     ... ValueError: All elements in candidates must be non-negative >>> combination_sum([], 1) Traceback (most recent call last):     ... ValueError: Candidates list should not be empty","any, backtrack, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\combination_sum.py","","main","","print, combination_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\crossword_puzzle_solver.py","","is_valid","Check if a word can be placed at the given position.  >>> puzzle = [ ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''] ... ] >>> is_valid(puzzle, 'word', 0, 0, True) True >>> puzzle = [ ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''] ... ] >>> is_valid(puzzle, 'word', 0, 0, False) True","range, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\crossword_puzzle_solver.py","","place_word","Place a word at the given position.  >>> puzzle = [ ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''] ... ] >>> place_word(puzzle, 'word', 0, 0, True) >>> puzzle [['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\crossword_puzzle_solver.py","","remove_word","Remove a word from the given position.  >>> puzzle = [ ...     ['w', '', '', ''], ...     ['o', '', '', ''], ...     ['r', '', '', ''], ...     ['d', '', '', ''] ... ] >>> remove_word(puzzle, 'word', 0, 0, True) >>> puzzle [['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\crossword_puzzle_solver.py","","solve_crossword","Solve the crossword puzzle using backtracking.  >>> puzzle = [ ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''] ... ]  >>> words = ['word', 'four', 'more', 'last'] >>> solve_crossword(puzzle, words) True >>> puzzle = [ ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''], ...     ['', '', '', ''] ... ] >>> words = ['word', 'four', 'more', 'paragraphs'] >>> solve_crossword(puzzle, words) False","range, len, range, len, is_valid, place_word, words.remove, solve_crossword, words.append, remove_word"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\generate_parentheses.py","","backtrack","Generate valid combinations of balanced parentheses using recursion.  :param partial: A string representing the current combination. :param open_count: An integer representing the count of open parentheses. :param close_count: An integer representing the count of close parentheses. :param n: An integer representing the total number of pairs. :param result: A list to store valid combinations. :return: None  This function uses recursion to explore all possible combinations, ensuring that at each step, the parentheses remain balanced.  Example: >>> result = [] >>> backtrack("""", 0, 0, 2, result) >>> result ['(())', '()()']","len, result.append, backtrack, backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\generate_parentheses.py","","generate_parenthesis","Generate valid combinations of balanced parentheses for a given n.  :param n: An integer representing the number of pairs of parentheses. :return: A list of strings with valid combinations.  This function uses a recursive approach to generate the combinations.  Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations. Space Complexity: O(n) - where 'n' is the number of pairs.  Example 1: >>> generate_parenthesis(3) ['((()))', '(()())', '(())()', '()(())', '()()()']  Example 2: >>> generate_parenthesis(1) ['()']","backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\generate_parentheses_iterative.py","","generate_parentheses_iterative","Generate all valid combinations of parentheses (Iterative Approach).  The algorithm works as follows: 1. Initialize an empty list to store the combinations. 2. Initialize a stack to keep track of partial combinations. 3. Start with empty string and push it onstack along with the counts of '(' and ')'. 4. While the stack is not empty:     a. Pop a partial combination and its open and close counts from the stack.     b. If the combination length is equal to 2*length, add it to the result.     c. If open count < length, push new combination with added '(' on stack.     d. If close count < open count, push new combination with added ')' on stack. 5. Return the result containing all valid combinations.  Args:     length: The desired length of the parentheses combinations  Returns:     A list of strings representing valid combinations of parentheses  Time Complexity:     O(2^(2*length))  Space Complexity:     O(2^(2*length))  >>> generate_parentheses_iterative(3) ['()()()', '()(())', '(())()', '(()())', '((()))'] >>> generate_parentheses_iterative(2) ['()()', '(())'] >>> generate_parentheses_iterative(1) ['()'] >>> generate_parentheses_iterative(0) ['']","stack.append, stack.pop, len, result.append, stack.append, stack.append"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\hamiltonian_cycle.py","","valid_connection","Checks whether it is possible to add next into path by validating 2 statements 1. There should be path between current and next vertex 2. Next vertex should not be in path If both validations succeed we return True, saying that it is possible to connect this vertices, otherwise we return False  Case 1:Use exact graph as in main function, with initialized values >>> graph = [[0, 1, 0, 1, 0], ...          [1, 0, 1, 1, 1], ...          [0, 1, 0, 0, 1], ...          [1, 1, 0, 0, 1], ...          [0, 1, 1, 1, 0]] >>> path = [0, -1, -1, -1, -1, 0] >>> curr_ind = 1 >>> next_ver = 1 >>> valid_connection(graph, next_ver, curr_ind, path) True  Case 2: Same graph, but trying to connect to node that is already in path >>> path = [0, 1, 2, 4, -1, 0] >>> curr_ind = 4 >>> next_ver = 1 >>> valid_connection(graph, next_ver, curr_ind, path) False","any"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\hamiltonian_cycle.py","","util_hamilton_cycle","Pseudo-Code Base Case: 1. Check if we visited all of vertices     1.1 If last visited vertex has path to starting vertex return True either         return False Recursive Step: 2. Iterate over each vertex     Check if next vertex is valid for transiting from current vertex         2.1 Remember next vertex as next transition         2.2 Do recursive call and check if going to this vertex solves problem         2.3 If next vertex leads to solution return True         2.4 Else backtrack, delete remembered vertex  Case 1: Use exact graph as in main function, with initialized values >>> graph = [[0, 1, 0, 1, 0], ...          [1, 0, 1, 1, 1], ...          [0, 1, 0, 0, 1], ...          [1, 1, 0, 0, 1], ...          [0, 1, 1, 1, 0]] >>> path = [0, -1, -1, -1, -1, 0] >>> curr_ind = 1 >>> util_hamilton_cycle(graph, path, curr_ind) True >>> path [0, 1, 2, 4, 3, 0]  Case 2: Use exact graph as in previous case, but in the properties taken from     middle of calculation >>> graph = [[0, 1, 0, 1, 0], ...          [1, 0, 1, 1, 1], ...          [0, 1, 0, 0, 1], ...          [1, 1, 0, 0, 1], ...          [0, 1, 1, 1, 0]] >>> path = [0, 1, 2, -1, -1, 0] >>> curr_ind = 3 >>> util_hamilton_cycle(graph, path, curr_ind) True >>> path [0, 1, 2, 4, 3, 0]","range, len, len, valid_connection, util_hamilton_cycle"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\hamiltonian_cycle.py","","hamilton_cycle","Wrapper function to call subroutine called util_hamilton_cycle, which will either return array of vertices indicating hamiltonian cycle or an empty list indicating that hamiltonian cycle was not found. Case 1: Following graph consists of 5 edges. If we look closely, we can see that there are multiple Hamiltonian cycles. For example one result is when we iterate like: (0)->(1)->(2)->(4)->(3)->(0)  (0)---(1)---(2)  |   /   \   |  |  /     \  |  | /       \ |  |/         \| (3)---------(4) >>> graph = [[0, 1, 0, 1, 0], ...          [1, 0, 1, 1, 1], ...          [0, 1, 0, 0, 1], ...          [1, 1, 0, 0, 1], ...          [0, 1, 1, 1, 0]] >>> hamilton_cycle(graph) [0, 1, 2, 4, 3, 0]  Case 2: Same Graph as it was in Case 1, changed starting index from default to 3  (0)---(1)---(2)  |   /   \   |  |  /     \  |  | /       \ |  |/         \| (3)---------(4) >>> graph = [[0, 1, 0, 1, 0], ...          [1, 0, 1, 1, 1], ...          [0, 1, 0, 0, 1], ...          [1, 1, 0, 0, 1], ...          [0, 1, 1, 1, 0]] >>> hamilton_cycle(graph, 3) [3, 0, 1, 2, 4, 3]  Case 3: Following Graph is exactly what it was before, but edge 3-4 is removed. Result is that there is no Hamiltonian Cycle anymore.  (0)---(1)---(2)  |   /   \   |  |  /     \  |  | /       \ |  |/         \| (3)         (4) >>> graph = [[0, 1, 0, 1, 0], ...          [1, 0, 1, 1, 1], ...          [0, 1, 0, 0, 1], ...          [1, 1, 0, 0, 0], ...          [0, 1, 1, 0, 0]] >>> hamilton_cycle(graph,4) []","util_hamilton_cycle, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\knight_tour.py","","get_valid_pos","Find all the valid positions a knight can move to from the current position.  >>> get_valid_pos((1, 3), 4) [(2, 1), (0, 1), (3, 2)]","permissible_positions.append"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\knight_tour.py","","is_complete","Check if the board (matrix) has been completely filled with non-zero values.  >>> is_complete([[1]]) True  >>> is_complete([[1, 2], [3, 0]]) False","any"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\knight_tour.py","","open_knight_tour_helper","Helper function to solve knight tour problem.","is_complete, get_valid_pos, len, open_knight_tour_helper"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\knight_tour.py","","open_knight_tour","Find the solution for the knight tour problem for a board of size n. Raises ValueError if the tour cannot be performed for the given size.  >>> open_knight_tour(1) [[1]]  >>> open_knight_tour(2) Traceback (most recent call last):     ... ValueError: Open Knight Tour cannot be performed on a board of size 2","range, ValueError, range, range, open_knight_tour_helper, range"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\match_word_pattern.py","","match_word_pattern","Determine if a given pattern matches a string using backtracking.  pattern: The pattern to match. input_string: The string to match against the pattern. return: True if the pattern matches the string, False otherwise.  >>> match_word_pattern(""aba"", ""GraphTreesGraph"") True  >>> match_word_pattern(""xyx"", ""PythonRubyPython"") True  >>> match_word_pattern(""GG"", ""PythonJavaPython"") False","backtrack, range, input_string.startswith, backtrack, len, len, len, len, backtrack, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\match_word_pattern.py","","backtrack",">>> backtrack(0, 0) True  >>> backtrack(0, 1) True  >>> backtrack(0, 4) False","range, input_string.startswith, backtrack, len, len, len, len, backtrack, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\minimax.py","","minimax","This function implements the minimax algorithm, which helps achieve the optimal score for a player in a two-player game by checking all possible moves. If the player is the maximizer, then the score is maximized. If the player is the minimizer, then the score is minimized.  Parameters: - depth: Current depth in the game tree. - node_index: Index of the current node in the scores list. - is_max: A boolean indicating whether the current move           is for the maximizer (True) or minimizer (False). - scores: A list containing the scores of the leaves of the game tree. - height: The maximum height of the game tree.  Returns: - An integer representing the optimal score for the current player.  >>> import math >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423] >>> height = math.log(len(scores), 2) >>> minimax(0, 0, True, scores, height) 65 >>> minimax(-1, 0, True, scores, height) Traceback (most recent call last):     ... ValueError: Depth cannot be less than 0 >>> minimax(0, 0, True, [], 2) Traceback (most recent call last):     ... ValueError: Scores cannot be empty >>> scores = [3, 5, 2, 9, 12, 5, 23, 23] >>> height = math.log(len(scores), 2) >>> minimax(0, 0, True, scores, height) 12","min, ValueError, len, ValueError, max, minimax, minimax, minimax, minimax"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\minimax.py","","main","","math.log, print, print, len, minimax"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\n_queens.py","","is_safe","This function returns a boolean value True if it is safe to place a queen there considering the current state of the board.  Parameters: board (2D matrix): The chessboard row, column: Coordinates of the cell on the board  Returns: Boolean Value  >>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) True >>> is_safe([[0, 1, 0], [0, 0, 0], [0, 0, 0]], 1, 1) False >>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1) False >>> is_safe([[0, 0, 1], [0, 0, 0], [0, 0, 0]], 1, 1) False","len, all, all, all, zip, zip, zip, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\n_queens.py","","solve","This function creates a state space tree and calls the safe function until it receives a False Boolean and terminates that branch and backtracks to the next possible solution branch.","range, len, solution.append, printboard, print, len, is_safe, solve"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\n_queens.py","","printboard","Prints the boards that have a successful combination.","range, len, range, print, len, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\n_queens_math.py","","depth_first_search",">>> boards = [] >>> depth_first_search([], [], [], boards, 4) >>> for board in boards: ...     print(board) ['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . '] ['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']","len, range, boards.append, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\n_queens_math.py","","n_queens_solution","","depth_first_search, print, print, len, print"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\power_sum.py","","backtrack",">>> backtrack(13, 2, 1, 0, 0) (0, 1) >>> backtrack(10, 2, 1, 0, 0) (0, 1) >>> backtrack(10, 3, 1, 0, 0) (0, 0) >>> backtrack(20, 2, 1, 0, 0) (0, 1) >>> backtrack(15, 10, 1, 0, 0) (0, 0) >>> backtrack(16, 2, 1, 0, 0) (0, 1) >>> backtrack(20, 1, 1, 0, 0) (0, 64)","backtrack, backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\power_sum.py","","solve",">>> solve(13, 2) 1 >>> solve(10, 2) 1 >>> solve(10, 3) 0 >>> solve(20, 2) 1 >>> solve(15, 10) 0 >>> solve(16, 2) 1 >>> solve(20, 1) Traceback (most recent call last):     ... ValueError: Invalid input needed_sum must be between 1 and 1000, power between 2 and 10. >>> solve(-10, 5) Traceback (most recent call last):     ... ValueError: Invalid input needed_sum must be between 1 and 1000, power between 2 and 10.","ValueError, backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\rat_in_maze.py","","solve_maze","This method solves the ""rat in maze"" problem. Parameters :     - maze: A two dimensional matrix of zeros and ones.     - source_row: The row index of the starting point.     - source_column: The column index of the starting point.     - destination_row: The row index of the destination point.     - destination_column: The column index of the destination point. Returns:     - solution: A 2D matrix representing the solution path if it exists. Raises:     - ValueError: If no solution exists or if the source or         destination coordinates are invalid. Description:     This method navigates through a maze represented as an n by n matrix,     starting from a specified source cell and     aiming to reach a destination cell.     The maze consists of walls (1s) and open paths (0s).     By providing custom row and column values, the source and destination     cells can be adjusted. >>> maze = [[0, 1, 0, 1, 1], ...         [0, 0, 0, 0, 0], ...         [1, 0, 1, 0, 1], ...         [0, 0, 1, 0, 0], ...         [1, 0, 0, 1, 0]] >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE [[0, 1, 1, 1, 1], [0, 0, 0, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 0]]  Note:     In the output maze, the zeros (0s) represent one of the possible     paths from the source to the destination.  >>> maze = [[0, 1, 0, 1, 1], ...         [0, 0, 0, 0, 0], ...         [0, 0, 0, 0, 1], ...         [0, 0, 0, 0, 0], ...         [0, 0, 0, 0, 0]] >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE [[0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0]]  >>> maze = [[0, 0, 0], ...         [0, 1, 0], ...         [1, 0, 0]] >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0], [1, 1, 0], [1, 1, 0]]  >>> maze = [[1, 0, 0], ...         [0, 1, 0], ...         [1, 0, 0]] >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE [[1, 0, 0], [1, 1, 0], [1, 1, 0]]  >>> maze = [[1, 1, 0, 0, 1, 0, 0, 1], ...         [1, 0, 1, 0, 0, 1, 1, 1], ...         [0, 1, 0, 1, 0, 0, 1, 0], ...         [1, 1, 1, 0, 0, 1, 0, 1], ...         [0, 1, 0, 0, 1, 0, 1, 1], ...         [0, 0, 0, 1, 1, 1, 0, 1], ...         [0, 1, 0, 1, 0, 1, 1, 1], ...         [1, 1, 0, 0, 0, 0, 0, 1]] >>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE [[1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1]] >>> maze = [[1, 0, 0], ...         [0, 1, 1], ...         [1, 0, 1]] >>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1) Traceback (most recent call last):     ... ValueError: No solution exists!  >>> maze = [[0, 0], ...         [1, 1]] >>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1) Traceback (most recent call last):     ... ValueError: No solution exists!  >>> maze = [[0, 1], ...         [1, 0]] >>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1) Traceback (most recent call last):     ... ValueError: Invalid source or destination coordinates  >>> maze = [[1, 0, 0], ...         [0, 1, 0], ...         [1, 0, 0]] >>> solve_maze(maze,0,1,len(maze),len(maze)-1) Traceback (most recent call last):     ... ValueError: Invalid source or destination coordinates","len, run_maze, ValueError, ValueError, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\rat_in_maze.py","","run_maze","This method is recursive starting from (i, j) and going in one of four directions: up, down, left, right. If a path is found to destination it returns True otherwise it returns False. Parameters     maze: A two dimensional matrix of zeros and ones.     i, j : coordinates of matrix     solutions: A two dimensional matrix of solutions. Returns:     Boolean if path is found True, Otherwise False.","len, run_maze, run_maze, run_maze, run_maze"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\sudoku.py","","is_safe","This function checks the grid to see if each row, column, and the 3x3 subgrids contain the digit 'n'. It returns False if it is not 'safe' (a duplicate digit is found) else returns True if it is 'safe'","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\sudoku.py","","find_empty_location","This function finds an empty location so that we can assign a number for that particular row and column.","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\sudoku.py","","sudoku","Takes a partially filled-in grid and attempts to assign values to all unassigned locations in such a way to meet the requirements for Sudoku solution (non-duplication across rows, columns, and boxes)  >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE [[3, 1, 6, 5, 7, 8, 4, 9, 2],  [5, 2, 9, 1, 3, 4, 7, 6, 8],  [4, 8, 7, 6, 2, 9, 5, 3, 1],  [2, 6, 3, 4, 1, 5, 9, 8, 7],  [9, 7, 4, 8, 6, 3, 1, 2, 5],  [8, 5, 1, 7, 9, 2, 6, 4, 3],  [1, 3, 8, 9, 4, 7, 2, 5, 6],  [6, 9, 2, 3, 5, 1, 8, 7, 4],  [7, 4, 5, 2, 8, 6, 3, 1, 9]]  >>> sudoku(no_solution) is None  True","range, find_empty_location, is_safe, sudoku"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\sudoku.py","","print_solution","A function to print the solution in the form of a 9x9 grid","print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\sum_of_subsets.py","","generate_sum_of_subsets_solutions","The main function. For list of numbers 'nums' find the subsets with sum equal to 'max_sum'  >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9) [[3, 4, 2], [4, 5]] >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3) [[3]] >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1) []","sum, create_state_space_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\sum_of_subsets.py","","create_state_space_tree","Creates a state space tree to iterate through each branch using DFS. It terminates the branching of a node when any of the two conditions given below satisfy. This algorithm follows depth-fist-search and backtracks when the node is not branchable.  >>> path = [] >>> result = [] >>> create_state_space_tree( ...     nums=[1], ...     max_sum=1, ...     num_index=0, ...     path=path, ...     result=result, ...     remaining_nums_sum=1) >>> path [] >>> result [[1]]","range, sum, result.append, len, create_state_space_tree, sum, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_break.py","","backtrack","Helper function that uses backtracking to determine if a valid word segmentation is possible starting from index 'start'.  Parameters: input_string (str): The input string to be segmented. word_dict (set[str]): A set of valid dictionary words. start (int): The starting index of the substring to be checked.  Returns: bool: True if a valid segmentation is possible, otherwise False.  Example: >>> backtrack(""leetcode"", {""leet"", ""code""}, 0) True  >>> backtrack(""applepenapple"", {""apple"", ""pen""}, 0) True  >>> backtrack(""catsandog"", {""cats"", ""dog"", ""sand"", ""and"", ""cat""}, 0) False","range, len, len, backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_break.py","","word_break","Determines if the input string can be segmented into a sequence of valid dictionary words using backtracking.  Parameters: input_string (str): The input string to segment. word_dict (set[str]): The set of valid words.  Returns: bool: True if the string can be segmented into valid words, otherwise False.  Example: >>> word_break(""leetcode"", {""leet"", ""code""}) True  >>> word_break(""applepenapple"", {""apple"", ""pen""}) True  >>> word_break(""catsandog"", {""cats"", ""dog"", ""sand"", ""and"", ""cat""}) False","backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_ladder.py","","backtrack","Helper function to perform backtracking to find the transformation from the current_word to the end_word.  Parameters: current_word (str): The current word in the transformation sequence. path (list[str]): The list of transformations from begin_word to current_word. end_word (str): The target word for transformation. word_set (set[str]): The set of valid words for transformation.  Returns: list[str]: The list of transformations from begin_word to end_word.            Returns an empty list if there is no valid             transformation from current_word to end_word.  Example: >>> backtrack(""hit"", [""hit""], ""cog"", {""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""}) ['hit', 'hot', 'dot', 'lot', 'log', 'cog']  >>> backtrack(""hit"", [""hit""], ""cog"", {""hot"", ""dot"", ""dog"", ""lot"", ""log""}) []  >>> backtrack(""lead"", [""lead""], ""gold"", {""load"", ""goad"", ""gold"", ""lead"", ""lord""}) ['lead', 'lead', 'load', 'goad', 'gold']  >>> backtrack(""game"", [""game""], ""code"", {""came"", ""cage"", ""code"", ""cade"", ""gave""}) ['game', 'came', 'cade', 'code']","range, len, word_set.remove, backtrack, word_set.add"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_ladder.py","","word_ladder","Solve the Word Ladder problem using Backtracking and return the list of transformations from begin_word to end_word.  Parameters: begin_word (str): The word from which the transformation starts. end_word (str): The target word for transformation. word_list (list[str]): The list of valid words for transformation.  Returns: list[str]: The list of transformations from begin_word to end_word.            Returns an empty list if there is no valid transformation.  Example: >>> word_ladder(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""]) ['hit', 'hot', 'dot', 'lot', 'log', 'cog']  >>> word_ladder(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log""]) []  >>> word_ladder(""lead"", ""gold"", [""load"", ""goad"", ""gold"", ""lead"", ""lord""]) ['lead', 'lead', 'load', 'goad', 'gold']  >>> word_ladder(""game"", ""code"", [""came"", ""cage"", ""code"", ""cade"", ""gave""]) ['game', 'came', 'cade', 'code']","backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_search.py","","get_point_key","Returns the hash key of matrix indexes.  >>> get_point_key(10, 20, 1, 0) 200",""
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_search.py","","exits_word","Return True if it's possible to search the word suffix starting from the word_index.  >>> exits_word([[""A""]], ""B"", 0, 0, 0, set()) False","len, len, get_point_key, visited_points_set.add, exits_word, visited_points_set.remove, len"
"C:/Users/Joseph Dania/Desktop/python_repo\backtracking\word_search.py","","word_exists",">>> word_exists([[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], ""ABCCED"") True >>> word_exists([[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], ""SEE"") True >>> word_exists([[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], ""ABCB"") False >>> word_exists([[""A""]], ""A"") True >>> word_exists([[""B"", ""A"", ""A""], [""A"", ""A"", ""A""], [""A"", ""B"", ""A""]], ""ABB"") False >>> word_exists([[""A""]], 123) Traceback (most recent call last):     ... ValueError: The word parameter should be a string of length greater than 0. >>> word_exists([[""A""]], """") Traceback (most recent call last):     ... ValueError: The word parameter should be a string of length greater than 0. >>> word_exists([[]], ""AB"") Traceback (most recent call last):     ... ValueError: The board should be a non empty matrix of single chars strings. >>> word_exists([], ""AB"") Traceback (most recent call last):     ... ValueError: The board should be a non empty matrix of single chars strings. >>> word_exists([[""A""], [21]], ""AB"") Traceback (most recent call last):     ... ValueError: The board should be a non empty matrix of single chars strings.","len, len, range, ValueError, ValueError, range, isinstance, len, ValueError, isinstance, len, exits_word, isinstance, len, ValueError, isinstance, len, get_point_key"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_and_operator.py","","binary_and","Take in 2 integers, convert them to binary, return a binary number that is the result of a binary and operation on the integers provided.  >>> binary_and(25, 32) '0b000000' >>> binary_and(37, 50) '0b100000' >>> binary_and(21, 30) '0b10100' >>> binary_and(58, 73) '0b0001000' >>> binary_and(0, 255) '0b00000000' >>> binary_and(256, 256) '0b100000000' >>> binary_and(0, -1) Traceback (most recent call last):     ... ValueError: the value of both inputs must be positive >>> binary_and(0, 1.1) Traceback (most recent call last):     ... ValueError: Unknown format code 'b' for object of type 'float' >>> binary_and(""0"", ""1"") Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int'","format, format, max, ValueError, len, len, .join, str, int, zip, a_binary.zfill, b_binary.zfill"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_coded_decimal.py","","binary_coded_decimal","Find binary coded decimal (bcd) of integer base 10. Each digit of the number is represented by a 4-bit binary. Example: >>> binary_coded_decimal(-2) '0b0000' >>> binary_coded_decimal(-1) '0b0000' >>> binary_coded_decimal(0) '0b0000' >>> binary_coded_decimal(3) '0b0011' >>> binary_coded_decimal(2) '0b0010' >>> binary_coded_decimal(12) '0b00010010' >>> binary_coded_decimal(987) '0b100110000111'",".join, .zfill, str, max, str, bin, int"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_count_setbits.py","","binary_count_setbits","Take in 1 integer, return a number that is the number of 1's in binary representation of that number.  >>> binary_count_setbits(25) 3 >>> binary_count_setbits(36) 2 >>> binary_count_setbits(16) 1 >>> binary_count_setbits(58) 4 >>> binary_count_setbits(4294967295) 32 >>> binary_count_setbits(0) 0 >>> binary_count_setbits(-10) Traceback (most recent call last):     ... ValueError: Input value must be a positive integer >>> binary_count_setbits(0.8) Traceback (most recent call last):     ... TypeError: Input value must be a 'int' type >>> binary_count_setbits(""0"") Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int'",".count, ValueError, isinstance, TypeError, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_count_trailing_zeros.py","","binary_count_trailing_zeros","Take in 1 integer, return a number that is the number of trailing zeros in binary representation of that number.  >>> binary_count_trailing_zeros(25) 0 >>> binary_count_trailing_zeros(36) 2 >>> binary_count_trailing_zeros(16) 4 >>> binary_count_trailing_zeros(58) 1 >>> binary_count_trailing_zeros(4294967296) 32 >>> binary_count_trailing_zeros(0) 0 >>> binary_count_trailing_zeros(-10) Traceback (most recent call last):     ... ValueError: Input value must be a positive integer >>> binary_count_trailing_zeros(0.8) Traceback (most recent call last):     ... TypeError: Input value must be a 'int' type >>> binary_count_trailing_zeros(""0"") Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int'","ValueError, isinstance, int, TypeError, log2"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_or_operator.py","","binary_or","Take in 2 integers, convert them to binary, and return a binary number that is the result of a binary or operation on the integers provided.  >>> binary_or(25, 32) '0b111001' >>> binary_or(37, 50) '0b110111' >>> binary_or(21, 30) '0b11111' >>> binary_or(58, 73) '0b1111011' >>> binary_or(0, 255) '0b11111111' >>> binary_or(0, 256) '0b100000000' >>> binary_or(0, -1) Traceback (most recent call last):     ... ValueError: the value of both inputs must be positive >>> binary_or(0, 1.1) Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer >>> binary_or(""0"", ""1"") Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int'","max, ValueError, str, str, len, len, .join, bin, bin, str, int, zip, a_binary.zfill, b_binary.zfill"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_shifts.py","","logical_left_shift","Take in 2 positive integers. 'number' is the integer to be logically left shifted 'shift_amount' times. i.e. (number << shift_amount) Return the shifted binary representation.  >>> logical_left_shift(0, 1) '0b00' >>> logical_left_shift(1, 1) '0b10' >>> logical_left_shift(1, 5) '0b100000' >>> logical_left_shift(17, 2) '0b1000100' >>> logical_left_shift(1983, 4) '0b111101111110000' >>> logical_left_shift(1, -1) Traceback (most recent call last):     ... ValueError: both inputs must be positive integers","str, ValueError, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_shifts.py","","logical_right_shift","Take in positive 2 integers. 'number' is the integer to be logically right shifted 'shift_amount' times. i.e. (number >>> shift_amount) Return the shifted binary representation.  >>> logical_right_shift(0, 1) '0b0' >>> logical_right_shift(1, 1) '0b0' >>> logical_right_shift(1, 5) '0b0' >>> logical_right_shift(17, 2) '0b100' >>> logical_right_shift(1983, 4) '0b1111011' >>> logical_right_shift(1, -1) Traceback (most recent call last):     ... ValueError: both inputs must be positive integers","ValueError, str, len, bin, len"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_shifts.py","","arithmetic_right_shift","Take in 2 integers. 'number' is the integer to be arithmetically right shifted 'shift_amount' times. i.e. (number >> shift_amount) Return the shifted binary representation.  >>> arithmetic_right_shift(0, 1) '0b00' >>> arithmetic_right_shift(1, 1) '0b00' >>> arithmetic_right_shift(-1, 1) '0b11' >>> arithmetic_right_shift(17, 2) '0b000100' >>> arithmetic_right_shift(-17, 2) '0b111011' >>> arithmetic_right_shift(-1983, 4) '0b111110000100'","len, len, bin, .strip, bin, len, abs, len, str, len, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_twos_complement.py","","twos_complement","Take in a negative integer 'number'. Return the two's complement representation of 'number'.  >>> twos_complement(0) '0b0' >>> twos_complement(-1) '0b11' >>> twos_complement(-5) '0b1011' >>> twos_complement(-17) '0b101111' >>> twos_complement(-207) '0b100110001' >>> twos_complement(1) Traceback (most recent call last):     ... ValueError: input must be a negative integer","len, ValueError, bin, bin, abs, len"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\binary_xor_operator.py","","binary_xor","Take in 2 integers, convert them to binary, return a binary number that is the result of a binary xor operation on the integers provided.  >>> binary_xor(25, 32) '0b111001' >>> binary_xor(37, 50) '0b010111' >>> binary_xor(21, 30) '0b01011' >>> binary_xor(58, 73) '0b1110011' >>> binary_xor(0, 255) '0b11111111' >>> binary_xor(256, 256) '0b000000000' >>> binary_xor(0, -1) Traceback (most recent call last):     ... ValueError: the value of both inputs must be positive >>> binary_xor(0, 1.1) Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer >>> binary_xor(""0"", ""1"") Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int'","max, ValueError, str, str, len, len, .join, bin, bin, str, int, zip, a_binary.zfill, b_binary.zfill"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\bitwise_addition_recursive.py","","bitwise_addition_recursive",">>> bitwise_addition_recursive(4, 5) 9 >>> bitwise_addition_recursive(8, 9) 17 >>> bitwise_addition_recursive(0, 4) 4 >>> bitwise_addition_recursive(4.5, 9) Traceback (most recent call last):     ... TypeError: Both arguments MUST be integers! >>> bitwise_addition_recursive('4', 9) Traceback (most recent call last):     ... TypeError: Both arguments MUST be integers! >>> bitwise_addition_recursive('4.5', 9) Traceback (most recent call last):     ... TypeError: Both arguments MUST be integers! >>> bitwise_addition_recursive(-1, 9) Traceback (most recent call last):     ... ValueError: Both arguments MUST be non-negative! >>> bitwise_addition_recursive(1, -9) Traceback (most recent call last):     ... ValueError: Both arguments MUST be non-negative!","bitwise_addition_recursive, TypeError, ValueError, isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\count_1s_brian_kernighan_method.py","","get_1s_count","Count the number of set bits in a 32 bit integer using Brian Kernighan's way. Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan >>> get_1s_count(25) 3 >>> get_1s_count(37) 3 >>> get_1s_count(21) 3 >>> get_1s_count(58) 4 >>> get_1s_count(0) 0 >>> get_1s_count(256) 1 >>> get_1s_count(-1) Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer >>> get_1s_count(0.8) Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer >>> get_1s_count(""25"") Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\count_number_of_one_bits.py","","get_set_bits_count_using_brian_kernighans_algorithm","Count the number of set bits in a 32 bit integer >>> get_set_bits_count_using_brian_kernighans_algorithm(25) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(37) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(21) 3 >>> get_set_bits_count_using_brian_kernighans_algorithm(58) 4 >>> get_set_bits_count_using_brian_kernighans_algorithm(0) 0 >>> get_set_bits_count_using_brian_kernighans_algorithm(256) 1 >>> get_set_bits_count_using_brian_kernighans_algorithm(-1) Traceback (most recent call last):     ... ValueError: the value of input must not be negative","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\count_number_of_one_bits.py","","get_set_bits_count_using_modulo_operator","Count the number of set bits in a 32 bit integer >>> get_set_bits_count_using_modulo_operator(25) 3 >>> get_set_bits_count_using_modulo_operator(37) 3 >>> get_set_bits_count_using_modulo_operator(21) 3 >>> get_set_bits_count_using_modulo_operator(58) 4 >>> get_set_bits_count_using_modulo_operator(0) 0 >>> get_set_bits_count_using_modulo_operator(256) 1 >>> get_set_bits_count_using_modulo_operator(-1) Traceback (most recent call last):     ... ValueError: the value of input must not be negative","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\count_number_of_one_bits.py","","benchmark","Benchmark code for comparing 2 functions, with different length int values. Brian Kernighan's algorithm is consistently faster than using modulo_operator.","print, print, timeit, print, print, timeit, print, do_benchmark, print, get_set_bits_count_using_modulo_operator, get_set_bits_count_using_brian_kernighans_algorithm"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\count_number_of_one_bits.py","","do_benchmark","","print, print, timeit, print, print, timeit, print, get_set_bits_count_using_modulo_operator, get_set_bits_count_using_brian_kernighans_algorithm"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\excess_3_code.py","","excess_3_code","Find excess-3 code of integer base 10. Add 3 to all digits in a decimal number then convert to a binary-coded decimal. https://en.wikipedia.org/wiki/Excess-3  >>> excess_3_code(0) '0b0011' >>> excess_3_code(3) '0b0110' >>> excess_3_code(2) '0b0101' >>> excess_3_code(20) '0b01010011' >>> excess_3_code(120) '0b010001010011'","str, max, .zfill, str, bin, int"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\find_previous_power_of_two.py","","find_previous_power_of_two","Find the largest power of two that is less than or equal to a given integer. https://stackoverflow.com/questions/1322510  >>> [find_previous_power_of_two(i) for i in range(18)] [0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16] >>> find_previous_power_of_two(-5) Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer >>> find_previous_power_of_two(10.5) Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\find_unique_number.py","","find_unique_number","Given a list of integers where every element appears twice except for one, this function returns the element that appears only once using bitwise XOR.  >>> find_unique_number([1, 1, 2, 2, 3]) 3 >>> find_unique_number([4, 5, 4, 6, 6]) 5 >>> find_unique_number([7]) 7 >>> find_unique_number([10, 20, 10]) 20 >>> find_unique_number([]) Traceback (most recent call last):     ... ValueError: input list must not be empty >>> find_unique_number([1, 'a', 1]) Traceback (most recent call last):     ... TypeError: all elements must be integers","ValueError, all, TypeError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\gray_code_sequence.py","","gray_code","Takes in an integer n and returns a n-bit gray code sequence An n-bit gray code sequence is a sequence of 2^n integers where:  a) Every integer is between [0,2^n -1] inclusive b) The sequence begins with 0 c) An integer appears at most one times in the sequence d)The binary representation of every pair of integers differ    by exactly one bit e) The binary representation of first and last bit also    differ by exactly one bit  >>> gray_code(2) [0, 1, 3, 2]  >>> gray_code(1) [0, 1]  >>> gray_code(3) [0, 1, 3, 2, 6, 7, 5, 4]  >>> gray_code(-1) Traceback (most recent call last):     ... ValueError: The given input must be positive  >>> gray_code(10.6) Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for <<: 'int' and 'float'","gray_code_sequence_string, range, ValueError, len, int"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\gray_code_sequence.py","","gray_code_sequence_string","Will output the n-bit grey sequence as a string of bits  >>> gray_code_sequence_string(2) ['00', '01', '11', '10']  >>> gray_code_sequence_string(1) ['0', '1']","gray_code_sequence_string, range, reversed, sequence.append, range, sequence.append"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\highest_set_bit.py","","get_highest_set_bit_position","Returns position of the highest set bit of a number. Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious >>> get_highest_set_bit_position(25) 5 >>> get_highest_set_bit_position(37) 6 >>> get_highest_set_bit_position(1) 1 >>> get_highest_set_bit_position(4) 3 >>> get_highest_set_bit_position(0) 0 >>> get_highest_set_bit_position(0.8) Traceback (most recent call last):     ... TypeError: Input value must be an 'int' type","isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\index_of_rightmost_set_bit.py","","get_index_of_rightmost_set_bit","Take in a positive integer 'number'. Returns the zero-based index of first set bit in that 'number' from right. Returns -1, If no set bit found.  >>> get_index_of_rightmost_set_bit(0) -1 >>> get_index_of_rightmost_set_bit(5) 0 >>> get_index_of_rightmost_set_bit(36) 2 >>> get_index_of_rightmost_set_bit(8) 3 >>> get_index_of_rightmost_set_bit(-18) Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer >>> get_index_of_rightmost_set_bit('test') Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer >>> get_index_of_rightmost_set_bit(1.25) Traceback (most recent call last):     ... ValueError: Input must be a non-negative integer","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\is_even.py","","is_even","return true if the input integer is even Explanation: Lets take a look at the following decimal to binary conversions 2 => 10 14 => 1110 100 => 1100100 3 => 11 13 => 1101 101 => 1100101 from the above examples we can observe that for all the odd integers there is always 1 set bit at the end also, 1 in binary can be represented as 001, 00001, or 0000001 so for any odd integer n => n&1 is always equals 1 else the integer is even  >>> is_even(1) False >>> is_even(4) True >>> is_even(9) False >>> is_even(15) False >>> is_even(40) True >>> is_even(100) True >>> is_even(101) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\is_power_of_two.py","","is_power_of_two","Return True if this number is power of 2 or False otherwise.  >>> is_power_of_two(0) True >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(4) True >>> is_power_of_two(6) False >>> is_power_of_two(8) True >>> is_power_of_two(17) False >>> is_power_of_two(-1) Traceback (most recent call last):     ... ValueError: number must not be negative >>> is_power_of_two(1.2) Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for &: 'float' and 'float'  # Test all powers of 2 from 0 to 10,000 >>> all(is_power_of_two(int(2 ** i)) for i in range(10000)) True","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\largest_pow_of_two_le_num.py","","largest_pow_of_two_le_num","Return the largest power of two less than or equal to a number.  >>> largest_pow_of_two_le_num(0) 0 >>> largest_pow_of_two_le_num(1) 1 >>> largest_pow_of_two_le_num(-1) 0 >>> largest_pow_of_two_le_num(3) 2 >>> largest_pow_of_two_le_num(15) 8 >>> largest_pow_of_two_le_num(99) 64 >>> largest_pow_of_two_le_num(178) 128 >>> largest_pow_of_two_le_num(999999) 524288 >>> largest_pow_of_two_le_num(99.9) Traceback (most recent call last):     ... TypeError: Input value must be a 'int' type","isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\missing_number.py","","find_missing_number","Finds the missing number in a list of consecutive integers.  Args:     nums: A list of integers.  Returns:     The missing number.  Example:     >>> find_missing_number([0, 1, 3, 4])     2     >>> find_missing_number([4, 3, 1, 0])     2     >>> find_missing_number([-4, -3, -1, 0])     -2     >>> find_missing_number([-2, 2, 1, 3, 0])     -1     >>> find_missing_number([1, 3, 4, 5, 6])     2     >>> find_missing_number([6, 5, 4, 2, 1])     3     >>> find_missing_number([6, 1, 5, 3, 4])     2","min, max, range"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\numbers_different_signs.py","","different_signs","Return True if numbers have opposite signs False otherwise.  >>> different_signs(1, -1) True >>> different_signs(1, 1) False >>> different_signs(1000000000000000000000000000, -1000000000000000000000000000) True >>> different_signs(-1000000000000000000000000000, 1000000000000000000000000000) True >>> different_signs(50, 278) False >>> different_signs(0, 2) False >>> different_signs(2, 0) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\power_of_4.py","","power_of_4","Return True if this number is power of 4 or False otherwise.  >>> power_of_4(0) Traceback (most recent call last):     ... ValueError: number must be positive >>> power_of_4(1) True >>> power_of_4(2) False >>> power_of_4(4) True >>> power_of_4(6) False >>> power_of_4(8) False >>> power_of_4(17) False >>> power_of_4(64) True >>> power_of_4(-1) Traceback (most recent call last):     ... ValueError: number must be positive >>> power_of_4(1.2) Traceback (most recent call last):     ... TypeError: number must be an integer","isinstance, TypeError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\reverse_bits.py","","get_reverse_bit_string","Return the reverse bit string of a 32 bit integer  >>> get_reverse_bit_string(9) '10010000000000000000000000000000' >>> get_reverse_bit_string(43) '11010100000000000000000000000000' >>> get_reverse_bit_string(2873) '10011100110100000000000000000000' >>> get_reverse_bit_string(2550136832) '00000000000000000000000000011001' >>> get_reverse_bit_string(""this is not a number"") Traceback (most recent call last):     ... TypeError: operation can not be conducted on an object of type str","range, isinstance, TypeError, str, type"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\reverse_bits.py","","reverse_bit","Take in a 32 bit integer, reverse its bits, return a 32 bit integer result  >>> reverse_bit(25) 2550136832 >>> reverse_bit(37) 2751463424 >>> reverse_bit(21) 2818572288 >>> reverse_bit(58) 1543503872 >>> reverse_bit(0) 0 >>> reverse_bit(256) 8388608 >>> reverse_bit(2550136832) 25 >>> reverse_bit(-1) Traceback (most recent call last):     ... ValueError: The value of input must be non-negative  >>> reverse_bit(1.1) Traceback (most recent call last):     ... TypeError: Input value must be an 'int' type  >>> reverse_bit(""0"") Traceback (most recent call last):     ... TypeError: Input value must be an 'int' type","range, isinstance, TypeError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\single_bit_manipulation_operations.py","","set_bit","Set the bit at position to 1.  Details: perform bitwise or for given number and X. Where X is a number with all the bits - zeroes and bit on given position - one.  >>> set_bit(0b1101, 1) # 0b1111 15 >>> set_bit(0b0, 5) # 0b100000 32 >>> set_bit(0b1111, 1) # 0b1111 15",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\single_bit_manipulation_operations.py","","clear_bit","Set the bit at position to 0.  Details: perform bitwise and for given number and X. Where X is a number with all the bits - ones and bit on given position - zero.  >>> clear_bit(0b10010, 1) # 0b10000 16 >>> clear_bit(0b0, 5) # 0b0 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\single_bit_manipulation_operations.py","","flip_bit","Flip the bit at position.  Details: perform bitwise xor for given number and X. Where X is a number with all the bits - zeroes and bit on given position - one.  >>> flip_bit(0b101, 1) # 0b111 7 >>> flip_bit(0b101, 0) # 0b100 4",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\single_bit_manipulation_operations.py","","is_bit_set","Is the bit at position set?  Details: Shift the bit at position to be the first (smallest) bit. Then check if the first bit is set by anding the shifted number with 1.  >>> is_bit_set(0b1010, 0) False >>> is_bit_set(0b1010, 1) True >>> is_bit_set(0b1010, 2) False >>> is_bit_set(0b1010, 3) True >>> is_bit_set(0b0, 17) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\single_bit_manipulation_operations.py","","get_bit","Get the bit at the given position  Details: perform bitwise and for the given number and X, Where X is a number with all the bits - zeroes and bit on given position - one. If the result is not equal to 0, then the bit on the given position is 1, else 0.  >>> get_bit(0b1010, 0) 0 >>> get_bit(0b1010, 1) 1 >>> get_bit(0b1010, 2) 0 >>> get_bit(0b1010, 3) 1","int"
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\swap_all_odd_and_even_bits.py","","show_bits",">>> print(show_bits(0, 0xFFFF))     0: 00000000 65535: 1111111111111111",""
"C:/Users/Joseph Dania/Desktop/python_repo\bit_manipulation\swap_all_odd_and_even_bits.py","","swap_odd_even_bits","1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and    odd bits (1, 3, 5, 7, etc.) in the input number. 2. We then right-shift the even bits by 1 position and left-shift the odd bits by    1 position to swap them. 3. Finally, we combine the swapped even and odd bits using a bitwise OR operation    to obtain the final result. >>> print(show_bits(0, swap_odd_even_bits(0)))     0: 00000000     0: 00000000 >>> print(show_bits(1, swap_odd_even_bits(1)))     1: 00000001     2: 00000010 >>> print(show_bits(2, swap_odd_even_bits(2)))     2: 00000010     1: 00000001 >>> print(show_bits(3, swap_odd_even_bits(3)))     3: 00000011     3: 00000011 >>> print(show_bits(4, swap_odd_even_bits(4)))     4: 00000100     8: 00001000 >>> print(show_bits(5, swap_odd_even_bits(5)))     5: 00000101    10: 00001010 >>> print(show_bits(6, swap_odd_even_bits(6)))     6: 00000110     9: 00001001 >>> print(show_bits(23, swap_odd_even_bits(23)))    23: 00010111    43: 00101011",""
"C:/Users/Joseph Dania/Desktop/python_repo\blockchain\diophantine_equation.py","","diophantine","Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the diophantine equation a*x + b*y = c has a solution (where x and y are integers) iff greatest_common_divisor(a,b) divides c.  GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )  >>> diophantine(10,6,14) (-7.0, 14.0)  >>> diophantine(391,299,-69) (9.0, -12.0)  But above equation has one more solution i.e., x = -4, y = 5. That's why we need diophantine all solution function.","extended_gcd, greatest_common_divisor"
"C:/Users/Joseph Dania/Desktop/python_repo\blockchain\diophantine_equation.py","","diophantine_all_soln","Lemma : if n|ab and gcd(a,n) = 1, then n|b.  Finding All solutions of Diophantine Equations:  Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the solutions have the form a(x0 + t*q) + b(y0 - t*p) = c, where t is an arbitrary integer.  n is the number of solution you want, n = 2 by default  >>> diophantine_all_soln(10, 6, 14) -7.0 14.0 -4.0 9.0  >>> diophantine_all_soln(10, 6, 14, 4) -7.0 14.0 -4.0 9.0 -1.0 4.0 2.0 -1.0  >>> diophantine_all_soln(391, 299, -69, n = 4) 9.0 -12.0 22.0 -29.0 35.0 -46.0 48.0 -63.0","diophantine, greatest_common_divisor, range, print"
"C:/Users/Joseph Dania/Desktop/python_repo\blockchain\diophantine_equation.py","","extended_gcd","Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x and y, then d = gcd(a,b)  >>> extended_gcd(10, 6) (2, -1, 2)  >>> extended_gcd(7, 5) (1, -2, 3)","extended_gcd"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\and_gate.py","","and_gate","Calculate AND of the input values  >>> and_gate(0, 0) 0 >>> and_gate(0, 1) 0 >>> and_gate(1, 0) 0 >>> and_gate(1, 1) 1","int"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\and_gate.py","","n_input_and_gate","Calculate AND of a list of input values  >>> n_input_and_gate([1, 0, 1, 1, 0]) 0 >>> n_input_and_gate([1, 1, 1, 1, 1]) 1","int, all"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\imply_gate.py","","imply_gate","Calculate IMPLY of the input values  >>> imply_gate(0, 0) 1 >>> imply_gate(0, 1) 1 >>> imply_gate(1, 0) 0 >>> imply_gate(1, 1) 1","int"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\imply_gate.py","","recursive_imply_list","Recursively calculates the implication of a list. Strictly the implication is applied consecutively left to right: ( (a -> b) -> c ) -> d ...  >>> recursive_imply_list([]) Traceback (most recent call last):     ... ValueError: Input list must contain at least two elements >>> recursive_imply_list([0]) Traceback (most recent call last):     ... ValueError: Input list must contain at least two elements >>> recursive_imply_list([1]) Traceback (most recent call last):     ... ValueError: Input list must contain at least two elements >>> recursive_imply_list([0, 0]) 1 >>> recursive_imply_list([0, 1]) 1 >>> recursive_imply_list([1, 0]) 0 >>> recursive_imply_list([1, 1]) 1 >>> recursive_imply_list([0, 0, 0]) 0 >>> recursive_imply_list([0, 0, 1]) 1 >>> recursive_imply_list([0, 1, 0]) 0 >>> recursive_imply_list([0, 1, 1]) 1 >>> recursive_imply_list([1, 0, 0]) 1 >>> recursive_imply_list([1, 0, 1]) 1 >>> recursive_imply_list([1, 1, 0]) 0 >>> recursive_imply_list([1, 1, 1]) 1","imply_gate, recursive_imply_list, len, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\karnaugh_map_simplification.py","","simplify_kmap","Simplify the Karnaugh map. >>> simplify_kmap(kmap=[[0, 1], [1, 1]]) ""A'B + AB' + AB"" >>> simplify_kmap(kmap=[[0, 0], [0, 0]]) '' >>> simplify_kmap(kmap=[[0, 1], [1, -1]]) ""A'B + AB' + AB"" >>> simplify_kmap(kmap=[[0, 1], [1, 2]]) ""A'B + AB' + AB"" >>> simplify_kmap(kmap=[[0, 1], [1, 1.1]]) ""A'B + AB' + AB"" >>> simplify_kmap(kmap=[[0, 1], [1, 'a']]) ""A'B + AB' + AB""","enumerate, .join, enumerate, simplified_f.append"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\karnaugh_map_simplification.py","","main","Main function to create and simplify a K-Map.  >>> main() [0, 1] [1, 1] Simplified Expression: A'B + AB' + AB","print, print, print, simplify_kmap"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\multiplexer.py","","mux","Implement a 2-to-1 Multiplexer.  :param input0: The first input value (0 or 1). :param input1: The second input value (0 or 1). :param select: The select signal (0 or 1) to choose between input0 and input1. :return: The output based on the select signal.  input1 if select else input0.  https://www.electrically4u.com/solved-problems-on-multiplexer https://en.wikipedia.org/wiki/Multiplexer  >>> mux(0, 1, 0) 0 >>> mux(0, 1, 1) 1 >>> mux(1, 0, 0) 1 >>> mux(1, 0, 1) 0 >>> mux(2, 1, 0) Traceback (most recent call last):     ... ValueError: Inputs and select signal must be 0 or 1 >>> mux(0, -1, 0) Traceback (most recent call last):     ... ValueError: Inputs and select signal must be 0 or 1 >>> mux(0, 1, 1.1) Traceback (most recent call last):     ... ValueError: Inputs and select signal must be 0 or 1","all, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\nand_gate.py","","nand_gate","Calculate NAND of the input values >>> nand_gate(0, 0) 1 >>> nand_gate(0, 1) 1 >>> nand_gate(1, 0) 1 >>> nand_gate(1, 1) 0","int"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\nimply_gate.py","","nimply_gate","Calculate NIMPLY of the input values  >>> nimply_gate(0, 0) 0 >>> nimply_gate(0, 1) 0 >>> nimply_gate(1, 0) 1 >>> nimply_gate(1, 1) 0","int"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\nor_gate.py","","nor_gate",">>> nor_gate(0, 0) 1 >>> nor_gate(0, 1) 0 >>> nor_gate(1, 0) 0 >>> nor_gate(1, 1) 0 >>> nor_gate(0.0, 0.0) 1 >>> nor_gate(0, -7) 0","int"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\nor_gate.py","","truth_table",">>> print(truth_table(nor_gate)) Truth Table of NOR Gate: | Input 1  | Input 2  |  Output  | |    0     |    0     |    1     | |    0     |    1     |    0     | |    1     |    0     |    0     | |    1     |    1     |    0     |",".join, make_table_row, .join, make_table_row, func"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\nor_gate.py","","make_table_row",">>> make_table_row((""One"", ""Two"", ""Three"")) '|   One    |   Two    |  Three   |'",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\not_gate.py","","not_gate","Calculate NOT of the input values >>> not_gate(0) 1 >>> not_gate(1) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\or_gate.py","","or_gate","Calculate OR of the input values >>> or_gate(0, 0) 0 >>> or_gate(0, 1) 1 >>> or_gate(1, 0) 1 >>> or_gate(1, 1) 1","int, .count"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","compare_string",">>> compare_string('0010','0110') '0_10'  >>> compare_string('0110','1101') False","list, list, range, len, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","check",">>> check(['0.00.01.5']) ['0.00.01.5']","range, range, list, len, len, range, len, len, set, len, compare_string, pi.append, temp.append"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","decimal_to_binary",">>> decimal_to_binary(3,[1.5]) ['0.00.01.5']","range, temp.append, str"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","is_for_table",">>> is_for_table('__1','011',2) True  >>> is_for_table('01_','001',1) False","list, list, sum, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","selection",">>> selection([[1]],['0.00.01.5']) ['0.00.01.5']  >>> selection([[1]],['0.00.01.5']) ['0.00.01.5']","range, enumerate, len, len, sum, range, temp.append, max, counts.index, temp.append, range, max, len, .count, len, range, range, len, len, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","prime_implicant_chart",">>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5']) [[1]]","range, len, .count, range, range, len, is_for_table, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\quine_mc_cluskey.py","","main","","int, decimal_to_binary, check, print, print, prime_implicant_chart, selection, print, print, input, float, .split, input"
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\xnor_gate.py","","xnor_gate","Calculate XOR of the input values >>> xnor_gate(0, 0) 1 >>> xnor_gate(0, 1) 0 >>> xnor_gate(1, 0) 0 >>> xnor_gate(1, 1) 1",""
"C:/Users/Joseph Dania/Desktop/python_repo\boolean_algebra\xor_gate.py","","xor_gate","calculate xor of the input values  >>> xor_gate(0, 0) 0 >>> xor_gate(0, 1) 1 >>> xor_gate(1, 0) 1 >>> xor_gate(1, 1) 0",".count"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\conways_game_of_life.py","","new_generation","Generates the next generation for a given state of Conway's Game of Life. >>> new_generation(BLINKER) [[0, 0, 0], [1, 1, 1], [0, 0, 0]]","range, len, range, next_generation.append, len, next_generation_row.append, next_generation_row.append, len, len, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\conways_game_of_life.py","","generate_images","Generates a list of images of subsequent Game of Life states.","range, Image.new, img.load, range, images.append, new_generation, len, range, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\game_of_life.py","","create_canvas","","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\game_of_life.py","","seed","","enumerate, enumerate, bool, random.getrandbits"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\game_of_life.py","","run","This function runs the rules of game through all points, and changes their status accordingly.(in the same canvas) @Args: -- canvas : canvas of population to run the rules on.  @returns: -- canvas of population after one step","np.array, np.array, enumerate, next_gen_canvas.tolist, create_canvas, enumerate, __judge_point"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\game_of_life.py","","__judge_point","",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\langtons_ant.py","LangtonsAnt","","Represents the main LangonsAnt algorithm.  >>> la = LangtonsAnt(2, 2) >>> la.board [[True, True], [True, True]] >>> la.ant_position (1, 1)",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\langtons_ant.py","","__init__","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\langtons_ant.py","","move_ant","Performs three tasks:     1. The ant turns either clockwise or anti-clockwise according to the colour     of the square that it is currently on. If the square is white, the ant     turns clockwise, and if the square is black the ant turns anti-clockwise     2. The ant moves one square in the direction that it is currently facing     3. The square the ant was previously on is inverted (White -> Black and     Black -> White)  If display is True, the board will also be displayed on the axes  >>> la = LangtonsAnt(2, 2) >>> la.move_ant(None, True, 0) >>> la.board [[True, True], [True, False]] >>> la.move_ant(None, True, 0) >>> la.board [[True, False], [True, False]]",".set_ticks, .set_ticks, axes.imshow, axes.get_xaxis, axes.get_yaxis"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\langtons_ant.py","","display","Displays the board without delay in a matplotlib plot to visually understand and track the ant.  >>> _ = LangtonsAnt(WIDTH, HEIGHT)","plt.subplots, FuncAnimation, plt.show, partial"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\nagel_schrekenberg.py","","construct_highway","Build the highway following the parameters given >>> construct_highway(10, 2, 6) [[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]] >>> construct_highway(10, 10, 2) [[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]","max, randint, randint"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\nagel_schrekenberg.py","","get_distance","Get the distance between a car (at index car_index) and the next car >>> get_distance([6, -1, 6, -1, 6], 2) 1 >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0) 3 >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1) 4","range, len, get_distance"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\nagel_schrekenberg.py","","update","Update the speed of the cars >>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5) [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4] >>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5) [-1, -1, 3, -1, -1, -1, -1, 1]","len, range, min, min, get_distance, random, max"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\nagel_schrekenberg.py","","simulate","The main function, it will simulate the evolution of the highway >>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3) [[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]] >>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3) [[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]","len, range, update, range, highway.append"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\one_dimensional.py","","format_ruleset",">>> format_ruleset(11100) [0, 0, 0, 1, 1, 1, 0, 0] >>> format_ruleset(0) [0, 0, 0, 0, 0, 0, 0, 0] >>> format_ruleset(11111111) [1, 1, 1, 1, 1, 1, 1, 1]","int"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\one_dimensional.py","","new_generation","","len, range, next_generation.append, int"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\one_dimensional.py","","generate_image","Convert the cells into a greyscale PIL.Image.Image and return it to the caller. >>> from random import random >>> cells = [[random() for w in range(31)] for h in range(16)] >>> img = generate_image(cells) >>> isinstance(img, Image.Image) True >>> img.width, img.height (31, 16)","Image.new, img.load, range, range, len, len, int"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","Entity","","Represents an entity (either prey or predator).  >>> e = Entity(True, coords=(0, 0)) >>> e.prey True >>> e.coords (0, 0) >>> e.alive True",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","WaTor","","Represents the main Wa-Tor algorithm.  :attr time_passed: A function that is called every time     time passes (a chronon) in order to visually display     the new Wa-Tor planet. The `time_passed` function can block     using ``time.sleep`` to slow the algorithm progression.  >>> wt = WaTor(10, 15) >>> wt.width 10 >>> wt.height 15 >>> len(wt.planet) 15 >>> len(wt.planet[0]) 10 >>> len(wt.get_entities()) == PREDATOR_INITIAL_COUNT + PREY_INITIAL_COUNT True",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","visualise","Visually displays the Wa-Tor planet using an ascii code in terminal to clear and re-print the Wa-Tor planet at intervals.  Uses ascii colour codes to colourfully display the predators and prey:     * (0x60f197) Prey = ``#``     * (0xfffff) Predator = ``x``  >>> wt = WaTor(30, 30) >>> wt.set_planet([ ... [Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1)), None], ... [Entity(False, coords=(1, 0)), None, Entity(False, coords=(1, 2))], ... [None, Entity(True, coords=(2, 1)), None] ... ]) >>> visualise(wt, 0, colour=False)  # doctest: +NORMALIZE_WHITESPACE #  x  . x  .  x .  #  . <BLANKLINE> Iteration: 0 | Prey count: 2 | Predator count: 3 |","wt.get_entities, sum, print, sleep, .system, print, __import__, len"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","reset_reproduction_time",">>> e = Entity(True, coords=(0, 0)) >>> e.reset_reproduction_time() >>> e.remaining_reproduction_time == PREY_REPRODUCTION_TIME True >>> e = Entity(False, coords=(0, 0)) >>> e.reset_reproduction_time() >>> e.remaining_reproduction_time == PREDATOR_REPRODUCTION_TIME True",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","__repr__",">>> Entity(prey=True, coords=(1, 1)) Entity(prey=True, coords=(1, 1), remaining_reproduction_time=5) >>> Entity(prey=False, coords=(2, 1))  # doctest: +NORMALIZE_WHITESPACE Entity(prey=False, coords=(2, 1), remaining_reproduction_time=20, energy_value=15)",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","__init__","","range, range, self.set_planet, self.add_entity, self.add_entity, range"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","set_planet","Ease of access for testing  >>> wt = WaTor(WIDTH, HEIGHT) >>> planet = [ ... [None, None, None], ... [None, Entity(True, coords=(1, 1)), None] ... ] >>> wt.set_planet(planet) >>> wt.planet == planet True >>> wt.width 3 >>> wt.height 2","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","add_entity","Adds an entity, making sure the entity does not override another entity  >>> wt = WaTor(WIDTH, HEIGHT) >>> wt.set_planet([[None, None], [None, None]]) >>> wt.add_entity(True) >>> len(wt.get_entities()) 1 >>> wt.add_entity(False) >>> len(wt.get_entities()) 2","randint, randint, Entity"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","get_entities","Returns a list of all the entities within the planet.  >>> wt = WaTor(WIDTH, HEIGHT) >>> len(wt.get_entities()) == PREDATOR_INITIAL_COUNT + PREY_INITIAL_COUNT True",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","balance_predators_and_prey","Balances predators and preys so that prey can not dominate the predators, blocking up space for them to reproduce.  >>> wt = WaTor(WIDTH, HEIGHT) >>> for i in range(2000): ...     row, col = i // HEIGHT, i % WIDTH ...     wt.planet[row][col] = Entity(True, coords=(row, col)) >>> entities = len(wt.get_entities()) >>> wt.balance_predators_and_prey() >>> len(wt.get_entities()) == entities False","self.get_entities, shuffle, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","get_surrounding_prey","Returns all the prey entities around (N, S, E, W) a predator entity.  Subtly different to the `move_and_reproduce`.  >>> wt = WaTor(WIDTH, HEIGHT) >>> wt.set_planet([ ... [None, Entity(True, (0, 1)), None], ... [None, Entity(False, (1, 1)), None], ... [None, Entity(True, (2, 1)), None]]) >>> wt.get_surrounding_prey( ... Entity(False, (1, 1)))  # doctest: +NORMALIZE_WHITESPACE [Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5), Entity(prey=True, coords=(2, 1), remaining_reproduction_time=5)] >>> wt.set_planet([[Entity(False, (0, 0))]]) >>> wt.get_surrounding_prey(Entity(False, (0, 0))) [] >>> wt.set_planet([ ... [Entity(True, (0, 0)), Entity(False, (1, 0)), Entity(False, (2, 0))], ... [None, Entity(False, (1, 1)), Entity(True, (2, 1))], ... [None, None, None]]) >>> wt.get_surrounding_prey(Entity(False, (1, 0))) [Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5)]",""
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","move_and_reproduce","Attempts to move to an unoccupied neighbouring square in either of the four directions (North, South, East, West). If the move was successful and the `remaining_reproduction_time` is equal to 0, then a new prey or predator can also be created in the previous square.  :param direction_orders: Ordered list (like priority queue) depicting                     order to attempt to move. Removes any systematic                     approach of checking neighbouring squares.  >>> planet = [ ... [None, None, None], ... [None, Entity(True, coords=(1, 1)), None], ... [None, None, None] ... ] >>> wt = WaTor(WIDTH, HEIGHT) >>> wt.set_planet(planet) >>> wt.move_and_reproduce(Entity(True, coords=(1, 1)), direction_orders=[""N""]) >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE [[None, Entity(prey=True, coords=(0, 1), remaining_reproduction_time=4), None], [None, None, None], [None, None, None]] >>> wt.planet[0][0] = Entity(True, coords=(0, 0)) >>> wt.move_and_reproduce(Entity(True, coords=(0, 1)), ... direction_orders=[""N"", ""W"", ""E"", ""S""]) >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None, Entity(prey=True, coords=(0, 2), remaining_reproduction_time=4)], [None, None, None], [None, None, None]] >>> wt.planet[0][1] = wt.planet[0][2] >>> wt.planet[0][2] = None >>> wt.move_and_reproduce(Entity(True, coords=(0, 1)), ... direction_orders=[""N"", ""W"", ""S"", ""E""]) >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None, None], [None, Entity(prey=True, coords=(1, 1), remaining_reproduction_time=4), None], [None, None, None]]  >>> wt = WaTor(WIDTH, HEIGHT) >>> reproducable_entity = Entity(False, coords=(0, 1)) >>> reproducable_entity.remaining_reproduction_time = 0 >>> wt.planet = [[None, reproducable_entity]] >>> wt.move_and_reproduce(reproducable_entity, ... direction_orders=[""N"", ""W"", ""S"", ""E""]) >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE [[Entity(prey=False, coords=(0, 0), remaining_reproduction_time=20, energy_value=15), Entity(prey=False, coords=(0, 1), remaining_reproduction_time=20, energy_value=15)]]","adjacent.append, len, Entity, entity.reset_reproduction_time, self.get_entities"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","perform_prey_actions","Performs the actions for a prey entity  For prey the rules are:     1. At each chronon, a prey moves randomly to one of the adjacent unoccupied        squares. If there are no free squares, no movement takes place.     2. Once a prey has survived a certain number of chronons it may reproduce.        This is done as it moves to a neighbouring square,        leaving behind a new prey in its old position.        Its reproduction time is also reset to zero.  >>> wt = WaTor(WIDTH, HEIGHT) >>> reproducable_entity = Entity(True, coords=(0, 1)) >>> reproducable_entity.remaining_reproduction_time = 0 >>> wt.planet = [[None, reproducable_entity]] >>> wt.perform_prey_actions(reproducable_entity, ... direction_orders=[""N"", ""W"", ""S"", ""E""]) >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE [[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5)]]","self.move_and_reproduce"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","perform_predator_actions","Performs the actions for a predator entity  :param occupied_by_prey_coords: Move to this location if there is prey there  For predators the rules are:     1. At each chronon, a predator moves randomly to an adjacent square occupied        by a prey. If there is none, the predator moves to a random adjacent        unoccupied square. If there are no free squares, no movement takes place.     2. At each chronon, each predator is deprived of a unit of energy.     3. Upon reaching zero energy, a predator dies.     4. If a predator moves to a square occupied by a prey,        it eats the prey and earns a certain amount of energy.     5. Once a predator has survived a certain number of chronons        it may reproduce in exactly the same way as the prey.  >>> wt = WaTor(WIDTH, HEIGHT) >>> wt.set_planet([[Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1))]]) >>> wt.perform_predator_actions(Entity(False, coords=(0, 1)), (0, 0), []) >>> wt.planet  # doctest: +NORMALIZE_WHITESPACE [[Entity(prey=False, coords=(0, 0), remaining_reproduction_time=20, energy_value=19), None]]","self.move_and_reproduce"
"C:/Users/Joseph Dania/Desktop/python_repo\cellular_automata\wa_tor.py","","run","Emulate time passing by looping `iteration_count` times  >>> wt = WaTor(WIDTH, HEIGHT) >>> wt.run(iteration_count=PREDATOR_INITIAL_ENERGY_VALUE - 1) >>> len(list(filter(lambda entity: entity.prey is False, ... wt.get_entities()))) >= PREDATOR_INITIAL_COUNT True","range, self.get_entities, range, self.balance_predators_and_prey, len, all_entities.pop, shuffle, self.time_passed, randint, self.perform_prey_actions, self.get_surrounding_prey, self.perform_predator_actions, shuffle, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\a1z26.py","","encode",">>> encode(""myname"") [13, 25, 14, 1, 13, 5]","ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\a1z26.py","","decode",">>> decode([13, 25, 14, 1, 13, 5]) 'myname'",".join, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\a1z26.py","","main","","encode, print, print, .lower, decode, .strip, input"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\affine_cipher.py","","check_keys","","sys.exit, gcd_by_iterative, sys.exit, sys.exit, sys.exit, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\affine_cipher.py","","encrypt_message",">>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic ' ...                       'substitution cipher.') 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'","divmod, check_keys, len, SYMBOLS.find, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\affine_cipher.py","","decrypt_message",">>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF' ...                       '{xIp~{HL}Gi') 'The affine cipher is a type of monoalphabetic substitution cipher.'","divmod, check_keys, cryptomath.find_mod_inverse, len, len, SYMBOLS.find, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\affine_cipher.py","","get_random_key","","random.randint, random.randint, len, len, gcd_by_iterative, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\affine_cipher.py","","main",">>> key = get_random_key() >>> msg = ""This is a test!"" >>> decrypt_message(key, encrypt_message(key, msg)) == msg True",".strip, int, .lower, mode.startswith, print, .strip, encrypt_message, mode.startswith, input, .strip, decrypt_message, input, mode.title, input"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\atbash.py","","atbash_slow",">>> atbash_slow(""ABCDEFG"") 'ZYXWVUT'  >>> atbash_slow(""aW;;123BX"") 'zD;;123YC'","ord, chr, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\atbash.py","","atbash",">>> atbash(""ABCDEFG"") 'ZYXWVUT'  >>> atbash(""aW;;123BX"") 'zD;;123YC'",".join, letters.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\atbash.py","","benchmark","Let's benchmark our functions side-by-side...","print, print, print, timeit, timeit"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\autokey.py","","encrypt","Encrypt a given `plaintext` (string) and `key` (string), returning the encrypted ciphertext.  >>> encrypt(""hello world"", ""coffee"") 'jsqqs avvwo' >>> encrypt(""coffee is good as python"", ""TheAlgorithms"") 'vvjfpk wj ohvp su ddylsv' >>> encrypt(""coffee is good as python"", 2) Traceback (most recent call last):     ... TypeError: key must be a string >>> encrypt("""", ""TheAlgorithms"") Traceback (most recent call last):     ... ValueError: plaintext is empty >>> encrypt(""coffee is good as python"", """") Traceback (most recent call last):     ... ValueError: key is empty >>> encrypt(527.26, ""TheAlgorithms"") Traceback (most recent call last):     ... TypeError: plaintext must be a string","plaintext.lower, key.lower, isinstance, TypeError, isinstance, TypeError, ValueError, ValueError, len, ord, ord, chr, ord, ord, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\autokey.py","","decrypt","Decrypt a given `ciphertext` (string) and `key` (string), returning the decrypted ciphertext.  >>> decrypt(""jsqqs avvwo"", ""coffee"") 'hello world' >>> decrypt(""vvjfpk wj ohvp su ddylsv"", ""TheAlgorithms"") 'coffee is good as python' >>> decrypt(""vvjfpk wj ohvp su ddylsv"", """") Traceback (most recent call last):     ... ValueError: key is empty >>> decrypt(527.26, ""TheAlgorithms"") Traceback (most recent call last):     ... TypeError: ciphertext must be a string >>> decrypt("""", ""TheAlgorithms"") Traceback (most recent call last):     ... ValueError: ciphertext is empty >>> decrypt(""vvjfpk wj ohvp su ddylsv"", 2) Traceback (most recent call last):     ... TypeError: key must be a string","key.lower, isinstance, TypeError, isinstance, TypeError, ValueError, ValueError, len, chr, chr, ord, ord, ord, ord, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\baconian_cipher.py","","encode","Encodes to Baconian cipher  >>> encode(""hello"") 'AABBBAABAAABABAABABAABBAB' >>> encode(""hello world"") 'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB' >>> encode(""hello world!"") Traceback (most recent call last):     ... Exception: encode() accepts only letters of the alphabet and spaces","word.lower, letter.isalpha, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\baconian_cipher.py","","decode","Decodes from Baconian cipher  >>> decode(""AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB"") 'hello world' >>> decode(""AABBBAABAAABABAABABAABBAB"") 'hello' >>> decode(""AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!"") Traceback (most recent call last):     ... Exception: decode() accepts only 'A', 'B' and spaces","coded.split, decoded.strip, set, Exception, set, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base16.py","","base16_encode","Encodes the given bytes into base16.  >>> base16_encode(b'Hello World!') '48656C6C6F20576F726C6421' >>> base16_encode(b'HELLO WORLD!') '48454C4C4F20574F524C4421' >>> base16_encode(b'') ''",".join, .upper, list, .zfill, hex"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base16.py","","base16_decode","Decodes the given base16 encoded data into bytes.  >>> base16_decode('48656C6C6F20576F726C6421') b'Hello World!' >>> base16_decode('48454C4C4F20574F524C4421') b'HELLO WORLD!' >>> base16_decode('') b'' >>> base16_decode('486') Traceback (most recent call last):   ... ValueError: Base16 encoded data is invalid: Data does not have an even number of hex digits. >>> base16_decode('48656c6c6f20576f726c6421') Traceback (most recent call last):   ... ValueError: Base16 encoded data is invalid: Data is not uppercase hex or it contains invalid characters. >>> base16_decode('This is not base64 encoded data.') Traceback (most recent call last):   ... ValueError: Base16 encoded data is invalid: Data is not uppercase hex or it contains invalid characters.","bytes, ValueError, ValueError, len, set, set, int, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base32.py","","base32_encode",">>> base32_encode(b""Hello World!"") b'JBSWY3DPEBLW64TMMQQQ====' >>> base32_encode(b""123456"") b'GEZDGNBVGY======' >>> base32_encode(b""some long complex string"") b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='",".join, binary_data.ljust, map, .join, bytes, zip, b32_result.ljust, .zfill, data.decode, int, len, bin, iter, len, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base32.py","","base32_decode",">>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====') b'Hello World!' >>> base32_decode(b'GEZDGNBVGY======') b'123456' >>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=') b'some long complex string'",".join, list, bytes, map, .join, .zfill, zip, .strip, chr, int, bin, data.decode, B32_CHARSET.index, iter"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base64_cipher.py","","base64_encode","Encodes data according to RFC4648.  The data is first transformed to binary and appended with binary digits so that its length becomes a multiple of 6, then each 6 binary digits will match a character in the B64_CHARSET string. The number of appended binary digits would later determine how many ""="" signs should be added, the padding. For every 2 binary digits added, a ""="" sign is added in the output. We can add any binary digits to make it a multiple of 6, for instance, consider the following example: ""AA"" -> 0010100100101001 -> 001010 010010 1001 As can be seen above, 2 more binary digits should be added, so there's 4 possibilities here: 00, 01, 10 or 11. That being said, Base64 encoding can be used in Steganography to hide data in these appended digits.  >>> from base64 import b64encode >>> a = b""This pull request is part of Hacktoberfest20!"" >>> b = b""https://tools.ietf.org/html/rfc4648"" >>> c = b""A"" >>> base64_encode(a) == b64encode(a) True >>> base64_encode(b) == b64encode(b) True >>> base64_encode(c) == b64encode(c) True >>> base64_encode(""abc"") Traceback (most recent call last):   ... TypeError: a bytes-like object is required, not 'str'",".join, isinstance, TypeError, .encode, .zfill, len, .join, len, bin, len, int, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base64_cipher.py","","base64_decode","Decodes data according to RFC4648.  This does the reverse operation of base64_encode. We first transform the encoded data back to a binary stream, take off the previously appended binary digits according to the padding, at this point we would have a binary stream whose length is multiple of 8, the last step is to convert every 8 bits to a byte.  >>> from base64 import b64decode >>> a = ""VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh"" >>> b = ""aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg="" >>> c = ""QQ=="" >>> base64_decode(a) == b64decode(a) True >>> base64_decode(b) == b64decode(b) True >>> base64_decode(c) == b64decode(c) True >>> base64_decode(""abc"") Traceback (most recent call last):   ... AssertionError: Incorrect padding","isinstance, encoded_data.count, bytes, TypeError, all, all, .join, int, isinstance, isinstance, encoded_data.decode, .join, range, ValueError, len, .zfill, len, .zfill, bin, bin, B64_CHARSET.index, B64_CHARSET.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base85.py","","_base10_to_85","",".join, _base10_to_85, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base85.py","","_base85_to_10","","sum, enumerate, reversed"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base85.py","","ascii85_encode",">>> ascii85_encode(b"""") b'' >>> ascii85_encode(b""12345"") b'0etOA2#' >>> ascii85_encode(b""base 85"") b'@UX=h+?24'",".join, binary_data.ljust, .join, bytes, int, .zfill, len, map, data.decode, zip, _base10_to_85, len, bin, len, ord, iter"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\base85.py","","ascii85_decode",">>> ascii85_decode(b"""") b'' >>> ascii85_decode(b""0etOA2#"") b'12345' >>> ascii85_decode(b""@UX=h+?24"") b'base 85'","map, .join, int, bytes, len, data.decode, zip, .zfill, chr, .join, ord, int, map, len, bin, zip, iter, _base85_to_10, iter"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\beaufort_cipher.py","","generate_key",">>> generate_key(""THE GERMAN ATTACK"",""SECRET"") 'SECRETSECRETSECRE'","len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\beaufort_cipher.py","","cipher_text",">>> cipher_text(""THE GERMAN ATTACK"",""SECRETSECRETSECRE"") 'BDC PAYUWL JPAIYI'",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\beaufort_cipher.py","","original_text",">>> original_text(""BDC PAYUWL JPAIYI"",""SECRETSECRETSECRE"") 'THE GERMAN ATTACK'",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\beaufort_cipher.py","","main","","generate_key, cipher_text, print, print, original_text"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\bifid.py","BifidCipher","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\bifid.py","","__init__","","np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\bifid.py","","letter_to_numbers","Return the pair of numbers that represents the given letter in the polybius square  >>> np.array_equal(BifidCipher().letter_to_numbers('a'), [1,1]) True  >>> np.array_equal(BifidCipher().letter_to_numbers('u'), [4,5]) True","np.where, np.concatenate"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\bifid.py","","numbers_to_letter","Return the letter corresponding to the position [index1, index2] in the polybius square  >>> BifidCipher().numbers_to_letter(4, 5) == ""u"" True  >>> BifidCipher().numbers_to_letter(1, 1) == ""a"" True",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\bifid.py","","encode","Return the encoded version of message according to the polybius cipher  >>> BifidCipher().encode('testmessage') == 'qtltbdxrxlk' True  >>> BifidCipher().encode('Test Message') == 'qtltbdxrxlk' True  >>> BifidCipher().encode('test j') == BifidCipher().encode('test i') True","message.lower, message.replace, message.replace, np.empty, range, first_step.reshape, range, len, self.letter_to_numbers, len, int, int, self.numbers_to_letter, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\bifid.py","","decode","Return the decoded version of message according to the polybius cipher  >>> BifidCipher().decode('qtltbdxrxlk') == 'testmessage' True","message.lower, message.replace, np.empty, range, first_step.reshape, range, len, self.letter_to_numbers, len, int, int, self.numbers_to_letter, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\brute_force_caesar_cipher.py","","decrypt",">>> decrypt('TMDETUX PMDVU') Decryption using Key #0: TMDETUX PMDVU Decryption using Key #1: SLCDSTW OLCUT Decryption using Key #2: RKBCRSV NKBTS Decryption using Key #3: QJABQRU MJASR Decryption using Key #4: PIZAPQT LIZRQ Decryption using Key #5: OHYZOPS KHYQP Decryption using Key #6: NGXYNOR JGXPO Decryption using Key #7: MFWXMNQ IFWON Decryption using Key #8: LEVWLMP HEVNM Decryption using Key #9: KDUVKLO GDUML Decryption using Key #10: JCTUJKN FCTLK Decryption using Key #11: IBSTIJM EBSKJ Decryption using Key #12: HARSHIL DARJI Decryption using Key #13: GZQRGHK CZQIH Decryption using Key #14: FYPQFGJ BYPHG Decryption using Key #15: EXOPEFI AXOGF Decryption using Key #16: DWNODEH ZWNFE Decryption using Key #17: CVMNCDG YVMED Decryption using Key #18: BULMBCF XULDC Decryption using Key #19: ATKLABE WTKCB Decryption using Key #20: ZSJKZAD VSJBA Decryption using Key #21: YRIJYZC URIAZ Decryption using Key #22: XQHIXYB TQHZY Decryption using Key #23: WPGHWXA SPGYX Decryption using Key #24: VOFGVWZ ROFXW Decryption using Key #25: UNEFUVY QNEWV","range, len, print, string.ascii_uppercase.find, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\brute_force_caesar_cipher.py","","main","","input, message.upper, decrypt"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\caesar_cipher.py","","encrypt","encrypt =======  Encodes a given string with the caesar cipher and returns the encoded message  Parameters: -----------  *   `input_string`: the plain-text that needs to be encoded *   `key`: the number of letters to shift the message by  Optional:  *   `alphabet` (``None``): the alphabet used to encode the cipher, if not     specified, the standard english alphabet with upper and lowercase     letters is used  Returns:  *   A string containing the encoded cipher-text  More on the caesar cipher =========================  The caesar cipher is named after Julius Caesar who used it when sending secret military messages to his troops. This is a simple substitution cipher where every character in the plain-text is shifted by a certain number known as the ""key"" or ""shift"".  Example: Say we have the following message: ``Hello, captain``  And our alphabet is made up of lower and uppercase letters: ``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``  And our shift is ``2``  We can then encode the message, one letter at a time. ``H`` would become ``J``, since ``J`` is two letters away, and so on. If the shift is ever two large, or our letter is at the end of the alphabet, we just start at the beginning (``Z`` would shift to ``a`` then ``b`` and so on).  Our final message would be ``Jgnnq, ecrvckp``  Further reading ===============  *   https://en.m.wikipedia.org/wiki/Caesar_cipher  Doctests ========  >>> encrypt('The quick brown fox jumps over the lazy dog', 8) 'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'  >>> encrypt('A very large key', 8000) 's nWjq dSjYW cWq'  >>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz') 'f qtbjwhfxj fqumfgjy'","len, alpha.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\caesar_cipher.py","","decrypt","decrypt =======  Decodes a given string of cipher-text and returns the decoded plain-text  Parameters: -----------  *   `input_string`: the cipher-text that needs to be decoded *   `key`: the number of letters to shift the message backwards by to decode  Optional:  *   `alphabet` (``None``): the alphabet used to decode the cipher, if not     specified, the standard english alphabet with upper and lowercase     letters is used  Returns:  *   A string containing the decoded plain-text  More on the caesar cipher =========================  The caesar cipher is named after Julius Caesar who used it when sending secret military messages to his troops. This is a simple substitution cipher where very character in the plain-text is shifted by a certain number known as the ""key"" or ""shift"". Please keep in mind, here we will be focused on decryption.  Example: Say we have the following cipher-text: ``Jgnnq, ecrvckp``  And our alphabet is made up of lower and uppercase letters: ``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ``  And our shift is ``2``  To decode the message, we would do the same thing as encoding, but in reverse. The first letter, ``J`` would become ``H`` (remember: we are decoding) because ``H`` is two letters in reverse (to the left) of ``J``. We would continue doing this. A letter like ``a`` would shift back to the end of the alphabet, and would become ``Z`` or ``Y`` and so on.  Our final message would be ``Hello, captain``  Further reading ===============  *   https://en.m.wikipedia.org/wiki/Caesar_cipher  Doctests ========  >>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8) 'The quick brown fox jumps over the lazy dog'  >>> decrypt('s nWjq dSjYW cWq', 8000) 'A very large key'  >>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz') 'a lowercase alphabet'","encrypt"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\caesar_cipher.py","","brute_force","brute_force ===========  Returns all the possible combinations of keys and the decoded strings in the form of a dictionary  Parameters: -----------  *   `input_string`: the cipher-text that needs to be used during brute-force  Optional:  *   `alphabet` (``None``): the alphabet used to decode the cipher, if not     specified, the standard english alphabet with upper and lowercase     letters is used  More about brute force ======================  Brute force is when a person intercepts a message or password, not knowing the key and tries every single combination. This is easy with the caesar cipher since there are only all the letters in the alphabet. The more complex the cipher, the larger amount of time it will take to do brute force  Ex: Say we have a ``5`` letter alphabet (``abcde``), for simplicity and we intercepted the following message: ``dbc``, we could then just write out every combination: ``ecd``... and so on, until we reach a combination that makes sense: ``cab``  Further reading ===============  *   https://en.wikipedia.org/wiki/Brute_force  Doctests ========  >>> brute_force(""jFyuMy xIH'N vLONy zILwy Gy!"")[20] ""Please don't brute force me!""  >>> brute_force(1) Traceback (most recent call last): TypeError: 'int' object is not iterable","range, decrypt, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\cryptomath_module.py","","find_mod_inverse","","gcd_by_iterative, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\decrypt_caesar_with_chi_squared.py","","decrypt_caesar_with_chi_squared","Basic Usage ===========  Arguments:   * `ciphertext` (str): the text to decode (encoded with the caesar cipher)  Optional Arguments:   * `cipher_alphabet` (list): the alphabet used for the cipher (each letter is     a string separated by commas)   * `frequencies_dict` (dict): a dictionary of word frequencies where keys are     the letters and values are a percentage representation of the frequency as     a decimal/float   * `case_sensitive` (bool): a boolean value: ``True`` if the case matters during     decryption, ``False`` if it doesn't  Returns:   * A tuple in the form of:     (`most_likely_cipher`, `most_likely_cipher_chi_squared_value`,     `decoded_most_likely_cipher`)      where...       - `most_likely_cipher` is an integer representing the shift of the smallest         chi-squared statistic (most likely key)       - `most_likely_cipher_chi_squared_value` is a float representing the         chi-squared statistic of the most likely shift       - `decoded_most_likely_cipher` is a string with the decoded cipher         (decoded by the most_likely_cipher key)   The Chi-squared test ====================  The caesar cipher -----------------  The caesar cipher is a very insecure encryption algorithm, however it has been used since Julius Caesar. The cipher is a simple substitution cipher where each character in the plain text is replaced by a character in the alphabet a certain number of characters after the original character. The number of characters away is called the shift or key. For example:  | Plain text: ``hello`` | Key: ``1`` | Cipher text: ``ifmmp`` | (each letter in ``hello`` has been shifted one to the right in the eng. alphabet)  As you can imagine, this doesn't provide lots of security. In fact decrypting ciphertext by brute-force is extremely easy even by hand. However one way to do that is the chi-squared test.  The chi-squared test --------------------  Each letter in the english alphabet has a frequency, or the amount of times it shows up compared to other letters (usually expressed as a decimal representing the percentage likelihood). The most common letter in the english language is ``e`` with a frequency of ``0.11162`` or ``11.162%``. The test is completed in the following fashion.  1. The ciphertext is decoded in a brute force way (every combination of the    ``26`` possible combinations) 2. For every combination, for each letter in the combination, the average    amount of times the letter should appear the message is calculated by    multiplying the total number of characters by the frequency of the letter.     | For example:    | In a message of ``100`` characters, ``e`` should appear around ``11.162``      times.  3. Then, to calculate the margin of error (the amount of times the letter    SHOULD appear with the amount of times the letter DOES appear), we use    the chi-squared test. The following formula is used:     Let:      - n be the number of times the letter actually appears      - p be the predicted value of the number of times the letter should        appear (see item ``2``)      - let v be the chi-squared test result (referred to here as chi-squared        value/statistic)       ::         (n - p)^2        --------- = v           p  4. Each chi squared value for each letter is then added up to the total.    The total is the chi-squared statistic for that encryption key. 5. The encryption key with the lowest chi-squared value is the most likely    to be the decoded answer.  Further Reading ===============  * http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-statistic/ * https://en.wikipedia.org/wiki/Letter_frequency * https://en.wikipedia.org/wiki/Chi-squared_test * https://en.m.wikipedia.org/wiki/Caesar_cipher  Doctests ========  >>> decrypt_caesar_with_chi_squared( ...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!' ... )  # doctest: +NORMALIZE_WHITESPACE (7, 3129.228005747531,  'why is the caesar cipher so popular? it is too easy to crack!')  >>> decrypt_caesar_with_chi_squared('crybd cdbsxq') (10, 233.35343938980898, 'short string')  >>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True) (10, 233.35343938980898, 'Short String')  >>> decrypt_caesar_with_chi_squared(12) Traceback (most recent call last): AttributeError: 'int' object has no attribute 'lower'","range, min, ciphertext.lower, len, chr, range, letter.lower, len, .upper, .count, letter.lower, decrypted_with_shift.count, alphabet_letters.index, letter.isupper, letter.lower, decrypted_with_shift.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\decrypt_caesar_with_chi_squared.py","","chi_squared_statistic_values_sorting_key","",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\deterministic_miller_rabin.py","","miller_rabin","Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.  Uses numerical analysis results to return whether or not the passed number is prime. If the passed number is above the upper limit, and allow_probable is True, then a return value of True indicates that n is probably prime. This test does not allow False negatives- a return value of False is ALWAYS composite.  Parameters ---------- n : int     The integer to be tested. Since we usually care if a number is prime,     n < 2 returns False instead of raising a ValueError. allow_probable: bool, default False     Whether or not to test n above the upper bound of the deterministic test.  Raises ------ ValueError  Reference --------- https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test","enumerate, ValueError, range, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\deterministic_miller_rabin.py","","test_miller_rabin","Testing a nontrivial (ends in 1, 3, 7, 9) composite and a prime in each range.","miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin, miller_rabin"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie.py","","find_primitive","Find a primitive root modulo modulus, if one exists.  Args:     modulus : The modulus for which to find a primitive root.  Returns:     The primitive root if one exists, or None if there is none.  Examples: >>> find_primitive(7)  # Modulo 7 has primitive root 3 3 >>> find_primitive(11)  # Modulo 11 has primitive root 2 2 >>> find_primitive(8) == None # Modulo 8 has no primitive root True","range, range, pow, li.append"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","DiffieHellman","","Class to represent the Diffie-Hellman key exchange protocol   >>> alice = DiffieHellman() >>> bob = DiffieHellman()  >>> alice_private = alice.get_private_key() >>> alice_public = alice.generate_public_key()  >>> bob_private = bob.get_private_key() >>> bob_public = bob.generate_public_key()  >>> # generating shared key using the DH object >>> alice_shared = alice.generate_shared_key(bob_public) >>> bob_shared = bob.generate_shared_key(alice_public)  >>> assert alice_shared == bob_shared  >>> # generating shared key using static methods >>> alice_shared = DiffieHellman.generate_shared_key_static( ...     alice_private, bob_public ... ) >>> bob_shared = DiffieHellman.generate_shared_key_static( ...     bob_private, alice_public ... )  >>> assert alice_shared == bob_shared",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","__init__","","int, ValueError, hexlify, urandom"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","get_private_key","","hex"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","generate_public_key","","pow, hex"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","is_valid_public_key","","pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","generate_shared_key","","int, pow, .hexdigest, self.is_valid_public_key, ValueError, sha256, .encode, str"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","is_valid_public_key_static","","pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\diffie_hellman.py","","generate_shared_key_static","","int, int, pow, .hexdigest, DiffieHellman.is_valid_public_key_static, ValueError, sha256, .encode, str"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\elgamal_key_generator.py","","primitive_root","","print, random.randrange, pow, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\elgamal_key_generator.py","","generate_key","","print, rabin_miller.generate_large_prime, primitive_root, random.randrange, cryptomath.find_mod_inverse, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\elgamal_key_generator.py","","make_key_files","","generate_key, print, print, os.path.exists, os.path.exists, print, print, sys.exit, open, fo.write, open, fo.write"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\elgamal_key_generator.py","","main","","print, make_key_files, print"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\enigma_machine2.py","","_validator","Checks if the values can be used for the ``enigma`` function  >>> _validator((1,1,1), (rotor1, rotor2, rotor3), 'POLAND') ((1, 1, 1), ('EGZWVONAHDCLFQMSIPJBYUKXTR', 'FOBHMDKEXQNRAULPGSJVTYICZW', 'ZJXESIUQLHAVRMDOYGTNFWPBKC'), {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'})  :param rotpos: rotor_positon :param rotsel: rotor_selection :param pb: plugb -> validated and transformed :return: (`rotpos`, `rotsel`, `pb`)","_plugboard, Exception, ValueError, ValueError, ValueError, len, len, len, len, set"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\enigma_machine2.py","","_plugboard","https://en.wikipedia.org/wiki/Enigma_machine#Plugboard  >>> _plugboard('PICTURES') {'P': 'I', 'I': 'P', 'C': 'T', 'T': 'C', 'U': 'R', 'R': 'U', 'E': 'S', 'S': 'E'} >>> _plugboard('POLAND') {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'}  In the code, ``pb`` stands for ``plugboard``  Pairs can be separated by spaces  :param pbstring: string containing plugboard setting for the Enigma machine :return: dictionary containing converted pairs","pbstring.replace, set, range, isinstance, TypeError, Exception, Exception, len, type, len, Exception, tmppbl.add, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\enigma_machine2.py","","enigma","The only difference with real-world enigma is that ``I`` allowed string input. All characters are converted to uppercase. (non-letter symbol are ignored)  | How it works: | (for every letter in the message)  - Input letter goes into the plugboard.   If it is connected to another one, switch it.  - Letter goes through ``3`` rotors.   Each rotor can be represented as ``2`` sets of symbol, where one is shuffled.   Each symbol from the first set has corresponding symbol in   the second set and vice versa.    example::    | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F   | VKLEPDBGRNWTFCJOHQAMUZYIXS |  - Symbol then goes through reflector (static rotor).   There it is switched with paired symbol.   The reflector can be represented as ``2`` sets, each with half of the alphanet.   There are usually ``10`` pairs of letters.    Example::    | ABCDEFGHIJKLM | e.g. E is paired to X   | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa  - Letter then goes through the rotors again  - If the letter is connected to plugboard, it is switched.  - Return the letter  >>> enigma('Hello World!', (1, 2, 1), plugb='pictures') 'KORYH JUHHI!' >>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures') 'HELLO, WORLD!' >>> enigma('hello world!', (1, 1, 1), plugb='pictures') 'FPNCZ QWOBU!' >>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures') 'HELLO WORLD'   :param text: input message :param rotor_position: tuple with ``3`` values in range ``1``.. ``26`` :param rotor_selection: tuple with ``3`` rotors :param plugb: string containing plugboard configuration (default ``''``) :return: en/decrypted string","text.upper, _validator, .join, plugb.upper, result.append, abc.index, abc.index, abc.index, len, len, len, len, len, len, rotor3.index, rotor2.index, rotor1.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\fractionated_morse_cipher.py","","encode_to_morse","Encode a plaintext message into Morse code.  Args:     plaintext: The plaintext message to encode.  Returns:     The Morse code representation of the plaintext message.  Example:     >>> encode_to_morse(""defend the east"")     '-..x.x..-.x.x-.x-..xx-x....x.xx.x.-x...x-'",".join, MORSE_CODE_DICT.get, letter.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\fractionated_morse_cipher.py","","encrypt_fractionated_morse","Encrypt a plaintext message using Fractionated Morse Cipher.  Args:     plaintext: The plaintext message to encrypt.     key: The encryption key.  Returns:     The encrypted ciphertext.  Example:     >>> encrypt_fractionated_morse(""defend the east"",""Roundtable"")     'ESOAVVLJRSSTRX'","encode_to_morse, .join, .join, key.upper, sorted, set, len, zip, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\fractionated_morse_cipher.py","","decrypt_fractionated_morse","Decrypt a ciphertext message encrypted with Fractionated Morse Cipher.  Args:     ciphertext: The ciphertext message to decrypt.     key: The decryption key.  Returns:     The decrypted plaintext message.  Example:     >>> decrypt_fractionated_morse(""ESOAVVLJRSSTRX"",""Roundtable"")     'DEFEND THE EAST'",".join, dict, .join, .strip, key.upper, sorted, zip, set, inverse_fractionated_morse_dict.get, .join, morse_code.split"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\gronsfeld_cipher.py","","gronsfeld","Encrypt plaintext with the Gronsfeld cipher  >>> gronsfeld('hello', '412') 'LFNPP' >>> gronsfeld('hello', '123') 'IGOMQ' >>> gronsfeld('', '123') '' >>> gronsfeld('yes, $ - _!@#%?', '0') 'YES, $ - _!@#%?' >>> gronsfeld('yes, $ - _!@#%?', '01') 'YFS, $ - _!@#%?' >>> gronsfeld('yes, $ - _!@#%?', '012') 'YFU, $ - _!@#%?' >>> gronsfeld('yes, $ - _!@#%?', '') Traceback (most recent call last):   ... ZeroDivisionError: division by zero","len, len, text.upper, enumerate, int, ascii_uppercase.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","HillCipher","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","main","","int, print, range, HillCipher, print, input, input, hill_matrix.append, np.array, input, print, print, int, hc.encrypt, input, print, print, .split, hc.decrypt, input"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","__init__","encrypt_key is an NxN numpy array","self.modulus, self.check_determinant"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","replace_letters",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.replace_letters('T') 19 >>> hill_cipher.replace_letters('0') 26","self.key_string.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","replace_digits",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.replace_digits(19) 'T' >>> hill_cipher.replace_digits(26) '0' >>> hill_cipher.replace_digits(26.1) '0'","int"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","check_determinant",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.check_determinant()","round, len, np.linalg.det, greatest_common_divisor, ValueError, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","process_text",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.process_text('Testing Hill Cipher') 'TESTINGHILLCIPHERR' >>> hill_cipher.process_text('hello') 'HELLOO'",".join, chars.append, text.upper, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","encrypt",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.encrypt('testing hill cipher') 'WHXYJOLM9C6XT085LL' >>> hill_cipher.encrypt('hello') '85FF00'","self.process_text, range, text.upper, .join, self.replace_letters, np.array, .T.tolist, len, self.replace_digits, self.modulus, self.encrypt_key.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","make_decrypt_key",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.make_decrypt_key() array([[ 6, 25],        [ 5, 26]])","round, range, self.to_int, np.linalg.det, len, np.linalg.inv, self.modulus, len, np.linalg.det, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\hill_cipher.py","","decrypt",">>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]])) >>> hill_cipher.decrypt('WHXYJOLM9C6XT085LL') 'TESTINGHILLCIPHERR' >>> hill_cipher.decrypt('85FF00') 'HELLOO'","self.make_decrypt_key, self.process_text, range, text.upper, .join, self.replace_letters, np.array, .T.tolist, len, self.replace_digits, self.modulus, decrypt_key.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\mixed_keyword_cypher.py","","mixed_keyword","For keyword: hello  H E L O A B C D F G I J K M N P Q R S T U V W X Y Z and map vertically  >>> mixed_keyword(""college"", ""UNIVERSITY"", True)  # doctest: +NORMALIZE_WHITESPACE {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',  'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',  'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',  'Y': 'T', 'Z': 'Y'} 'XKJGUFMJST'  >>> mixed_keyword(""college"", ""UNIVERSITY"", False)  # doctest: +NORMALIZE_WHITESPACE 'XKJGUFMJST'","keyword.upper, plaintext.upper, set, len, range, .join, print, unique_chars.append, range, mapping.get, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\mono_alphabetic_ciphers.py","","translate_message",">>> translate_message(""QWERTYUIOPASDFGHJKLZXCVBNM"",""Hello World"",""encrypt"") 'Pcssi Bidsm'","symbol.upper, chars_a.find, symbol.isupper, symbol.upper, .upper, .lower"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\mono_alphabetic_ciphers.py","","encrypt_message",">>> encrypt_message(""QWERTYUIOPASDFGHJKLZXCVBNM"", ""Hello World"") 'Pcssi Bidsm'","translate_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\mono_alphabetic_ciphers.py","","decrypt_message",">>> decrypt_message(""QWERTYUIOPASDFGHJKLZXCVBNM"", ""Hello World"") 'Itssg Vgksr'","translate_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\mono_alphabetic_ciphers.py","","main","","print, encrypt_message, decrypt_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\morse_code.py","","encrypt",">>> encrypt(""Sos!"") '... --- ... -.-.--' >>> encrypt(""SOS!"") == encrypt(""sos!"") True",".join, message.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\morse_code.py","","decrypt",">>> decrypt('... --- ... -.-.--') 'SOS!'",".join, message.split"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\morse_code.py","","main",">>> s = """".join(MORSE_CODE_DICT) >>> decrypt(encrypt(s)) == s True","print, encrypt, print, decrypt, print"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\onepad_cipher.py","Onepad","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\onepad_cipher.py","","encrypt","Function to encrypt text using pseudo-random numbers >>> Onepad().encrypt("""") ([], []) >>> Onepad().encrypt([]) ([], []) >>> random.seed(1) >>> Onepad().encrypt("" "") ([6969], [69]) >>> random.seed(1) >>> Onepad().encrypt(""Hello"") ([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61]) >>> Onepad().encrypt(1) Traceback (most recent call last): ... TypeError: 'int' object is not iterable >>> Onepad().encrypt(1.1) Traceback (most recent call last): ... TypeError: 'float' object is not iterable","ord, random.randint, cipher.append, key.append"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\onepad_cipher.py","","decrypt","Function to decrypt text using pseudo-random numbers. >>> Onepad().decrypt([], []) '' >>> Onepad().decrypt([35], []) '' >>> Onepad().decrypt([], [35]) Traceback (most recent call last): ... IndexError: list index out of range >>> random.seed(1) >>> Onepad().decrypt([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61]) 'Hello'","range, .join, len, int, plain.append, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\permutation_cipher.py","","generate_valid_block_size","Generate a valid block size that is a factor of the message length.  Args:     message_length (int): The length of the message.  Returns:     int: A valid block size.  Example:     >>> random.seed(1)     >>> generate_valid_block_size(12)     3","random.choice, range"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\permutation_cipher.py","","generate_permutation_key","Generate a random permutation key of a specified block size.  Args:     block_size (int): The size of each permutation block.  Returns:     list[int]: A list containing a random permutation of digits.  Example:     >>> random.seed(0)     >>> generate_permutation_key(4)     [2, 0, 1, 3]","list, random.shuffle, range"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\permutation_cipher.py","","encrypt","Encrypt a message using a permutation cipher with block rearrangement using a key.  Args:     message (str): The plaintext message to be encrypted.     key (list[int]): The permutation key for decryption.     block_size (int): The size of each permutation block.  Returns:     tuple: A tuple containing the encrypted message and the encryption key.  Example:     >>> encrypted_message, key = encrypt(""HELLO WORLD"")     >>> decrypted_message = decrypt(encrypted_message, key)     >>> decrypted_message     'HELLO WORLD'","message.upper, len, range, generate_valid_block_size, generate_permutation_key, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\permutation_cipher.py","","decrypt","Decrypt an encrypted message using a permutation cipher with block rearrangement.  Args:     encrypted_message (str): The encrypted message.     key (list[int]): The permutation key for decryption.  Returns:     str: The decrypted plaintext message.  Example:     >>> encrypted_message, key = encrypt(""HELLO WORLD"")     >>> decrypted_message = decrypt(encrypted_message, key)     >>> decrypted_message     'HELLO WORLD'","len, range, len, enumerate, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\permutation_cipher.py","","main","Driver function to pass message to get encrypted, then decrypted.  Example: >>> main() Decrypted message: HELLO WORLD","encrypt, decrypt, print"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\playfair_cipher.py","","chunker","","iter, tuple, itertools.islice"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\playfair_cipher.py","","prepare_input","Prepare the plaintext by up-casing it and separating repeated letters with X's",".join, range, len, len, c.upper, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\playfair_cipher.py","","generate_table","","key.upper, table.append, table.append"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\playfair_cipher.py","","encode","Encode the given plaintext using the Playfair cipher. Takes the plaintext and the key as input and returns the encoded string.  >>> encode(""Hello"", ""MONARCHY"") 'CFSUPM' >>> encode(""attack on the left flank"", ""EMERGENCY"") 'DQZSBYFSDZFMFNLOHFDRSG' >>> encode(""Sorry!"", ""SPECIAL"") 'AVXETX' >>> encode(""Number 1"", ""NUMBER"") 'UMBENF' >>> encode(""Photosynthesis!"", ""THE SUN"") 'OEMHQHVCHESUKE'","generate_table, prepare_input, chunker, divmod, divmod, table.index, table.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\playfair_cipher.py","","decode","Decode the input string using the provided key.  >>> decode(""BMZFAZRZDH"", ""HAZARD"") 'FIREHAZARD' >>> decode(""HNBWBPQT"", ""AUTOMOBILE"") 'DRIVINGX' >>> decode(""SLYSSAQS"", ""CASTLE"") 'ATXTACKX'","generate_table, chunker, divmod, divmod, table.index, table.index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\polybius.py","PolybiusCipher","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\polybius.py","","__init__","","np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\polybius.py","","letter_to_numbers","Return the pair of numbers that represents the given letter in the polybius square >>> np.array_equal(PolybiusCipher().letter_to_numbers('a'), [1,1]) True  >>> np.array_equal(PolybiusCipher().letter_to_numbers('u'), [4,5]) True","np.where, np.concatenate"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\polybius.py","","numbers_to_letter","Return the letter corresponding to the position [index1, index2] in the polybius square  >>> PolybiusCipher().numbers_to_letter(4, 5) == ""u"" True  >>> PolybiusCipher().numbers_to_letter(1, 1) == ""a"" True",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\polybius.py","","encode","Return the encoded version of message according to the polybius cipher  >>> PolybiusCipher().encode(""test message"") == ""44154344 32154343112215"" True  >>> PolybiusCipher().encode(""Test Message"") == ""44154344 32154343112215"" True","message.lower, message.replace, range, len, self.letter_to_numbers, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\polybius.py","","decode","Return the decoded version of message according to the polybius cipher  >>> PolybiusCipher().decode(""44154344 32154343112215"") == ""test message"" True  >>> PolybiusCipher().decode(""4415434432154343112215"") == ""testmessage"" True","message.replace, range, int, self.numbers_to_letter, len, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\porta_cipher.py","","generate_table",">>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE [('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),  ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),  ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]","key.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\porta_cipher.py","","encrypt",">>> encrypt('marvin', 'jessica') 'QRACRWU'","generate_table, words.upper, get_opponent, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\porta_cipher.py","","decrypt",">>> decrypt('marvin', 'QRACRWU') 'JESSICA'","encrypt"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\porta_cipher.py","","get_position",">>> get_position(generate_table('marvin')[0], 'M') (0, 12)",".index"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\porta_cipher.py","","get_opponent",">>> get_opponent(generate_table('marvin')[0], 'M') 'T'","get_position, char.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rabin_miller.py","","rabin_miller","","range, random.randrange, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rabin_miller.py","","is_prime_low_num","","rabin_miller"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rabin_miller.py","","generate_large_prime","","random.randrange, is_prime_low_num"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rail_fence_cipher.py","","encrypt","Shuffles the character of a string by placing each of them in a grid (the height is dependent on the key) in a zigzag formation and reading it left to right.  >>> encrypt(""Hello World"", 4) 'HWe olordll'  >>> encrypt(""This is a message"", 0) Traceback (most recent call last):     ... ValueError: Height of grid can't be 0 or negative  >>> encrypt(b""This is a byte string"", 5) Traceback (most recent call last):     ... TypeError: sequence item 0: expected str instance, int found","enumerate, .join, ValueError, min, .append, .join, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rail_fence_cipher.py","","decrypt","Generates a template based on the key and fills it in with the characters of the input string and then reading it in a zigzag formation.  >>> decrypt(""HWe olordll"", 4) 'Hello World'  >>> decrypt(""This is a message"", -10) Traceback (most recent call last):     ... ValueError: Height of grid can't be 0 or negative  >>> decrypt(""My key is very big"", 100) 'My key is very big'","range, range, ValueError, len, min, .append, grid.append, len, len, min, .pop, range, list, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rail_fence_cipher.py","","bruteforce","Uses decrypt function by guessing every key  >>> bruteforce(""HWe olordll"")[4] 'Hello World'","range, len, decrypt"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rot13.py","","dencrypt","https://en.wikipedia.org/wiki/ROT13  >>> msg = ""My secret bank account number is 173-52946 so don't tell anyone!!"" >>> s = dencrypt(msg) >>> s ""Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!"" >>> dencrypt(s) == msg True","chr, chr, ord, ord, ord, ord, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rot13.py","","main","","input, dencrypt, print, dencrypt, print"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","get_blocks_from_text","","message.encode, range, len, range, block_ints.append, min, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","get_text_from_blocks","",".join, range, message.extend, block_message.insert, len, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","encrypt_message","","get_blocks_from_text, encrypted_blocks.append, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","decrypt_message","","get_text_from_blocks, decrypted_blocks.append, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","read_key_file","","content.split, open, fo.read, int, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","encrypt_and_write_to_file","","read_key_file, .join, sys.exit, str, open, fo.write, encrypt_message, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","read_from_file_and_decrypt","","read_key_file, content.split, int, int, encrypted_message.split, decrypt_message, open, fo.read, sys.exit, encrypted_blocks.append, int"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_cipher.py","","main","","input, .startswith, .startswith, input, print, encrypt_and_write_to_file, print, print, response.lower, os.path.exists, rkg.make_key_files, print, read_from_file_and_decrypt, print, print, print, response.lower, open, dec.write"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_factorization.py","","rsafactor","This function returns the factors of N, where p*q=N  Return: [p, q]  We call N the RSA modulus, e the encryption exponent, and d the decryption exponent. The pair (N, e) is the public key. As its name suggests, it is public and is used to encrypt messages. The pair (N, d) is the secret key or private key and is known only to the recipient of encrypted messages.  >>> rsafactor(3, 16971, 25777) [149, 173] >>> rsafactor(7331, 11, 27233) [113, 241] >>> rsafactor(4021, 13, 17711) [89, 199]","sorted, random.randint, math.gcd"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_key_generator.py","","main","","print, make_key_files, print"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_key_generator.py","","generate_key",">>> random.seed(0) # for repeatability >>> public_key, private_key = generate_key(8) >>> public_key (26569, 239) >>> private_key (26569, 2855)","rabin_miller.generate_large_prime, rabin_miller.generate_large_prime, cryptomath_module.find_mod_inverse, random.randrange, gcd_by_iterative"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\rsa_key_generator.py","","make_key_files","","generate_key, print, print, os.path.exists, os.path.exists, print, print, sys.exit, open, out_file.write, open, out_file.write"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\running_key_cipher.py","","running_key_encrypt","Encrypts the plaintext using the Running Key Cipher.  :param key: The running key (long piece of text). :param plaintext: The plaintext to be encrypted. :return: The ciphertext.",".upper, .upper, len, ord, enumerate, .join, ciphertext.append, plaintext.replace, key.replace, ord, ord, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\running_key_cipher.py","","running_key_decrypt","Decrypts the ciphertext using the Running Key Cipher.  :param key: The running key (long piece of text). :param ciphertext: The ciphertext to be decrypted. :return: The plaintext.",".upper, .upper, len, ord, enumerate, .join, plaintext.append, ciphertext.replace, key.replace, ord, ord, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\running_key_cipher.py","","test_running_key_encrypt",">>> key = ""How does the duck know that? said Victor"" >>> ciphertext = running_key_encrypt(key, ""DEFEND THIS"") >>> running_key_decrypt(key, ciphertext) == ""DEFENDTHIS"" True",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","ShuffledShiftCipher","","This algorithm uses the Caesar Cipher algorithm but removes the option to use brute force to decrypt the message.  The passcode is a random password from the selection buffer of 1. uppercase letters of the English alphabet 2. lowercase letters of the English alphabet 3. digits from 0 to 9  Using unique characters from the passcode, the normal list of characters, that can be allowed in the plaintext, is pivoted and shuffled. Refer to docstring of __make_key_list() to learn more about the shuffling.  Then, using the passcode, a number is calculated which is used to encrypt the plaintext message with the normal shift cipher method, only in this case, the reference, to look back at while decrypting, is shuffled.  Each cipher object can possess an optional argument as passcode, without which a new passcode is generated for that object automatically. cip1 = ShuffledShiftCipher('d4usr9TWxw9wMD') cip2 = ShuffledShiftCipher()",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","test_end_to_end",">>> test_end_to_end() 'Hello, this is a modified Caesar cipher'","ShuffledShiftCipher, cip1.decrypt, cip1.encrypt"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","__init__","Initializes a cipher object with a passcode as it's entity Note: No new passcode is generated if user provides a passcode while creating the object","self.__make_key_list, self.__make_shift_key, self.__passcode_creator"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","__str__",":return: passcode of the cipher object",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","__neg_pos","Mutates the list by changing the sign of each alternate element  :param iterlist: takes a list iterable :return: the mutated list","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","__passcode_creator","Creates a random password from the selection buffer of 1. uppercase letters of the English alphabet 2. lowercase letters of the English alphabet 3. digits from 0 to 9  :rtype: list :return: a password of a random length between 10 to 20","random.choice, range, random.randint"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","__make_key_list","Shuffles the ordered character choices by pivoting at breakpoints Breakpoints are the set of characters in the passcode  eg:     if, ABCDEFGHIJKLMNOPQRSTUVWXYZ are the possible characters     and CAMERA is the passcode     then, breakpoints = [A,C,E,M,R] # sorted set of characters from passcode     shuffled parts: [A,CB,ED,MLKJIHGF,RQPON,ZYXWVUTS]     shuffled __key_list : ACBEDMLKJIHGFRQPONZYXWVUTS  Shuffling only 26 letters of the english alphabet can generate 26! combinations for the shuffled list. In the program we consider, a set of 97 characters (including letters, digits, punctuation and whitespaces), thereby creating a possibility of 97! combinations (which is a 152 digit number in itself), thus diminishing the possibility of a brute force approach. Moreover, shift keys even introduce a multiple of 26 for a brute force approach for each of the already 97! combinations.","sorted, set, temp_list.extend, keys_l.extend, temp_list.clear"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","__make_shift_key","sum() of the mutated list of ascii values of all characters where the mutated list is the one returned by __neg_pos()","sum, self.__neg_pos, len, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","decrypt","Performs shifting of the encoded_message w.r.t. the shuffled __key_list to create the decoded_message  >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44') >>> ssc.decrypt(""d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#"") 'Hello, this is a modified Caesar cipher'","self.__key_list.index, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\shuffled_shift_cipher.py","","encrypt","Performs shifting of the plaintext w.r.t. the shuffled __key_list to create the encoded_message  >>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44') >>> ssc.encrypt('Hello, this is a modified Caesar cipher') ""d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#""","self.__key_list.index, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_keyword_cypher.py","","remove_duplicates","Removes duplicate alphabetic characters in a keyword (letter is ignored after its first appearance).  :param key: Keyword to use :return: String with duplicates removed  >>> remove_duplicates('Hello World!!') 'Helo Wrd'","ch.isalpha"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_keyword_cypher.py","","create_cipher_map","Returns a cipher map given a keyword.  :param key: keyword to use :return: dictionary cipher map","remove_duplicates, len, range, chr, key.upper, len, range, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_keyword_cypher.py","","encipher","Enciphers a message given a cipher map.  :param message: Message to encipher :param cipher_map: Cipher map :return: enciphered string  >>> encipher('Hello World!!', create_cipher_map('Goodbye!!')) 'CYJJM VMQJB!!'",".join, cipher_map.get, message.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_keyword_cypher.py","","decipher","Deciphers a message given a cipher map  :param message: Message to decipher :param cipher_map: Dictionary mapping to use :return: Deciphered string  >>> cipher_map = create_cipher_map('Goodbye!!') >>> decipher(encipher('Hello World!!', cipher_map), cipher_map) 'HELLO WORLD!!'",".join, cipher_map.items, rev_cipher_map.get, message.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_keyword_cypher.py","","main","Handles I/O  :return: void",".strip, .strip, .lower, create_cipher_map, print, func, input, input, KeyError, .strip, input"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_substitution_cipher.py","","main","","input, input, check_valid_key, .startswith, print, encrypt_message, .startswith, resp.lower, decrypt_message, resp.lower, mode.title"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_substitution_cipher.py","","check_valid_key","","list, list, key_list.sort, letters_list.sort, sys.exit"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_substitution_cipher.py","","encrypt_message",">>> encrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji') 'Ilcrism Olcvs'","translate_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_substitution_cipher.py","","decrypt_message",">>> decrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs') 'Harshil Darji'","translate_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_substitution_cipher.py","","translate_message","","symbol.upper, chars_a.find, symbol.isupper, symbol.upper, .upper, .lower"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\simple_substitution_cipher.py","","get_random_key","","list, random.shuffle, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\transposition_cipher.py","","main","","input, int, input, .startswith, print, input, encrypt_message, .startswith, mode.lower, decrypt_message, mode.lower, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\transposition_cipher.py","","encrypt_message",">>> encrypt_message(6, 'Harshil Darji') 'Hlia rDsahrij'","range, .join, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\transposition_cipher.py","","decrypt_message",">>> decrypt_message(6, 'Hlia rDsahrij') 'Harshil Darji'","math.ceil, .join, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\transposition_cipher_encrypt_decrypt_file.py","","main","","int, input, os.path.exists, time.time, .startswith, round, print, input, os.path.exists, print, sys.exit, print, input, trans_cipher.encrypt_message, .startswith, open, output_obj.write, .startswith, sys.exit, mode.lower, open, f.read, trans_cipher.decrypt_message, time.time, mode.lower, open, f.read, response.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\trifid_cipher.py","","__encrypt_part","Arrange the triagram value of each letter of `message_part` vertically and join them horizontally.  >>> __encrypt_part('ASK', TEST_CHARACTER_TO_NUMBER) '132111112'",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\trifid_cipher.py","","__decrypt_part","Convert each letter of the input string into their respective trigram values, join them and split them into three equal groups of strings which are returned.  >>> __decrypt_part('ABCDE', TEST_CHARACTER_TO_NUMBER) ('11111', '21131', '21122')",".join, len, len, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\trifid_cipher.py","","__prepare","A helper function that generates the triagrams and assigns each letter of the alphabet to its corresponding triagram and stores this in a dictionary (`character_to_number` and `number_to_character`) after confirming if the alphabet's length is ``27``.  >>> test = __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxYZ+') >>> expected = ('IAMABOY','ABCDEFGHIJKLMNOPQRSTUVWXYZ+', ... TEST_CHARACTER_TO_NUMBER, TEST_NUMBER_TO_CHARACTER) >>> test == expected True  Testing with incomplete alphabet  >>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVw') Traceback (most recent call last):     ... KeyError: 'Length of alphabet has to be 27.'  Testing with extra long alphabets  >>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxyzzwwtyyujjgfd') Traceback (most recent call last):     ... KeyError: 'Length of alphabet has to be 27.'  Testing with punctuation not in the given alphabet  >>> __prepare('am i a boy?','abCdeFghijkLmnopqrStuVwxYZ+') Traceback (most recent call last):     ... ValueError: Each message character has to be included in alphabet!  Testing with numbers  >>> __prepare(500,'abCdeFghijkLmnopqrStuVwxYZ+') Traceback (most recent call last):     ... AttributeError: 'int' object has no attribute 'replace'",".upper, .upper, any, dict, len, KeyError, ValueError, zip, alphabet.replace, message.replace, TEST_CHARACTER_TO_NUMBER.values, character_to_number.items"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\trifid_cipher.py","","encrypt_message","encrypt_message ===============  Encrypts a message using the trifid_cipher. Any punctuatuion chars that would be used should be added to the alphabet.  PARAMETERS ----------  *   `message`: The message you want to encrypt. *   `alphabet` (optional): The characters to be used for the cipher . *   `period` (optional): The number of characters you want in a group whilst     encrypting.  >>> encrypt_message('I am a boy') 'BCDGBQY'  >>> encrypt_message(' ') ''  >>> encrypt_message('   aide toi le c  iel      ta id  era    ', ... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5) 'FMJFVOISSUFTFPUFEQQC'","__prepare, range, range, __encrypt_part, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\trifid_cipher.py","","decrypt_message","decrypt_message ===============  Decrypts a trifid_cipher encrypted message.  PARAMETERS ----------  *   `message`: The message you want to decrypt. *   `alphabet` (optional): The characters used for the cipher. *   `period` (optional): The number of characters used in grouping when it     was encrypted.  >>> decrypt_message('BCDGBQY') 'IAMABOY'  Decrypting with your own alphabet and period  >>> decrypt_message('FMJFVOISSUFTFPUFEQQC','FELIXMARDSTBCGHJKNOPQUVWYZ+',5) 'AIDETOILECIELTAIDERA'","__prepare, range, .join, len, __decrypt_part, range, len, decrypted_numeric.append"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\vernam_cipher.py","","vernam_encrypt",">>> vernam_encrypt(""HELLO"",""KEY"") 'RIJVS'","range, len, chr, ord, ord, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\vernam_cipher.py","","vernam_decrypt",">>> vernam_decrypt(""RIJVS"",""KEY"") 'HELLO'","range, len, chr, ord, ord, len"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\vigenere_cipher.py","","main","","input, input, input, .startswith, print, print, encrypt_message, .startswith, mode.lower, decrypt_message, mode.lower, mode.title"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\vigenere_cipher.py","","encrypt_message",">>> encrypt_message('HDarji', 'This is Harshil Darji from Dharmaj.') 'Akij ra Odrjqqs Gaisq muod Mphumrs.'","translate_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\vigenere_cipher.py","","decrypt_message",">>> decrypt_message('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.') 'This is Harshil Darji from Dharmaj.'","translate_message"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\vigenere_cipher.py","","translate_message","","key.upper, .join, LETTERS.find, symbol.upper, len, symbol.isupper, translated.append, LETTERS.find, translated.append, symbol.islower, len, LETTERS.find, translated.append, .lower"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","XORCipher","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","__init__","simple constructor that receives a key or uses default key = 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","encrypt","input: 'content' of type string and 'key' of type int output: encrypted string 'content' as a list of chars if key not passed the method uses the key by the constructor. otherwise key = 1  Empty list >>> XORCipher().encrypt("""", 5) []  One key >>> XORCipher().encrypt(""hallo welt"", 1) ['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']  Normal key >>> XORCipher().encrypt(""HALLO WELT"", 32) ['h', 'a', 'l', 'l', 'o', '\x00', 'w', 'e', 'l', 't']  Key greater than 255 >>> XORCipher().encrypt(""hallo welt"", 256) ['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']","isinstance, isinstance, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","decrypt","input: 'content' of type list and 'key' of type int output: decrypted string 'content' as a list of chars if key not passed the method uses the key by the constructor. otherwise key = 1  Empty list >>> XORCipher().decrypt("""", 5) []  One key >>> XORCipher().decrypt(""hallo welt"", 1) ['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']  Normal key >>> XORCipher().decrypt(""HALLO WELT"", 32) ['h', 'a', 'l', 'l', 'o', '\x00', 'w', 'e', 'l', 't']  Key greater than 255 >>> XORCipher().decrypt(""hallo welt"", 256) ['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']","isinstance, isinstance, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","encrypt_string","input: 'content' of type string and 'key' of type int output: encrypted string 'content' if key not passed the method uses the key by the constructor. otherwise key = 1  Empty list >>> XORCipher().encrypt_string("""", 5) ''  One key >>> XORCipher().encrypt_string(""hallo welt"", 1) 'i`mmn!vdmu'  Normal key >>> XORCipher().encrypt_string(""HALLO WELT"", 32) 'hallo\x00welt'  Key greater than 255 >>> XORCipher().encrypt_string(""hallo welt"", 256) 'hallo welt'","isinstance, isinstance, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","decrypt_string","input: 'content' of type string and 'key' of type int output: decrypted string 'content' if key not passed the method uses the key by the constructor. otherwise key = 1  Empty list >>> XORCipher().decrypt_string("""", 5) ''  One key >>> XORCipher().decrypt_string(""hallo welt"", 1) 'i`mmn!vdmu'  Normal key >>> XORCipher().decrypt_string(""HALLO WELT"", 32) 'hallo\x00welt'  Key greater than 255 >>> XORCipher().decrypt_string(""hallo welt"", 256) 'hallo welt'","isinstance, isinstance, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","encrypt_file","input: filename (str) and a key (int) output: returns true if encrypt process was successful otherwise false if key not passed the method uses the key by the constructor. otherwise key = 1","isinstance, isinstance, open, open, fout.write, self.encrypt_string"
"C:/Users/Joseph Dania/Desktop/python_repo\ciphers\xor_cipher.py","","decrypt_file","input: filename (str) and a key (int) output: returns true if decrypt process was successful otherwise false if key not passed the method uses the key by the constructor. otherwise key = 1","isinstance, isinstance, open, open, fout.write, self.decrypt_string"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\flip_augmentation.py","","main","Get images list and annotations list from input dir. Update new images and annotations. Save images and annotations in output dir.","get_dataset, print, update_image_and_anno, enumerate, random_chars, cv2.imwrite, print, .rsplit, annos_list.append, open, outfile.write, .join, len, .split"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\flip_augmentation.py","","get_dataset","- label_dir <type: str>: Path to label include annotation of images - img_dir <type: str>: Path to folder contain images Return <type: list>: List of images path and labels","glob.glob, os.path.join, os.path.join, img_paths.append, labels.append, .rsplit, open, in_file.readlines, .split, boxes.append, obj_list.rstrip, int, float, float, float, float, label_file.split"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\flip_augmentation.py","","update_image_and_anno","- img_list <type: list>: list of all images - anno_list <type: list>: list of all annotations of specific image - flip_type <type: int>: 0 is vertical, 1 is horizontal Return:     - new_imgs_list <type: narray>: image after resize     - new_annos_lists <type: list>: list of new annotation after scale     - path_list <type: list>: list the name of image file","range, len, path_list.append, cv2.imread, new_annos_lists.append, new_imgs_list.append, cv2.flip, new_annos.append, cv2.flip, new_annos.append"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\flip_augmentation.py","","random_chars","Automatic generate random 32 characters. Get random string code: '7b7ad245cdff75241935e4dd860f3bad' >>> len(random_chars(32)) 32",".join, random.choice, range"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","root_mean_square_error","Simple implementation of Root Mean Squared Error for two N dimensional numpy arrays.  Examples:     >>> root_mean_square_error(np.array([1, 2, 3]), np.array([1, 2, 3]))     0.0     >>> root_mean_square_error(np.array([1, 2, 3]), np.array([2, 2, 2]))     0.816496580927726     >>> root_mean_square_error(np.array([1, 2, 3]), np.array([6, 4, 2]))     3.1622776601683795","float, np.sqrt, .mean"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","normalize_image","Normalizes image in Numpy 2D array format, between ranges 0-cap, as to fit uint8 type.  Args:     image: 2D numpy array representing image as matrix, with values in any range     cap: Maximum cap amount for normalization     data_type: numpy data type to set output variable to Returns:     return 2D numpy array of type uint8, corresponding to limited range matrix  Examples:     >>> normalize_image(np.array([[1, 2, 3], [4, 5, 10]]),     ...                 cap=1.0, data_type=np.float64)     array([[0.        , 0.11111111, 0.22222222],            [0.33333333, 0.44444444, 1.        ]])     >>> normalize_image(np.array([[4, 4, 3], [1, 7, 2]]))     array([[127, 127,  85],            [  0, 255,  42]], dtype=uint8)","normalized.astype, np.min, np.max, np.min"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","normalize_array","Normalizes a 1D array, between ranges 0-cap.  Args:     array: List containing values to be normalized between cap range.     cap: Maximum cap amount for normalization. Returns:     return 1D numpy array, corresponding to limited range array  Examples:     >>> normalize_array(np.array([2, 3, 5, 7]))     array([0. , 0.2, 0.6, 1. ])     >>> normalize_array(np.array([[5], [7], [11], [13]]))     array([[0.  ],            [0.25],            [0.75],            [1.  ]])","np.max, np.min, np.min"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","grayscale","Uses luminance weights to transform RGB channel to greyscale, by taking the dot product between the channel and the weights.  Example:     >>> grayscale(np.array([[[108, 201, 72], [255, 11,  127]],     ...                     [[56,  56,  56], [128, 255, 107]]]))     array([[158,  97],            [ 56, 200]], dtype=uint8)",".astype, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","binarize","Binarizes a grayscale image based on a given threshold value, setting values to 1 or 0 accordingly.  Examples:     >>> binarize(np.array([[128, 255], [101, 156]]))     array([[1, 1],            [0, 1]])     >>> binarize(np.array([[0.07, 1], [0.51, 0.3]]), threshold=0.5)     array([[0, 1],            [1, 0]])","np.where"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","transform","Simple image transformation using one of two available filter functions: Erosion and Dilation.  Args:     image: binarized input image, onto which to apply transformation     kind: Can be either 'erosion', in which case the :func:np.max           function is called, or 'dilation', when :func:np.min is used instead.     kernel: n x n kernel with shape < :attr:image.shape,           to be used when applying convolution to original image  Returns:     returns a numpy array with same shape as input image,     corresponding to applied binary transformation.  Examples:     >>> img = np.array([[1, 0.5], [0.2, 0.7]])     >>> img = binarize(img, threshold=0.5)     >>> transform(img, 'erosion')     array([[1, 1],            [1, 1]], dtype=uint8)     >>> transform(img, 'dilation')     array([[0, 0],            [0, 0]], dtype=uint8)","np.zeros, np.pad, range, np.ones, range, apply"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","opening_filter","Opening filter, defined as the sequence of erosion and then a dilation filter on the same image.  Examples:     >>> img = np.array([[1, 0.5], [0.2, 0.7]])     >>> img = binarize(img, threshold=0.5)     >>> opening_filter(img)     array([[1, 1],            [1, 1]], dtype=uint8)","transform, np.ones, transform"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","closing_filter","Opening filter, defined as the sequence of dilation and then erosion filter on the same image.  Examples:     >>> img = np.array([[1, 0.5], [0.2, 0.7]])     >>> img = binarize(img, threshold=0.5)     >>> closing_filter(img)     array([[0, 0],            [0, 0]], dtype=uint8)","transform, np.ones, transform"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","binary_mask","Apply binary mask, or thresholding based on bit mask value (mapping mask is binary).  Returns the mapped true value mask and its complementary false value mask.  Example:     >>> img = np.array([[[108, 201, 72], [255, 11,  127]],     ...                 [[56,  56,  56], [128, 255, 107]]])     >>> gray = grayscale(img)     >>> binary = binarize(gray)     >>> morphological = opening_filter(binary)     >>> binary_mask(gray, morphological)     (array([[1, 1],            [1, 1]], dtype=uint8), array([[158,  97],            [ 56, 200]], dtype=uint8))","image_gray.copy, image_gray.copy"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","matrix_concurrency","Calculate sample co-occurrence matrix based on input image as well as selected coordinates on image.  Implementation is made using basic iteration, as function to be performed (np.max) is non-linear and therefore not callable on the frequency domain.  Example:     >>> img = np.array([[[108, 201, 72], [255, 11,  127]],     ...                 [[56,  56,  56], [128, 255, 107]]])     >>> gray = grayscale(img)     >>> binary = binarize(gray)     >>> morphological = opening_filter(binary)     >>> mask_1 = binary_mask(gray, morphological)[0]     >>> matrix_concurrency(mask_1, (0, 1))     array([[0., 0.],            [0., 0.]])","np.zeros, range, np.sum, range, np.max, np.max"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","haralick_descriptors","Calculates all 8 Haralick descriptors based on co-occurrence input matrix. All descriptors are as follows: Maximum probability, Inverse Difference, Homogeneity, Entropy, Energy, Dissimilarity, Contrast and Correlation  Args:     matrix: Co-occurrence matrix to use as base for calculating descriptors.  Returns:     Reverse ordered list of resulting descriptors  Example:     >>> img = np.array([[[108, 201, 72], [255, 11,  127]],     ...                 [[56,  56,  56], [128, 255, 107]]])     >>> gray = grayscale(img)     >>> binary = binarize(gray)     >>> morphological = opening_filter(binary)     >>> mask_1 = binary_mask(gray, morphological)[0]     >>> concurrency = matrix_concurrency(mask_1, (0, 1))     >>> [float(f) for f in haralick_descriptors(concurrency)]     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]","np.multiply, np.subtract, np.max, np.power, np.power, np.abs, correlation.sum, energy.sum, contrast.sum, dissimilarity.sum, inverse_difference.sum, homogeneity.sum, entropy.sum, np.abs, np.power, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","get_descriptors","Calculate all Haralick descriptors for a sequence of different co-occurrence matrices, given input masks and coordinates.  Example:     >>> img = np.array([[[108, 201, 72], [255, 11,  127]],     ...                 [[56,  56,  56], [128, 255, 107]]])     >>> gray = grayscale(img)     >>> binary = binarize(gray)     >>> morphological = opening_filter(binary)     >>> get_descriptors(binary_mask(gray, morphological), (0, 1))     array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","np.array, np.concatenate, haralick_descriptors, matrix_concurrency"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","euclidean","Simple method for calculating the euclidean distance between two points, with type np.ndarray.  Example:     >>> a = np.array([1, 0, -2])     >>> b = np.array([2, -1, 1])     >>> euclidean(a, b)     3.3166247903554","float, np.sqrt, np.sum, np.square"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\haralick_descriptors.py","","get_distances","Calculate all Euclidean distances between a selected base descriptor and all other Haralick descriptors The resulting comparison is return in decreasing order, showing which descriptor is the most similar to the selected base.  Args:     descriptors: Haralick descriptors to compare with base index     base: Haralick descriptor index to use as base when calculating respective     euclidean distance to other descriptors.  Returns:     Ordered distances between descriptors  Example:     >>> index = 1     >>> img = np.array([[[108, 201, 72], [255, 11,  127]],     ...                 [[56,  56,  56], [128, 255, 107]]])     >>> gray = grayscale(img)     >>> binary = binarize(gray)     >>> morphological = opening_filter(binary)     >>> get_distances(get_descriptors(     ...                 binary_mask(gray, morphological), (0, 1)),     ...               index)     [(0, 0.0), (1, 0.0), (2, 0.0), (3, 0.0), (4, 0.0), (5, 0.0), (6, 0.0), (7, 0.0), (8, 0.0), (9, 0.0), (10, 0.0), (11, 0.0), (12, 0.0), (13, 0.0), (14, 0.0), (15, 0.0)]","np.array, .tolist, list, enum_distances.sort, enumerate, euclidean, normalize_array"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\harris_corner.py","HarrisCorner","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\harris_corner.py","","__init__","k : is an empirically determined constant in [0.04,0.06] window_size : neighbourhoods considered","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\harris_corner.py","","__str__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\harris_corner.py","","detect","Returns the image with corners identified img_path  : path of the image output : list of the corner positions, image","cv2.imread, img.copy, cv2.cvtColor, np.gradient, range, range, .sum, .sum, .sum, corner_list.append, color_img.itemset, color_img.itemset, color_img.itemset"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\horn_schunck.py","","warp","Warps the pixels of an image into a new image using the horizontal and vertical flows. Pixels that are warped from an invalid location are set to 0.  Parameters:     image: Grayscale image     horizontal_flow: Horizontal flow     vertical_flow: Vertical flow  Returns: Warped image  >>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]),     np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]),     np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]])) array([[0, 0, 0],        [3, 1, 0],        [0, 2, 3]])","np.stack, np.stack, .astype, np.meshgrid, np.arange, np.arange, np.round, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\horn_schunck.py","","horn_schunck","This function performs the Horn-Schunck algorithm and returns the estimated optical flow. It is assumed that the input images are grayscale and normalized to be in [0, 1].  Parameters:     image0: First image of the sequence     image1: Second image of the sequence     alpha: Regularization constant     num_iter: Number of iterations performed  Returns: estimated horizontal & vertical flow  >>> np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]),     np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).    astype(np.int32) array([[[ 0, -1, -1],         [ 0, -1, -1]], <BLANKLINE>        [[ 0,  0,  0],         [ 0,  0,  0]]], dtype=int32)","np.zeros_like, np.zeros_like, np.array, range, np.array, np.array, np.array, warp, convolve, convolve, convolve, convolve, convolve, convolve, convolve, convolve"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\intensity_based_segmentation.py","","segment_image","Performs image segmentation based on intensity thresholds.  Args:     image: Input grayscale image as a 2D array.     thresholds: Intensity thresholds to define segments.  Returns:     A labeled 2D array where each region corresponds to a threshold range.  Example:     >>> img = np.array([[80, 120, 180], [40, 90, 150], [20, 60, 100]])     >>> segment_image(img, [50, 100, 150])     array([[1, 2, 3],            [0, 1, 2],            [0, 1, 1]], dtype=int32)","np.zeros_like, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\mean_threshold.py","","mean_threshold","image: is a grayscale PIL image object","image.load, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\mosaic_augmentation.py","","main","Get images list and annotations list from input dir. Update new images and annotations. Save images and annotations in output dir.","get_dataset, range, random.sample, update_image_and_anno, random_chars, cv2.imwrite, print, range, .rsplit, annos_list.append, open, outfile.write, len, .join, path.split"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\mosaic_augmentation.py","","get_dataset","- label_dir <type: str>: Path to label include annotation of images - img_dir <type: str>: Path to folder contain images Return <type: list>: List of images path and labels","glob.glob, os.path.join, os.path.join, img_paths.append, labels.append, .rsplit, open, in_file.readlines, .split, boxes.append, float, float, float, float, obj_list.rstrip, float, float, float, float, int, label_file.split"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\mosaic_augmentation.py","","update_image_and_anno","- all_img_list <type: list>: list of all images - all_annos <type: list>: list of all annotations of specific image - idxs <type: list>: index of image in list - output_size <type: tuple>: size of output image (Height, Width) - scale_range <type: tuple>: range of scale image - filter_scale <type: float>: the condition of downscale image and bounding box Return:     - output_img <type: narray>: image after resize     - new_anno <type: list>: list of new annotation after scale     - path[0] <type: string>: get the name of image file","np.zeros, int, int, enumerate, path_list.append, cv2.imread, random.random, random.random, cv2.resize, new_anno.append, cv2.resize, new_anno.append, cv2.resize, cv2.resize, new_anno.append, new_anno.append"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\mosaic_augmentation.py","","random_chars","Automatic generate random 32 characters. Get random string code: '7b7ad245cdff75241935e4dd860f3bad' >>> len(random_chars(32)) 32",".join, random.choice, range"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\pooling_functions.py","","maxpooling","This function is used to perform maxpooling on the input array of 2D matrix(image) Args:     arr: numpy array     size: size of pooling matrix     stride: the number of pixels shifts over the input matrix Returns:     numpy array of maxpooled matrix Sample Input Output: >>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2) array([[ 6.,  8.],        [14., 16.]]) >>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1) array([[241., 180.],        [241., 157.]])","np.array, np.zeros, ValueError, np.max"
"C:/Users/Joseph Dania/Desktop/python_repo\computer_vision\pooling_functions.py","","avgpooling","This function is used to perform avgpooling on the input array of 2D matrix(image) Args:     arr: numpy array     size: size of pooling matrix     stride: the number of pixels shifts over the input matrix Returns:     numpy array of avgpooled matrix Sample Input Output: >>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2) array([[ 3.,  5.],        [11., 13.]]) >>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1) array([[161., 102.],        [114.,  69.]])","np.array, np.zeros, ValueError, int, np.average"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\astronomical_length_scale_conversion.py","","length_conversion","Conversion between astronomical length units.  >>> length_conversion(1, ""meter"", ""kilometer"") 0.001 >>> length_conversion(1, ""meter"", ""megametre"") 1e-06 >>> length_conversion(1, ""gigametre"", ""meter"") 1000000000 >>> length_conversion(1, ""gigametre"", ""terametre"") 0.001 >>> length_conversion(1, ""petametre"", ""terametre"") 1000 >>> length_conversion(1, ""petametre"", ""exametre"") 0.001 >>> length_conversion(1, ""terametre"", ""zettametre"") 1e-09 >>> length_conversion(1, ""yottametre"", ""zettametre"") 1000 >>> length_conversion(4, ""wrongUnit"", ""inch"") Traceback (most recent call last):   ... ValueError: Invalid 'from_type' value: 'wrongUnit'. Conversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym",".strip, .strip, UNIT_SYMBOL.get, UNIT_SYMBOL.get, ValueError, ValueError, pow, from_type.lower, to_type.lower, .join, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\binary_to_decimal.py","","bin_to_decimal","Convert a binary value to its decimal equivalent  >>> bin_to_decimal(""101"") 5 >>> bin_to_decimal("" 1010   "") 10 >>> bin_to_decimal(""-11101"") -29 >>> bin_to_decimal(""0"") 0 >>> bin_to_decimal(""a"") Traceback (most recent call last):     ... ValueError: Non-binary value was passed to the function >>> bin_to_decimal("""") Traceback (most recent call last):     ... ValueError: Empty string was passed to the function >>> bin_to_decimal(""39"") Traceback (most recent call last):     ... ValueError: Non-binary value was passed to the function",".strip, ValueError, all, ValueError, str, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\binary_to_hexadecimal.py","","bin_to_hexadecimal","Converting a binary string into hexadecimal using Grouping Method  >>> bin_to_hexadecimal('101011111') '0x15f' >>> bin_to_hexadecimal(' 1010   ') '0x0a' >>> bin_to_hexadecimal('-11101') '-0x1d' >>> bin_to_hexadecimal('a') Traceback (most recent call last):     ... ValueError: Non-binary value was passed to the function >>> bin_to_hexadecimal('') Traceback (most recent call last):     ... ValueError: Empty string was passed to the function",".strip, range, ValueError, all, ValueError, len, hexadecimal.append, .join, str, len, divmod, len"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\binary_to_octal.py","","bin_to_octal","","all, ValueError, ValueError, enumerate, str, len, range, int, len, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\convert_number_to_words.py","NumberingSystem","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\convert_number_to_words.py","NumberWords","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\convert_number_to_words.py","","convert_small_number","Converts small, non-negative integers with irregular constructions in English (i.e., numbers under 100) into words.  >>> convert_small_number(0) 'zero' >>> convert_small_number(5) 'five' >>> convert_small_number(10) 'ten' >>> convert_small_number(15) 'fifteen' >>> convert_small_number(20) 'twenty' >>> convert_small_number(25) 'twenty-five' >>> convert_small_number(-1) Traceback (most recent call last): ... ValueError: This function only accepts non-negative integers >>> convert_small_number(123) Traceback (most recent call last): ... ValueError: This function only converts numbers less than 100","divmod, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\convert_number_to_words.py","","convert_number","Converts an integer to English words.  :param num: The integer to be converted :param system: The numbering system (short, long, or Indian)  >>> convert_number(0) 'zero' >>> convert_number(1) 'one' >>> convert_number(100) 'one hundred' >>> convert_number(-100) 'negative one hundred' >>> convert_number(123_456_789_012_345) # doctest: +NORMALIZE_WHITESPACE 'one hundred twenty-three trillion four hundred fifty-six billion seven hundred eighty-nine million twelve thousand three hundred forty-five' >>> convert_number(123_456_789_012_345, ""long"") # doctest: +NORMALIZE_WHITESPACE 'one hundred twenty-three thousand four hundred fifty-six milliard seven hundred eighty-nine million twelve thousand three hundred forty-five' >>> convert_number(12_34_56_78_90_12_345, ""indian"") # doctest: +NORMALIZE_WHITESPACE 'one crore crore twenty-three lakh crore forty-five thousand six hundred seventy-eight crore ninety lakh twelve thousand three hundred forty-five' >>> convert_number(10**18) Traceback (most recent call last): ... ValueError: Input number is too large >>> convert_number(10**21, ""long"") Traceback (most recent call last): ... ValueError: Input number is too large >>> convert_number(10**19, ""indian"") Traceback (most recent call last): ... ValueError: Input number is too large",".join, word_groups.append, NumberingSystem.max_value, ValueError, divmod, word_groups.append, system.upper, word_groups.append, convert_small_number, convert_number, convert_small_number"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\convert_number_to_words.py","","max_value","Gets the max value supported by the given number system.  >>> NumberingSystem.max_value(""short"") == 10**18 - 1 True >>> NumberingSystem.max_value(""long"") == 10**21 - 1 True >>> NumberingSystem.max_value(""indian"") == 10**19 - 1 True","system.upper, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_any.py","","decimal_to_any","Convert a positive integer to another base as str. >>> decimal_to_any(0, 2) '0' >>> decimal_to_any(5, 4) '11' >>> decimal_to_any(20, 3) '202' >>> decimal_to_any(58, 16) '3A' >>> decimal_to_any(243, 17) 'E5' >>> decimal_to_any(34923, 36) 'QY3' >>> decimal_to_any(10, 11) 'A' >>> decimal_to_any(16, 16) '10' >>> decimal_to_any(36, 36) '10' >>> # negatives will error >>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... ValueError: parameter must be positive int >>> # floats will error >>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: int() can't convert non-string with explicit base >>> # a float base will error >>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer >>> # a str base will error >>> decimal_to_any(10, '16') # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: 'str' object cannot be interpreted as an integer >>> # a base less than 2 will error >>> decimal_to_any(7, 0) # doctest: +ELLIPSIS Traceback (most recent call last):     ... ValueError: base must be >= 2 >>> # a base greater than 36 will error >>> decimal_to_any(34, 37) # doctest: +ELLIPSIS Traceback (most recent call last):     ... ValueError: base must be <= 36","isinstance, isinstance, isinstance, TypeError, ValueError, TypeError, TypeError, ValueError, ValueError, divmod, str, str, str, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_binary.py","","decimal_to_binary_iterative","Convert an Integer Decimal Number to a Binary Number as str. >>> decimal_to_binary_iterative(0) '0b0' >>> decimal_to_binary_iterative(2) '0b10' >>> decimal_to_binary_iterative(7) '0b111' >>> decimal_to_binary_iterative(35) '0b100011' >>> # negatives work too >>> decimal_to_binary_iterative(-2) '-0b10' >>> # other floats will error >>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer >>> # strings will error as well >>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: 'str' object cannot be interpreted as an integer","isinstance, isinstance, TypeError, TypeError, binary.insert, .join, .join, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_binary.py","","decimal_to_binary_recursive_helper","Take a positive integer value and return its binary equivalent. >>> decimal_to_binary_recursive_helper(1000) '1111101000' >>> decimal_to_binary_recursive_helper(""72"") '1001000' >>> decimal_to_binary_recursive_helper(""number"") Traceback (most recent call last):     ... ValueError: invalid literal for int() with base 10: 'number'","int, divmod, str, decimal_to_binary_recursive_helper, str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_binary.py","","decimal_to_binary_recursive","Take an integer value and raise ValueError for wrong inputs, call the function above and return the output with prefix ""0b"" & ""-0b"" for positive and negative integers respectively. >>> decimal_to_binary_recursive(0) '0b0' >>> decimal_to_binary_recursive(40) '0b101000' >>> decimal_to_binary_recursive(-40) '-0b101000' >>> decimal_to_binary_recursive(40.8) Traceback (most recent call last):     ... ValueError: Input value is not an integer >>> decimal_to_binary_recursive(""forty"") Traceback (most recent call last):     ... ValueError: Input value is not an integer",".strip, number.lstrip, ValueError, number.startswith, number.isnumeric, ValueError, str, decimal_to_binary_recursive_helper, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_hexadecimal.py","","decimal_to_hexadecimal","take integer decimal value, return hexadecimal representation as str beginning with 0x >>> decimal_to_hexadecimal(5) '0x5' >>> decimal_to_hexadecimal(15) '0xf' >>> decimal_to_hexadecimal(37) '0x25' >>> decimal_to_hexadecimal(255) '0xff' >>> decimal_to_hexadecimal(4096) '0x1000' >>> decimal_to_hexadecimal(999098) '0xf3eba' >>> # negatives work too >>> decimal_to_hexadecimal(-256) '-0x100' >>> # floats are acceptable if equivalent to an int >>> decimal_to_hexadecimal(17.0) '0x11' >>> # other floats will error >>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS Traceback (most recent call last):     ... AssertionError >>> # strings will error as well >>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS Traceback (most recent call last):     ... AssertionError >>> # results are the same when compared to Python's default hex function >>> decimal_to_hexadecimal(-256) == hex(-256) True","isinstance, int, int, divmod"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_octal.py","","decimal_to_octal","Convert a Decimal Number to an Octal Number.  >>> all(decimal_to_octal(i) == oct(i) for i ...     in (0, 2, 8, 64, 65, 216, 255, 256, 512)) True","math.floor, int, math.floor, math.pow"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\decimal_to_octal.py","","main","Print octal equivalents of decimal numbers.","print, print, print, print, print, print, print, print, print, print, print, decimal_to_octal, decimal_to_octal, decimal_to_octal, decimal_to_octal, decimal_to_octal"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\energy_conversions.py","","energy_conversion","Conversion of energy units. >>> energy_conversion(""joule"", ""joule"", 1) 1.0 >>> energy_conversion(""joule"", ""kilojoule"", 1) 0.001 >>> energy_conversion(""joule"", ""megajoule"", 1) 1e-06 >>> energy_conversion(""joule"", ""gigajoule"", 1) 1e-09 >>> energy_conversion(""joule"", ""wattsecond"", 1) 1.0 >>> energy_conversion(""joule"", ""watthour"", 1) 0.0002777777777777778 >>> energy_conversion(""joule"", ""kilowatthour"", 1) 2.7777777777777776e-07 >>> energy_conversion(""joule"", ""newtonmeter"", 1) 1.0 >>> energy_conversion(""joule"", ""calorie_nutr"", 1) 0.00023884589662749592 >>> energy_conversion(""joule"", ""kilocalorie_nutr"", 1) 2.388458966274959e-07 >>> energy_conversion(""joule"", ""electronvolt"", 1) 6.241509074460763e+18 >>> energy_conversion(""joule"", ""britishthermalunit_it"", 1) 0.0009478171226670134 >>> energy_conversion(""joule"", ""footpound"", 1) 0.7375621211696556 >>> energy_conversion(""joule"", ""megajoule"", 1000) 0.001 >>> energy_conversion(""calorie_nutr"", ""kilocalorie_nutr"", 1000) 1.0 >>> energy_conversion(""kilowatthour"", ""joule"", 10) 36000000.0 >>> energy_conversion(""britishthermalunit_it"", ""footpound"", 1) 778.1692306784539 >>> energy_conversion(""watthour"", ""joule"", ""a"") # doctest: +ELLIPSIS Traceback (most recent call last):   ... TypeError: unsupported operand type(s) for /: 'str' and 'float' >>> energy_conversion(""wrongunit"", ""joule"", 1) # doctest: +ELLIPSIS Traceback (most recent call last):   ... ValueError: Incorrect 'from_type' or 'to_type' value: 'wrongunit', 'joule' Valid values are: joule, ... footpound >>> energy_conversion(""joule"", ""wrongunit"", 1) # doctest: +ELLIPSIS Traceback (most recent call last):   ... ValueError: Incorrect 'from_type' or 'to_type' value: 'joule', 'wrongunit' Valid values are: joule, ... footpound >>> energy_conversion(""123"", ""abc"", 1) # doctest: +ELLIPSIS Traceback (most recent call last):   ... ValueError: Incorrect 'from_type' or 'to_type' value: '123', 'abc' Valid values are: joule, ... footpound","ValueError, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\excel_title_to_column.py","","excel_title_to_column","Given a string column_title that represents the column title in an Excel sheet, return its corresponding column number.  >>> excel_title_to_column(""A"") 1 >>> excel_title_to_column(""B"") 2 >>> excel_title_to_column(""AB"") 28 >>> excel_title_to_column(""Z"") 26","column_title.isupper, len, pow, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\hexadecimal_to_decimal.py","","hex_to_decimal","Convert a hexadecimal value to its decimal equivalent #https://www.programiz.com/python-programming/methods/built-in/hex  >>> hex_to_decimal(""a"") 10 >>> hex_to_decimal(""12f"") 303 >>> hex_to_decimal(""   12f   "") 303 >>> hex_to_decimal(""FfFf"") 65535 >>> hex_to_decimal(""-Ff"") -255 >>> hex_to_decimal(""F-f"") Traceback (most recent call last):     ... ValueError: Non-hexadecimal value was passed to the function >>> hex_to_decimal("""") Traceback (most recent call last):     ... ValueError: Empty string was passed to the function >>> hex_to_decimal(""12m"") Traceback (most recent call last):     ... ValueError: Non-hexadecimal value was passed to the function",".lower, ValueError, all, ValueError, hex_string.strip"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\hex_to_bin.py","","hex_to_bin","Convert a hexadecimal value to its binary equivalent #https://stackoverflow.com/questions/1425493/convert-hex-to-binary Here, we have used the bitwise right shift operator: >> Shifts the bits of the number to the right and fills 0 on voids left as a result. Similar effect as of dividing the number with some power of two. Example: a = 10 a >> 1 = 5  >>> hex_to_bin(""AC"") 10101100 >>> hex_to_bin(""9A4"") 100110100100 >>> hex_to_bin(""   12f   "") 100101111 >>> hex_to_bin(""FfFf"") 1111111111111111 >>> hex_to_bin(""-fFfF"") -1111111111111111 >>> hex_to_bin(""F-f"") Traceback (most recent call last):     ... ValueError: Invalid value was passed to the function >>> hex_to_bin("""") Traceback (most recent call last):     ... ValueError: No value was passed to the function","hex_num.strip, int, ValueError, int, ValueError, str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\ipv4_conversion.py","","ipv4_to_decimal","Convert an IPv4 address to its decimal representation.  Args:     ip_address: A string representing an IPv4 address (e.g., ""192.168.0.1"").  Returns:     int: The decimal representation of the IP address.  >>> ipv4_to_decimal(""192.168.0.1"") 3232235521 >>> ipv4_to_decimal(""10.0.0.255"") 167772415 >>> ipv4_to_decimal(""10.0.255"") Traceback (most recent call last):     ... ValueError: Invalid IPv4 address format >>> ipv4_to_decimal(""10.0.0.256"") Traceback (most recent call last):     ... ValueError: Invalid IPv4 octet 256","int, len, ValueError, ipv4_address.split, ValueError, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\ipv4_conversion.py","","alt_ipv4_to_decimal",">>> alt_ipv4_to_decimal(""192.168.0.1"") 3232235521 >>> alt_ipv4_to_decimal(""10.0.0.255"") 167772415","int, .join, ipv4_address.split, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\ipv4_conversion.py","","decimal_to_ipv4","Convert a decimal representation of an IP address to its IPv4 format.  Args:     decimal_ipv4: An integer representing the decimal IP address.  Returns:     The IPv4 representation of the decimal IP address.  >>> decimal_to_ipv4(3232235521) '192.168.0.1' >>> decimal_to_ipv4(167772415) '10.0.0.255' >>> decimal_to_ipv4(-1) Traceback (most recent call last):     ... ValueError: Invalid decimal IPv4 address","range, .join, ValueError, ip_parts.append, reversed, str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\length_conversion.py","FromTo","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\length_conversion.py","","length_conversion","Conversion between length units.  >>> length_conversion(4, ""METER"", ""FEET"") 13.12336 >>> length_conversion(4, ""M"", ""FT"") 13.12336 >>> length_conversion(1, ""meter"", ""kilometer"") 0.001 >>> length_conversion(1, ""kilometer"", ""inch"") 39370.1 >>> length_conversion(3, ""kilometer"", ""mile"") 1.8641130000000001 >>> length_conversion(2, ""feet"", ""meter"") 0.6096 >>> length_conversion(4, ""feet"", ""yard"") 1.333329312 >>> length_conversion(1, ""inch"", ""meter"") 0.0254 >>> length_conversion(2, ""inch"", ""mile"") 3.15656468e-05 >>> length_conversion(2, ""centimeter"", ""millimeter"") 20.0 >>> length_conversion(2, ""centimeter"", ""yard"") 0.0218722 >>> length_conversion(4, ""yard"", ""meter"") 3.6576 >>> length_conversion(4, ""yard"", ""kilometer"") 0.0036576 >>> length_conversion(3, ""foot"", ""meter"") 0.9144000000000001 >>> length_conversion(3, ""foot"", ""inch"") 36.00001944 >>> length_conversion(4, ""mile"", ""kilometer"") 6.43736 >>> length_conversion(2, ""miles"", ""InChEs"") 126719.753468 >>> length_conversion(3, ""millimeter"", ""centimeter"") 0.3 >>> length_conversion(3, ""mm"", ""in"") 0.1181103 >>> length_conversion(4, ""wrongUnit"", ""inch"") Traceback (most recent call last):   ... ValueError: Invalid 'from_type' value: 'wrongUnit'. Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi",".rstrip, TYPE_CONVERSION.get, .rstrip, TYPE_CONVERSION.get, ValueError, ValueError, from_type.lower, to_type.lower, .join, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\molecular_chemistry.py","","molarity_to_normality","Convert molarity to normality.   Volume is taken in litres.    Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration   Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration    >>> molarity_to_normality(2, 3.1, 0.31)   20   >>> molarity_to_normality(4, 11.4, 5.7)   8","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\molecular_chemistry.py","","moles_to_pressure","Convert moles to pressure.   Ideal gas laws are used.   Temperature is taken in kelvin.   Volume is taken in litres.   Pressure has atm as SI unit.    Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws   Wikipedia reference: https://en.wikipedia.org/wiki/Pressure   Wikipedia reference: https://en.wikipedia.org/wiki/Temperature    >>> moles_to_pressure(0.82, 3, 300)   90   >>> moles_to_pressure(8.2, 5, 200)   10","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\molecular_chemistry.py","","moles_to_volume","Convert moles to volume.   Ideal gas laws are used.   Temperature is taken in kelvin.   Volume is taken in litres.   Pressure has atm as SI unit.    Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws   Wikipedia reference: https://en.wikipedia.org/wiki/Pressure   Wikipedia reference: https://en.wikipedia.org/wiki/Temperature    >>> moles_to_volume(0.82, 3, 300)   90   >>> moles_to_volume(8.2, 5, 200)   10","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\molecular_chemistry.py","","pressure_and_volume_to_temperature","Convert pressure and volume to temperature.   Ideal gas laws are used.   Temperature is taken in kelvin.   Volume is taken in litres.   Pressure has atm as SI unit.    Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws   Wikipedia reference: https://en.wikipedia.org/wiki/Pressure   Wikipedia reference: https://en.wikipedia.org/wiki/Temperature    >>> pressure_and_volume_to_temperature(0.82, 1, 2)   20   >>> pressure_and_volume_to_temperature(8.2, 5, 3)   60","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\octal_to_binary.py","","octal_to_binary","Convert an Octal number to Binary.  >>> octal_to_binary(""17"") '001111' >>> octal_to_binary(""7"") '111' >>> octal_to_binary(""Av"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> octal_to_binary(""@#"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> octal_to_binary("""") Traceback (most recent call last):     ... ValueError: Empty string was passed to the function","ValueError, int, range, ValueError, str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\octal_to_decimal.py","","oct_to_decimal","Convert a octal value to its decimal equivalent  >>> oct_to_decimal("""") Traceback (most recent call last):     ... ValueError: Empty string was passed to the function >>> oct_to_decimal(""-"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal(""e"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal(""8"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal(""-e"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal(""-8"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal(""1"") 1 >>> oct_to_decimal(""-1"") -1 >>> oct_to_decimal(""12"") 10 >>> oct_to_decimal("" 12   "") 10 >>> oct_to_decimal(""-45"") -37 >>> oct_to_decimal(""-"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal(""0"") 0 >>> oct_to_decimal(""-4055"") -2093 >>> oct_to_decimal(""2-0Fm"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function >>> oct_to_decimal("""") Traceback (most recent call last):     ... ValueError: Empty string was passed to the function >>> oct_to_decimal(""19"") Traceback (most recent call last):     ... ValueError: Non-octal value was passed to the function",".strip, ValueError, ValueError, str, oct_string.isdigit, all, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\octal_to_hexadecimal.py","","octal_to_hex","Convert an Octal number to Hexadecimal number. For more information: https://en.wikipedia.org/wiki/Octal  >>> octal_to_hex(""100"") '0x40' >>> octal_to_hex(""235"") '0x9D' >>> octal_to_hex(17) Traceback (most recent call last):     ... TypeError: Expected a string as input >>> octal_to_hex(""Av"") Traceback (most recent call last):     ... ValueError: Not a Valid Octal Number >>> octal_to_hex("""") Traceback (most recent call last):     ... ValueError: Empty string was passed to the function","octal.startswith, any, isinstance, TypeError, ValueError, ValueError, int"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions.py","SIUnit","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions.py","BinaryUnit","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions.py","","convert_si_prefix","Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units >>> convert_si_prefix(1, SIUnit.giga, SIUnit.mega) 1000 >>> convert_si_prefix(1, SIUnit.mega, SIUnit.giga) 0.001 >>> convert_si_prefix(1, SIUnit.kilo, SIUnit.kilo) 1 >>> convert_si_prefix(1, 'giga', 'mega') 1000 >>> convert_si_prefix(1, 'gIGa', 'mEGa') 1000","isinstance, isinstance, known_prefix.lower, unknown_prefix.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions.py","","convert_binary_prefix","Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix >>> convert_binary_prefix(1, BinaryUnit.giga, BinaryUnit.mega) 1024 >>> convert_binary_prefix(1, BinaryUnit.mega, BinaryUnit.giga) 0.0009765625 >>> convert_binary_prefix(1, BinaryUnit.kilo, BinaryUnit.kilo) 1 >>> convert_binary_prefix(1, 'giga', 'mega') 1024 >>> convert_binary_prefix(1, 'gIGa', 'mEGa') 1024","isinstance, isinstance, known_prefix.lower, unknown_prefix.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions_string.py","BinaryUnit","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions_string.py","SIUnit","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions_string.py","","add_si_prefix","Function that converts a number to his version with SI prefix @input value (an integer) @example: >>> add_si_prefix(10000) '10.0 kilo'","prefixes.items, str, SIUnit.get_positive, SIUnit.get_negative"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions_string.py","","add_binary_prefix","Function that converts a number to his version with Binary prefix @input value (an integer) @example: >>> add_binary_prefix(65536) '64.0 kilo'","str"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions_string.py","","get_positive","Returns a dictionary with only the elements of this enum that has a positive value >>> from itertools import islice >>> positive = SIUnit.get_positive() >>> inc = iter(positive.items()) >>> dict(islice(inc, len(positive) // 2)) {'yotta': 24, 'zetta': 21, 'exa': 18, 'peta': 15, 'tera': 12} >>> dict(inc) {'giga': 9, 'mega': 6, 'kilo': 3, 'hecto': 2, 'deca': 1}",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\prefix_conversions_string.py","","get_negative","Returns a dictionary with only the elements of this enum that has a negative value @example >>> from itertools import islice >>> negative = SIUnit.get_negative() >>> inc = iter(negative.items()) >>> dict(islice(inc, len(negative) // 2)) {'deci': -1, 'centi': -2, 'milli': -3, 'micro': -6, 'nano': -9} >>> dict(inc) {'pico': -12, 'femto': -15, 'atto': -18, 'zepto': -21, 'yocto': -24}",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\pressure_conversions.py","FromTo","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\pressure_conversions.py","","pressure_conversion","Conversion between pressure units. >>> pressure_conversion(4, ""atm"", ""pascal"") 405300 >>> pressure_conversion(1, ""pascal"", ""psi"") 0.00014401981999999998 >>> pressure_conversion(1, ""bar"", ""atm"") 0.986923 >>> pressure_conversion(3, ""kilopascal"", ""bar"") 0.029999991892499998 >>> pressure_conversion(2, ""megapascal"", ""psi"") 290.074434314 >>> pressure_conversion(4, ""psi"", ""torr"") 206.85984 >>> pressure_conversion(1, ""inHg"", ""atm"") 0.0334211 >>> pressure_conversion(1, ""torr"", ""psi"") 0.019336718261000002 >>> pressure_conversion(4, ""wrongUnit"", ""atm"") Traceback (most recent call last):     ... ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are: atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr","ValueError, ValueError, .join, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\rectangular_to_polar.py","","rectangular_to_polar","https://en.wikipedia.org/wiki/Polar_coordinate_system  >>> rectangular_to_polar(5,-5) (7.07, -45.0) >>> rectangular_to_polar(-1,1) (1.41, 135.0) >>> rectangular_to_polar(-1,-1) (1.41, -135.0) >>> rectangular_to_polar(1e-10,1e-10) (0.0, 45.0) >>> rectangular_to_polar(-1e-10,1e-10) (0.0, 135.0) >>> rectangular_to_polar(9.75,5.93) (11.41, 31.31) >>> rectangular_to_polar(10000,99999) (100497.76, 84.29)","round, round, math.sqrt, math.degrees, math.atan2"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\rgb_cmyk_conversion.py","","rgb_to_cmyk","Simple RGB to CMYK conversion. Returns percentages of CMYK paint. https://www.programmingalgorithms.com/algorithm/rgb-to-cmyk/  Note: this is a very popular algorithm that converts colors linearly and gives only approximate results. Actual preparation for printing requires advanced color conversion considering the color profiles and parameters of the target device.  >>> rgb_to_cmyk(255, 200, ""a"") Traceback (most recent call last):     ... ValueError: Expected int, found (<class 'int'>, <class 'int'>, <class 'str'>)  >>> rgb_to_cmyk(255, 255, 999) Traceback (most recent call last):     ... ValueError: Expected int of the range 0..255  >>> rgb_to_cmyk(255, 255, 255)  # white (0, 0, 0, 0)  >>> rgb_to_cmyk(128, 128, 128)  # gray (0, 0, 0, 50)  >>> rgb_to_cmyk(0, 0, 0)    # black (0, 0, 0, 100)  >>> rgb_to_cmyk(255, 0, 0)  # red (0, 100, 100, 0)  >>> rgb_to_cmyk(0, 255, 0)  # green (100, 0, 100, 0)  >>> rgb_to_cmyk(0, 0, 255)    # blue (100, 100, 0, 0)","round, round, round, round, ValueError, ValueError, max, isinstance, isinstance, isinstance, type, type, type"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\rgb_hsv_conversion.py","","hsv_to_rgb","Conversion from the HSV-representation to the RGB-representation. Expected RGB-values taken from https://www.rapidtables.com/convert/color/hsv-to-rgb.html  >>> hsv_to_rgb(0, 0, 0) [0, 0, 0] >>> hsv_to_rgb(0, 0, 1) [255, 255, 255] >>> hsv_to_rgb(0, 1, 1) [255, 0, 0] >>> hsv_to_rgb(60, 1, 1) [255, 255, 0] >>> hsv_to_rgb(120, 1, 1) [0, 255, 0] >>> hsv_to_rgb(240, 1, 1) [0, 0, 255] >>> hsv_to_rgb(300, 1, 1) [255, 0, 255] >>> hsv_to_rgb(180, 0.5, 0.5) [64, 128, 128] >>> hsv_to_rgb(234, 0.14, 0.88) [193, 196, 224] >>> hsv_to_rgb(330, 0.75, 0.5) [128, 32, 80]","Exception, Exception, Exception, round, round, round, abs, round, round, round, round, round, round, round, round, round, round, round, round, round, round, round"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\rgb_hsv_conversion.py","","rgb_to_hsv","Conversion from the RGB-representation to the HSV-representation. The tested values are the reverse values from the hsv_to_rgb-doctests. Function ""approximately_equal_hsv"" is needed because of small deviations due to rounding for the RGB-values.  >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0]) True >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1]) True >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1]) True >>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1]) True >>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1]) True >>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1]) True >>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1]) True >>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5]) True >>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88]) True >>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5]) True","max, Exception, Exception, Exception, min"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\rgb_hsv_conversion.py","","approximately_equal_hsv","Utility-function to check that two hsv-colors are approximately equal  >>> approximately_equal_hsv([0, 0, 0], [0, 0, 0]) True >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001]) True >>> approximately_equal_hsv([0, 0, 0], [1, 0, 0]) False >>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001]) False","abs, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\roman_numerals.py","","roman_to_int","LeetCode No. 13 Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. https://en.wikipedia.org/wiki/Roman_numerals >>> tests = {""III"": 3, ""CLIV"": 154, ""MIX"": 1009, ""MMD"": 2500, ""MMMCMXCIX"": 3999} >>> all(roman_to_int(key) == value for key, value in tests.items()) True","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\roman_numerals.py","","int_to_roman","Given a integer, convert it to an roman numeral. https://en.wikipedia.org/wiki/Roman_numerals >>> tests = {""III"": 3, ""CLIV"": 154, ""MIX"": 1009, ""MMD"": 2500, ""MMMCMXCIX"": 3999} >>> all(int_to_roman(value) == key for key, value in tests.items()) True",".join, divmod, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\speed_conversions.py","","convert_speed","Convert speed from one unit to another using the speed_chart above.  ""km/h"": 1.0, ""m/s"": 3.6, ""mph"": 1.609344, ""knot"": 1.852,  >>> convert_speed(100, ""km/h"", ""m/s"") 27.778 >>> convert_speed(100, ""km/h"", ""mph"") 62.137 >>> convert_speed(100, ""km/h"", ""knot"") 53.996 >>> convert_speed(100, ""m/s"", ""km/h"") 360.0 >>> convert_speed(100, ""m/s"", ""mph"") 223.694 >>> convert_speed(100, ""m/s"", ""knot"") 194.384 >>> convert_speed(100, ""mph"", ""km/h"") 160.934 >>> convert_speed(100, ""mph"", ""m/s"") 44.704 >>> convert_speed(100, ""mph"", ""knot"") 86.898 >>> convert_speed(100, ""knot"", ""km/h"") 185.2 >>> convert_speed(100, ""knot"", ""m/s"") 51.444 >>> convert_speed(100, ""knot"", ""mph"") 115.078","round, ValueError, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","celsius_to_fahrenheit","Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Celsius Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit  >>> celsius_to_fahrenheit(273.354, 3) 524.037 >>> celsius_to_fahrenheit(273.354, 0) 524.0 >>> celsius_to_fahrenheit(-40.0) -40.0 >>> celsius_to_fahrenheit(-20.0) -4.0 >>> celsius_to_fahrenheit(0) 32.0 >>> celsius_to_fahrenheit(20) 68.0 >>> celsius_to_fahrenheit(""40"") 104.0 >>> celsius_to_fahrenheit(""celsius"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'celsius'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","celsius_to_kelvin","Convert a given value from Celsius to Kelvin and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Celsius Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin  >>> celsius_to_kelvin(273.354, 3) 546.504 >>> celsius_to_kelvin(273.354, 0) 547.0 >>> celsius_to_kelvin(0) 273.15 >>> celsius_to_kelvin(20.0) 293.15 >>> celsius_to_kelvin(""40"") 313.15 >>> celsius_to_kelvin(""celsius"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'celsius'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","celsius_to_rankine","Convert a given value from Celsius to Rankine and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Celsius Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale  >>> celsius_to_rankine(273.354, 3) 983.707 >>> celsius_to_rankine(273.354, 0) 984.0 >>> celsius_to_rankine(0) 491.67 >>> celsius_to_rankine(20.0) 527.67 >>> celsius_to_rankine(""40"") 563.67 >>> celsius_to_rankine(""celsius"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'celsius'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","fahrenheit_to_celsius","Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit Wikipedia reference: https://en.wikipedia.org/wiki/Celsius  >>> fahrenheit_to_celsius(273.354, 3) 134.086 >>> fahrenheit_to_celsius(273.354, 0) 134.0 >>> fahrenheit_to_celsius(0) -17.78 >>> fahrenheit_to_celsius(20.0) -6.67 >>> fahrenheit_to_celsius(40.0) 4.44 >>> fahrenheit_to_celsius(60) 15.56 >>> fahrenheit_to_celsius(80) 26.67 >>> fahrenheit_to_celsius(""100"") 37.78 >>> fahrenheit_to_celsius(""fahrenheit"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'fahrenheit'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","fahrenheit_to_kelvin","Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin  >>> fahrenheit_to_kelvin(273.354, 3) 407.236 >>> fahrenheit_to_kelvin(273.354, 0) 407.0 >>> fahrenheit_to_kelvin(0) 255.37 >>> fahrenheit_to_kelvin(20.0) 266.48 >>> fahrenheit_to_kelvin(40.0) 277.59 >>> fahrenheit_to_kelvin(60) 288.71 >>> fahrenheit_to_kelvin(80) 299.82 >>> fahrenheit_to_kelvin(""100"") 310.93 >>> fahrenheit_to_kelvin(""fahrenheit"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'fahrenheit'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","fahrenheit_to_rankine","Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale  >>> fahrenheit_to_rankine(273.354, 3) 733.024 >>> fahrenheit_to_rankine(273.354, 0) 733.0 >>> fahrenheit_to_rankine(0) 459.67 >>> fahrenheit_to_rankine(20.0) 479.67 >>> fahrenheit_to_rankine(40.0) 499.67 >>> fahrenheit_to_rankine(60) 519.67 >>> fahrenheit_to_rankine(80) 539.67 >>> fahrenheit_to_rankine(""100"") 559.67 >>> fahrenheit_to_rankine(""fahrenheit"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'fahrenheit'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","kelvin_to_celsius","Convert a given value from Kelvin to Celsius and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin Wikipedia reference: https://en.wikipedia.org/wiki/Celsius  >>> kelvin_to_celsius(273.354, 3) 0.204 >>> kelvin_to_celsius(273.354, 0) 0.0 >>> kelvin_to_celsius(273.15) 0.0 >>> kelvin_to_celsius(300) 26.85 >>> kelvin_to_celsius(""315.5"") 42.35 >>> kelvin_to_celsius(""kelvin"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'kelvin'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","kelvin_to_fahrenheit","Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit  >>> kelvin_to_fahrenheit(273.354, 3) 32.367 >>> kelvin_to_fahrenheit(273.354, 0) 32.0 >>> kelvin_to_fahrenheit(273.15) 32.0 >>> kelvin_to_fahrenheit(300) 80.33 >>> kelvin_to_fahrenheit(""315.5"") 108.23 >>> kelvin_to_fahrenheit(""kelvin"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'kelvin'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","kelvin_to_rankine","Convert a given value from Kelvin to Rankine and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale  >>> kelvin_to_rankine(273.354, 3) 492.037 >>> kelvin_to_rankine(273.354, 0) 492.0 >>> kelvin_to_rankine(0) 0.0 >>> kelvin_to_rankine(20.0) 36.0 >>> kelvin_to_rankine(""40"") 72.0 >>> kelvin_to_rankine(""kelvin"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'kelvin'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","rankine_to_celsius","Convert a given value from Rankine to Celsius and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale Wikipedia reference: https://en.wikipedia.org/wiki/Celsius  >>> rankine_to_celsius(273.354, 3) -121.287 >>> rankine_to_celsius(273.354, 0) -121.0 >>> rankine_to_celsius(273.15) -121.4 >>> rankine_to_celsius(300) -106.48 >>> rankine_to_celsius(""315.5"") -97.87 >>> rankine_to_celsius(""rankine"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'rankine'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","rankine_to_fahrenheit","Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit  >>> rankine_to_fahrenheit(273.15) -186.52 >>> rankine_to_fahrenheit(300) -159.67 >>> rankine_to_fahrenheit(""315.5"") -144.17 >>> rankine_to_fahrenheit(""rankine"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'rankine'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","rankine_to_kelvin","Convert a given value from Rankine to Kelvin and round it to 2 decimal places. Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin  >>> rankine_to_kelvin(0) 0.0 >>> rankine_to_kelvin(20.0) 11.11 >>> rankine_to_kelvin(""40"") 22.22 >>> rankine_to_kelvin(""rankine"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'rankine'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","reaumur_to_kelvin","Convert a given value from reaumur to Kelvin and round it to 2 decimal places. Reference:- http://www.csgnetwork.com/temp2conv.html  >>> reaumur_to_kelvin(0) 273.15 >>> reaumur_to_kelvin(20.0) 298.15 >>> reaumur_to_kelvin(40) 323.15 >>> reaumur_to_kelvin(""reaumur"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'reaumur'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","reaumur_to_fahrenheit","Convert a given value from reaumur to fahrenheit and round it to 2 decimal places. Reference:- http://www.csgnetwork.com/temp2conv.html  >>> reaumur_to_fahrenheit(0) 32.0 >>> reaumur_to_fahrenheit(20.0) 77.0 >>> reaumur_to_fahrenheit(40) 122.0 >>> reaumur_to_fahrenheit(""reaumur"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'reaumur'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","reaumur_to_celsius","Convert a given value from reaumur to celsius and round it to 2 decimal places. Reference:- http://www.csgnetwork.com/temp2conv.html  >>> reaumur_to_celsius(0) 0.0 >>> reaumur_to_celsius(20.0) 25.0 >>> reaumur_to_celsius(40) 50.0 >>> reaumur_to_celsius(""reaumur"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'reaumur'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\temperature_conversions.py","","reaumur_to_rankine","Convert a given value from reaumur to rankine and round it to 2 decimal places. Reference:- http://www.csgnetwork.com/temp2conv.html  >>> reaumur_to_rankine(0) 491.67 >>> reaumur_to_rankine(20.0) 536.67 >>> reaumur_to_rankine(40) 581.67 >>> reaumur_to_rankine(""reaumur"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'reaumur'","round, float"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\time_conversions.py","","convert_time","Convert time from one unit to another using the time_chart above.  >>> convert_time(3600, ""seconds"", ""hours"") 1.0 >>> convert_time(3500, ""Seconds"", ""Hours"") 0.972 >>> convert_time(1, ""DaYs"", ""hours"") 24.0 >>> convert_time(120, ""minutes"", ""SeCoNdS"") 7200.0 >>> convert_time(2, ""WEEKS"", ""days"") 14.0 >>> convert_time(0.5, ""hours"", ""MINUTES"") 30.0 >>> convert_time(-3600, ""seconds"", ""hours"") Traceback (most recent call last):     ... ValueError: 'time_value' must be a non-negative number. >>> convert_time(""Hello"", ""hours"", ""minutes"") Traceback (most recent call last):     ... ValueError: 'time_value' must be a non-negative number. >>> convert_time([0, 1, 2], ""weeks"", ""days"") Traceback (most recent call last):     ... ValueError: 'time_value' must be a non-negative number. >>> convert_time(1, ""cool"", ""century"")  # doctest: +ELLIPSIS Traceback (most recent call last):     ... ValueError: Invalid unit cool is not in seconds, minutes, hours, days, weeks, ... >>> convert_time(1, ""seconds"", ""hot"")  # doctest: +ELLIPSIS Traceback (most recent call last):     ... ValueError: Invalid unit hot is not in seconds, minutes, hours, days, weeks, ...","unit_from.lower, unit_to.lower, round, ValueError, ValueError, isinstance, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\volume_conversions.py","FromTo","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\volume_conversions.py","","volume_conversion","Conversion between volume units. >>> volume_conversion(4, ""cubic meter"", ""litre"") 4000 >>> volume_conversion(1, ""litre"", ""gallon"") 0.264172 >>> volume_conversion(1, ""kilolitre"", ""cubic meter"") 1 >>> volume_conversion(3, ""gallon"", ""cubic yard"") 0.017814279 >>> volume_conversion(2, ""cubic yard"", ""litre"") 1529.1 >>> volume_conversion(4, ""cubic foot"", ""cup"") 473.396 >>> volume_conversion(1, ""cup"", ""kilolitre"") 0.000236588 >>> volume_conversion(4, ""wrongUnit"", ""litre"") Traceback (most recent call last):     ... ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are: cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup","ValueError, ValueError, .join, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\conversions\weight_conversion.py","","weight_conversion","Conversion of weight unit with the help of KILOGRAM_CHART  ""kilogram"" : 1, ""gram"" : pow(10, 3), ""milligram"" : pow(10, 6), ""metric-ton"" : pow(10, -3), ""long-ton"" : 0.0009842073, ""short-ton"" : 0.0011023122, ""pound"" : 2.2046244202, ""stone"": 0.1574731728, ""ounce"" : 35.273990723, ""carrat"" : 5000, ""atomic-mass-unit"" : 6.022136652E+26  >>> weight_conversion(""kilogram"",""kilogram"",4) 4 >>> weight_conversion(""kilogram"",""gram"",1) 1000 >>> weight_conversion(""kilogram"",""milligram"",4) 4000000 >>> weight_conversion(""kilogram"",""metric-ton"",4) 0.004 >>> weight_conversion(""kilogram"",""long-ton"",3) 0.0029526219 >>> weight_conversion(""kilogram"",""short-ton"",1) 0.0011023122 >>> weight_conversion(""kilogram"",""pound"",4) 8.8184976808 >>> weight_conversion(""kilogram"",""stone"",5) 0.7873658640000001 >>> weight_conversion(""kilogram"",""ounce"",4) 141.095962892 >>> weight_conversion(""kilogram"",""carrat"",3) 15000 >>> weight_conversion(""kilogram"",""atomic-mass-unit"",1) 6.022136652e+26 >>> weight_conversion(""gram"",""kilogram"",1) 0.001 >>> weight_conversion(""gram"",""gram"",3) 3.0 >>> weight_conversion(""gram"",""milligram"",2) 2000.0 >>> weight_conversion(""gram"",""metric-ton"",4) 4e-06 >>> weight_conversion(""gram"",""long-ton"",3) 2.9526219e-06 >>> weight_conversion(""gram"",""short-ton"",3) 3.3069366000000003e-06 >>> weight_conversion(""gram"",""pound"",3) 0.0066138732606 >>> weight_conversion(""gram"",""stone"",4) 0.0006298926912000001 >>> weight_conversion(""gram"",""ounce"",1) 0.035273990723 >>> weight_conversion(""gram"",""carrat"",2) 10.0 >>> weight_conversion(""gram"",""atomic-mass-unit"",1) 6.022136652e+23 >>> weight_conversion(""milligram"",""kilogram"",1) 1e-06 >>> weight_conversion(""milligram"",""gram"",2) 0.002 >>> weight_conversion(""milligram"",""milligram"",3) 3.0 >>> weight_conversion(""milligram"",""metric-ton"",3) 3e-09 >>> weight_conversion(""milligram"",""long-ton"",3) 2.9526219e-09 >>> weight_conversion(""milligram"",""short-ton"",1) 1.1023122e-09 >>> weight_conversion(""milligram"",""pound"",3) 6.6138732605999995e-06 >>> weight_conversion(""milligram"",""ounce"",2) 7.054798144599999e-05 >>> weight_conversion(""milligram"",""carrat"",1) 0.005 >>> weight_conversion(""milligram"",""atomic-mass-unit"",1) 6.022136652e+20 >>> weight_conversion(""metric-ton"",""kilogram"",2) 2000 >>> weight_conversion(""metric-ton"",""gram"",2) 2000000 >>> weight_conversion(""metric-ton"",""milligram"",3) 3000000000 >>> weight_conversion(""metric-ton"",""metric-ton"",2) 2.0 >>> weight_conversion(""metric-ton"",""long-ton"",3) 2.9526219 >>> weight_conversion(""metric-ton"",""short-ton"",2) 2.2046244 >>> weight_conversion(""metric-ton"",""pound"",3) 6613.8732606 >>> weight_conversion(""metric-ton"",""ounce"",4) 141095.96289199998 >>> weight_conversion(""metric-ton"",""carrat"",4) 20000000 >>> weight_conversion(""metric-ton"",""atomic-mass-unit"",1) 6.022136652e+29 >>> weight_conversion(""long-ton"",""kilogram"",4) 4064.18432 >>> weight_conversion(""long-ton"",""gram"",4) 4064184.32 >>> weight_conversion(""long-ton"",""milligram"",3) 3048138240.0 >>> weight_conversion(""long-ton"",""metric-ton"",4) 4.06418432 >>> weight_conversion(""long-ton"",""long-ton"",3) 2.999999907217152 >>> weight_conversion(""long-ton"",""short-ton"",1) 1.119999989746176 >>> weight_conversion(""long-ton"",""pound"",3) 6720.000000049448 >>> weight_conversion(""long-ton"",""ounce"",1) 35840.000000060514 >>> weight_conversion(""long-ton"",""carrat"",4) 20320921.599999998 >>> weight_conversion(""long-ton"",""atomic-mass-unit"",4) 2.4475073353955697e+30 >>> weight_conversion(""short-ton"",""kilogram"",3) 2721.5519999999997 >>> weight_conversion(""short-ton"",""gram"",3) 2721552.0 >>> weight_conversion(""short-ton"",""milligram"",1) 907184000.0 >>> weight_conversion(""short-ton"",""metric-ton"",4) 3.628736 >>> weight_conversion(""short-ton"",""long-ton"",3) 2.6785713457296 >>> weight_conversion(""short-ton"",""short-ton"",3) 2.9999999725344 >>> weight_conversion(""short-ton"",""pound"",2) 4000.0000000294335 >>> weight_conversion(""short-ton"",""ounce"",4) 128000.00000021611 >>> weight_conversion(""short-ton"",""carrat"",4) 18143680.0 >>> weight_conversion(""short-ton"",""atomic-mass-unit"",1) 5.463186016507968e+29 >>> weight_conversion(""pound"",""kilogram"",4) 1.814368 >>> weight_conversion(""pound"",""gram"",2) 907.184 >>> weight_conversion(""pound"",""milligram"",3) 1360776.0 >>> weight_conversion(""pound"",""metric-ton"",3) 0.001360776 >>> weight_conversion(""pound"",""long-ton"",2) 0.0008928571152432 >>> weight_conversion(""pound"",""short-ton"",1) 0.0004999999954224 >>> weight_conversion(""pound"",""pound"",3) 3.0000000000220752 >>> weight_conversion(""pound"",""ounce"",1) 16.000000000027015 >>> weight_conversion(""pound"",""carrat"",1) 2267.96 >>> weight_conversion(""pound"",""atomic-mass-unit"",4) 1.0926372033015936e+27 >>> weight_conversion(""stone"",""kilogram"",5) 31.751450000000002 >>> weight_conversion(""stone"",""gram"",2) 12700.58 >>> weight_conversion(""stone"",""milligram"",3) 19050870.0 >>> weight_conversion(""stone"",""metric-ton"",3) 0.01905087 >>> weight_conversion(""stone"",""long-ton"",3) 0.018750005325351003 >>> weight_conversion(""stone"",""short-ton"",3) 0.021000006421614002 >>> weight_conversion(""stone"",""pound"",2) 28.00000881870372 >>> weight_conversion(""stone"",""ounce"",1) 224.00007054835967 >>> weight_conversion(""stone"",""carrat"",2) 63502.9 >>> weight_conversion(""ounce"",""kilogram"",3) 0.0850485 >>> weight_conversion(""ounce"",""gram"",3) 85.0485 >>> weight_conversion(""ounce"",""milligram"",4) 113398.0 >>> weight_conversion(""ounce"",""metric-ton"",4) 0.000113398 >>> weight_conversion(""ounce"",""long-ton"",4) 0.0001116071394054 >>> weight_conversion(""ounce"",""short-ton"",4) 0.0001249999988556 >>> weight_conversion(""ounce"",""pound"",1) 0.0625000000004599 >>> weight_conversion(""ounce"",""ounce"",2) 2.000000000003377 >>> weight_conversion(""ounce"",""carrat"",1) 141.7475 >>> weight_conversion(""ounce"",""atomic-mass-unit"",1) 1.70724563015874e+25 >>> weight_conversion(""carrat"",""kilogram"",1) 0.0002 >>> weight_conversion(""carrat"",""gram"",4) 0.8 >>> weight_conversion(""carrat"",""milligram"",2) 400.0 >>> weight_conversion(""carrat"",""metric-ton"",2) 4.0000000000000003e-07 >>> weight_conversion(""carrat"",""long-ton"",3) 5.9052438e-07 >>> weight_conversion(""carrat"",""short-ton"",4) 8.818497600000002e-07 >>> weight_conversion(""carrat"",""pound"",1) 0.00044092488404000004 >>> weight_conversion(""carrat"",""ounce"",2) 0.0141095962892 >>> weight_conversion(""carrat"",""carrat"",4) 4.0 >>> weight_conversion(""carrat"",""atomic-mass-unit"",4) 4.8177093216e+23 >>> weight_conversion(""atomic-mass-unit"",""kilogram"",4) 6.642160796e-27 >>> weight_conversion(""atomic-mass-unit"",""gram"",2) 3.321080398e-24 >>> weight_conversion(""atomic-mass-unit"",""milligram"",2) 3.3210803980000002e-21 >>> weight_conversion(""atomic-mass-unit"",""metric-ton"",3) 4.9816205970000004e-30 >>> weight_conversion(""atomic-mass-unit"",""long-ton"",3) 4.9029473573977584e-30 >>> weight_conversion(""atomic-mass-unit"",""short-ton"",1) 1.830433719948128e-30 >>> weight_conversion(""atomic-mass-unit"",""pound"",3) 1.0982602420317504e-26 >>> weight_conversion(""atomic-mass-unit"",""ounce"",2) 1.1714775914938915e-25 >>> weight_conversion(""atomic-mass-unit"",""carrat"",2) 1.660540199e-23 >>> weight_conversion(""atomic-mass-unit"",""atomic-mass-unit"",2) 1.999999998903455 >>> weight_conversion(""slug"", ""kilogram"", 1) Traceback (most recent call last): ... ValueError: Invalid 'from_type' or 'to_type' value: 'slug', 'kilogram' Supported values are: kilogram, gram, milligram, metric-ton, long-ton, short-ton, pound, stone, ounce, carrat, atomic-mass-unit","ValueError, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\burrows_wheeler.py","BWTTransformDict","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\burrows_wheeler.py","","all_rotations",":param s: The string that will be rotated len(s) times. :return: A list with the rotations. :raises TypeError: If s is not an instance of str. Examples:  >>> all_rotations(""^BANANA|"") # doctest: +NORMALIZE_WHITESPACE ['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA', 'A|^BANAN', '|^BANANA'] >>> all_rotations(""a_asa_da_casa"") # doctest: +NORMALIZE_WHITESPACE ['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a', 'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d', '_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca', 'aa_asa_da_cas'] >>> all_rotations(""panamabanana"") # doctest: +NORMALIZE_WHITESPACE ['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan', 'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab', 'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan'] >>> all_rotations(5) Traceback (most recent call last):     ... TypeError: The parameter s type must be str.","isinstance, TypeError, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\burrows_wheeler.py","","bwt_transform",":param s: The string that will be used at bwt algorithm :return: the string composed of the last char of each row of the ordered rotations and the index of the original string at ordered rotations list :raises TypeError: If the s parameter type is not str :raises ValueError: If the s parameter is empty Examples:  >>> bwt_transform(""^BANANA"") {'bwt_string': 'BNN^AAA', 'idx_original_string': 6} >>> bwt_transform(""a_asa_da_casa"") {'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3} >>> bwt_transform(""panamabanana"") {'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11} >>> bwt_transform(4) Traceback (most recent call last):     ... TypeError: The parameter s type must be str. >>> bwt_transform('') Traceback (most recent call last):     ... ValueError: The parameter s must not be empty.","all_rotations, rotations.sort, isinstance, TypeError, ValueError, .join, rotations.index"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\burrows_wheeler.py","","reverse_bwt",":param bwt_string: The string returned from bwt algorithm execution :param idx_original_string: A 0-based index of the string that was used to generate bwt_string at ordered rotations list :return: The string used to generate bwt_string when bwt was executed :raises TypeError: If the bwt_string parameter type is not str :raises ValueError: If the bwt_string parameter is empty :raises TypeError: If the idx_original_string type is not int or if not possible to cast it to int :raises ValueError: If the idx_original_string value is lower than 0 or greater than len(bwt_string) - 1  >>> reverse_bwt(""BNN^AAA"", 6) '^BANANA' >>> reverse_bwt(""aaaadss_c__aa"", 3) 'a_asa_da_casa' >>> reverse_bwt(""mnpbnnaaaaaa"", 11) 'panamabanana' >>> reverse_bwt(4, 11) Traceback (most recent call last):     ... TypeError: The parameter bwt_string type must be str. >>> reverse_bwt("""", 11) Traceback (most recent call last):     ... ValueError: The parameter bwt_string must not be empty. >>> reverse_bwt(""mnpbnnaaaaaa"", ""asd"") # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... TypeError: The parameter idx_original_string type must be int or passive of cast to int. >>> reverse_bwt(""mnpbnnaaaaaa"", -1) Traceback (most recent call last):     ... ValueError: The parameter idx_original_string must not be lower than 0. >>> reverse_bwt(""mnpbnnaaaaaa"", 12) # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: The parameter idx_original_string must be lower than len(bwt_string). >>> reverse_bwt(""mnpbnnaaaaaa"", 11.0) 'panamabanana' >>> reverse_bwt(""mnpbnnaaaaaa"", 11.4) 'panamabanana'","range, isinstance, TypeError, ValueError, int, ValueError, len, ValueError, len, len, range, ordered_rotations.sort, TypeError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\coordinate_compression.py","CoordinateCompressor","","A class for coordinate compression.  This class allows you to compress and decompress a list of values.  Mapping: In addition to compression and decompression, this class maintains a mapping between original values and their compressed counterparts using two data structures: a dictionary `coordinate_map` and a list `reverse_map`: - `coordinate_map`: A dictionary that maps original values to their compressed   coordinates. Keys are original values, and values are compressed coordinates. - `reverse_map`: A list used for reverse mapping, where each index corresponds   to a compressed coordinate, and the value at that index is the original value.  Example of mapping: Original: 10, Compressed: 0 Original: 52, Compressed: 1 Original: 83, Compressed: 2 Original: 100, Compressed: 3  This mapping allows for efficient compression and decompression of values within the list.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\coordinate_compression.py","","__init__","Initialize the CoordinateCompressor with a list.  Args: arr: The list of values to be compressed.  >>> arr = [100, 10, 52, 83] >>> cc = CoordinateCompressor(arr) >>> cc.compress(100) 3 >>> cc.compress(52) 1 >>> cc.decompress(1) 52","sorted, len, self.compress_coordinates, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\coordinate_compression.py","","compress_coordinates","Compress the coordinates in the input list.  >>> arr = [100, 10, 52, 83] >>> cc = CoordinateCompressor(arr) >>> cc.coordinate_map[83] 2 >>> cc.coordinate_map[80]  # Value not in the original list Traceback (most recent call last):     ... KeyError: 80 >>> cc.reverse_map[2] 83",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\coordinate_compression.py","","compress","Compress a single value.  Args: original: The value to compress.  Returns: The compressed integer, or -1 if not found in the original list.  >>> arr = [100, 10, 52, 83] >>> cc = CoordinateCompressor(arr) >>> cc.compress(100) 3 >>> cc.compress(7)  # Value not in the original list -1","self.coordinate_map.get"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\coordinate_compression.py","","decompress","Decompress a single integer.  Args: num: The compressed integer to decompress.  Returns: The original value.  >>> arr = [100, 10, 52, 83] >>> cc = CoordinateCompressor(arr) >>> cc.decompress(0) 10 >>> cc.decompress(5)  # Compressed coordinate out of range -1","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","Letter","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","TreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","parse_file","Read the file and build a dict of all letters and their frequencies, then convert the dict into a list of Letters.","sorted, open, f.read, Letter, chars.items"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","build_tree","Run through the list of Letters and build the min heap for the Huffman Tree.","list, len, response.pop, response.pop, TreeNode, response.append, response.sort"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","traverse_tree","Recursively traverse the Huffman Tree to set each Letter's bitstring dictionary, and return the list of Letters","isinstance, traverse_tree, traverse_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","huffman","Parse the file, build the tree, then run through the file again, using the letters dictionary to find and print out the bitstring for each letter.","parse_file, build_tree, print, print, open, traverse_tree, letter.bitstring.items, f.read, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\huffman.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv.py","","read_file_binary","Reads given file as bytes and returns them as a long string","open, binary_file.read, print, sys.exit"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv.py","","add_key_to_lexicon","Adds new strings (curr_string + ""0"",  curr_string + ""1"") to the lexicon","lexicon.pop, .is_integer, lexicon.items, bin, math.log2"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv.py","","compress_data","Compresses given data_bits using Lempel-Ziv-Welch compression algorithm and returns the result as a string","len, range, len, add_key_to_lexicon"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv.py","","add_file_length","Adds given file's length in front (using Elias  gamma coding) of the compressed string","os.path.getsize, len, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv.py","","write_file_binary","Writes given to_write string (should only consist of 0's and 1's) as bytes in the file","open, print, sys.exit, result_byte_array.append, opened_file.write, range, len, .to_bytes, len, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv.py","","compress","Reads source file, compresses it and writes the compressed result in destination file","read_file_binary, compress_data, add_file_length, write_file_binary"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv_decompress.py","","read_file_binary","Reads given file as bytes and returns them as a long string","open, binary_file.read, print, sys.exit"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv_decompress.py","","decompress_data","Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm and returns the result as a string","len, range, len, .is_integer, list, math.log2, lexicon.pop, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv_decompress.py","","write_file_binary","Writes given to_write string (should only consist of 0's and 1's) as bytes in the file","open, print, sys.exit, result_byte_array.append, opened_file.write, range, len, .to_bytes, len, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv_decompress.py","","remove_prefix","Removes size prefix, that compressed file should have Returns the result",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lempel_ziv_decompress.py","","compress","Reads source file, decompresses it and writes the result in destination file","read_file_binary, remove_prefix, decompress_data, write_file_binary"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","Token","","Dataclass representing triplet called token consisting of length, offset and indicator. This triplet is used during LZ77 compression.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","LZ77Compressor","","Class containing compress and decompress methods using LZ77 compression algorithm.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","","__repr__",">>> token = Token(1, 2, ""c"") >>> repr(token) '(1, 2, c)' >>> str(token) '(1, 2, c)'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","","compress","Compress the given string text using LZ77 compression algorithm.  Args:     text: string to be compressed  Returns:     output: the compressed text as a list of Tokens  >>> lz77_compressor = LZ77Compressor() >>> str(lz77_compressor.compress(""ababcbababaa"")) '[(0, 0, a), (0, 0, b), (2, 2, c), (4, 3, a), (2, 2, a)]' >>> str(lz77_compressor.compress(""aacaacabcabaaac"")) '[(0, 0, a), (1, 1, c), (3, 4, b), (3, 3, a), (1, 2, c)]'","self._find_encoding_token, output.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","","decompress","Convert the list of tokens into an output string.  Args:     tokens: list containing triplets (offset, length, char)  Returns:     output: decompressed text  Tests:     >>> lz77_compressor = LZ77Compressor()     >>> lz77_compressor.decompress([Token(0, 0, 'c'), Token(0, 0, 'a'),     ... Token(0, 0, 'b'), Token(0, 0, 'r'), Token(3, 1, 'c'),     ... Token(2, 1, 'd'), Token(7, 4, 'r'), Token(3, 5, 'd')])     'cabracadabrarrarrad'     >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(0, 0, 'b'),     ... Token(2, 2, 'c'), Token(4, 3, 'a'), Token(2, 2, 'a')])     'ababcbababaa'     >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(1, 1, 'c'),     ... Token(3, 4, 'b'), Token(3, 3, 'a'), Token(1, 2, 'c')])     'aacaacabcabaaac'","range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","","_find_encoding_token","Finds the encoding token for the first character in the text.  Tests:     >>> lz77_compressor = LZ77Compressor()     >>> lz77_compressor._find_encoding_token(""abrarrarrad"", ""abracad"").offset     7     >>> lz77_compressor._find_encoding_token(""adabrarrarrad"", ""cabrac"").length     1     >>> lz77_compressor._find_encoding_token(""abc"", ""xyz"").offset     0     >>> lz77_compressor._find_encoding_token("""", ""xyz"").offset     Traceback (most recent call last):         ...     ValueError: We need some text to work with.     >>> lz77_compressor._find_encoding_token(""abc"", """").offset     0","enumerate, Token, ValueError, Token, len, self._match_length_from_index"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\lz77.py","","_match_length_from_index","Calculate the longest possible match of text and window characters from text_index in text and window_index in window.  Args:     text: _description_     window: sliding window     text_index: index of character in text     window_index: index of character in sliding window  Returns:     The maximum match between text and window, from given indexes.  Tests:     >>> lz77_compressor = LZ77Compressor(13, 6)     >>> lz77_compressor._match_length_from_index(""rarrad"", ""adabrar"", 0, 4)     5     >>> lz77_compressor._match_length_from_index(""adabrarrarrad"",     ...     ""cabrac"", 0, 1)     1","self._match_length_from_index"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\peak_signal_to_noise_ratio.py","","peak_signal_to_noise_ratio","","np.mean, math.log10, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\peak_signal_to_noise_ratio.py","","main","","os.path.dirname, cv2.imread, cv2.imread, cv2.imread, cv2.imread, print, print, print, print, os.path.realpath, os.path.join, os.path.join, os.path.join, os.path.join, peak_signal_to_noise_ratio, peak_signal_to_noise_ratio"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\run_length_encoding.py","","run_length_encode","Performs Run Length Encoding >>> run_length_encode(""AAAABBBCCDAA"") [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)] >>> run_length_encode(""A"") [('A', 1)] >>> run_length_encode(""AA"") [('A', 2)] >>> run_length_encode(""AAADDDDDDFFFCCCAAVVVV"") [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]","range, len, encoded.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_compression\run_length_encoding.py","","run_length_decode","Performs Run Length Decoding >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]) 'AAAABBBCCDAA' >>> run_length_decode([('A', 1)]) 'A' >>> run_length_decode([('A', 2)]) 'AA' >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]) 'AAADDDDDDFFFCCCAAVVVV'",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\equilibrium_index_in_array.py","","equilibrium_index","Find the equilibrium index of an array.  Args:     arr (list[int]): The input array of integers.  Returns:     int: The equilibrium index or -1 if no equilibrium index exists.  Examples:     >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])     3     >>> equilibrium_index([1, 2, 3, 4, 5])     -1     >>> equilibrium_index([1, 1, 1, 1, 1])     2     >>> equilibrium_index([2, 4, 6, 8, 10, 3])     -1","sum, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\find_triplets_with_0_sum.py","","find_triplets_with_0_sum","Given a list of integers, return elements a, b, c such that a + b + c = 0. Args:     nums: list of integers Returns:     list of lists of integers where sum(each_list) == 0 Examples:     >>> find_triplets_with_0_sum([-1, 0, 1, 2, -1, -4])     [[-1, -1, 2], [-1, 0, 1]]     >>> find_triplets_with_0_sum([])     []     >>> find_triplets_with_0_sum([0, 0, 0])     [[0, 0, 0]]     >>> find_triplets_with_0_sum([1, 2, 3, 0, -1, -2, -3])     [[-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]","list, sorted, combinations, sorted, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\find_triplets_with_0_sum.py","","find_triplets_with_0_sum_hashing","Function for finding the triplets with a given sum in the array using hashing.  Given a list of integers, return elements a, b, c such that a + b + c = 0.  Args:     nums: list of integers Returns:     list of lists of integers where sum(each_list) == 0 Examples:     >>> find_triplets_with_0_sum_hashing([-1, 0, 1, 2, -1, -4])     [[-1, 0, 1], [-1, -1, 2]]     >>> find_triplets_with_0_sum_hashing([])     []     >>> find_triplets_with_0_sum_hashing([0, 0, 0])     [[0, 0, 0]]     >>> find_triplets_with_0_sum_hashing([1, 2, 3, 0, -1, -2, -3])     [[-1, 0, 1], [-3, 1, 2], [-2, 0, 2], [-2, -1, 3], [-3, 0, 3]]  Time complexity: O(N^2) Auxiliary Space: O(N)","enumerate, set, set_initialize.add, sorted, output_arr.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\index_2d_array_in_1d.py","Index2DArrayIterator","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\index_2d_array_in_1d.py","","index_2d_array_in_1d","Retrieves the value of the one-dimensional index from a two-dimensional array.  Args:     array: A 2D array of integers where all rows are the same size and all            columns are the same size.     index: A 1D index.  Returns:     int: The 0-indexed value of the 1D index in the array.  Examples: >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 5) 5 >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], -1) Traceback (most recent call last):     ... ValueError: index out of range >>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 12) Traceback (most recent call last):     ... ValueError: index out of range >>> index_2d_array_in_1d([[]], 0) Traceback (most recent call last):     ... ValueError: no items in array","len, len, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\index_2d_array_in_1d.py","","__iter__",">>> tuple(Index2DArrayIterator([[5], [-523], [-1], [34], [0]])) (5, -523, -1, 34, 0) >>> tuple(Index2DArrayIterator([[5, -523, -1], [34, 0]])) (5, -523, -1, 34, 0) >>> tuple(Index2DArrayIterator([[5, -523, -1, 34, 0]])) (5, -523, -1, 34, 0) >>> t = Index2DArrayIterator([[5, 2, 25], [23, 14, 5], [324, -1, 0]]) >>> tuple(t) (5, 2, 25, 23, 14, 5, 324, -1, 0) >>> list(t) [5, 2, 25, 23, 14, 5, 324, -1, 0] >>> sorted(t) [-1, 0, 2, 5, 5, 14, 23, 25, 324] >>> tuple(t)[3] 23 >>> sum(t) 397 >>> -1 in t True >>> t = iter(Index2DArrayIterator([[5], [-523], [-1], [34], [0]])) >>> next(t) 5 >>> next(t) -523",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\kth_largest_element.py","","partition","Partitions list based on the pivot element.  This function rearranges the elements in the input list 'elements' such that all elements greater than or equal to the chosen pivot are on the right side of the pivot, and all elements smaller than the pivot are on the left side.  Args:     arr: The list to be partitioned     low: The lower index of the list     high: The higher index of the list  Returns:     int: The index of pivot element after partitioning      Examples:     >>> partition([3, 1, 4, 5, 9, 2, 6, 5, 3, 5], 0, 9)     4     >>> partition([7, 1, 4, 5, 9, 2, 6, 5, 8], 0, 8)     1     >>> partition(['apple', 'cherry', 'date', 'banana'], 0, 3)     2     >>> partition([3.1, 1.2, 5.6, 4.7], 0, 3)     1","range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\kth_largest_element.py","","kth_largest_element","Finds the kth largest element in a list. Should deliver similar results to: ```python def kth_largest_element(arr, position):     return sorted(arr)[-position] ```  Args:     nums: The list of numbers.     k: The position of the desired kth largest element.  Returns:     int: The kth largest element.  Examples:     >>> kth_largest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3)     5     >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], 1)     9     >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], -2)     Traceback (most recent call last):     ...     ValueError: Invalid value of 'position'     >>> kth_largest_element([9, 1, 3, 6, 7, 9, 8, 4, 2, 4, 9], 110)     Traceback (most recent call last):     ...     ValueError: Invalid value of 'position'     >>> kth_largest_element([1, 2, 4, 3, 5, 9, 7, 6, 5, 9, 3], 0)     Traceback (most recent call last):     ...     ValueError: Invalid value of 'position'     >>> kth_largest_element(['apple', 'cherry', 'date', 'banana'], 2)     'cherry'     >>> kth_largest_element([3.1, 1.2, 5.6, 4.7,7.9,5,0], 2)     5.6     >>> kth_largest_element([-2, -5, -4, -1], 1)     -1     >>> kth_largest_element([], 1)     -1     >>> kth_largest_element([3.1, 1.2, 5.6, 4.7, 7.9, 5, 0], 1.5)     Traceback (most recent call last):     ...     ValueError: The position should be an integer     >>> kth_largest_element((4, 6, 1, 2), 4)     Traceback (most recent call last):     ...     TypeError: 'tuple' object does not support item assignment","isinstance, ValueError, ValueError, partition, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\median_two_array.py","","find_median_sorted_arrays","Find the median of two arrays.  Args:     nums1: The first array.     nums2: The second array.  Returns: The median of the two arrays.  Examples:     >>> find_median_sorted_arrays([1, 3], [2])     2.0      >>> find_median_sorted_arrays([1, 2], [3, 4])     2.5      >>> find_median_sorted_arrays([0, 0], [0, 0])     0.0      >>> find_median_sorted_arrays([], [])     Traceback (most recent call last):         ...     ValueError: Both input arrays are empty.      >>> find_median_sorted_arrays([], [1])     1.0      >>> find_median_sorted_arrays([-1000], [1000])     0.0      >>> find_median_sorted_arrays([-1.1, -2.2], [-3.3, -4.4])     -2.75","sorted, len, ValueError, float, float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\monotonic_array.py","","is_monotonic","Check if a list is monotonic.  >>> is_monotonic([1, 2, 2, 3]) True >>> is_monotonic([6, 5, 4, 4]) True >>> is_monotonic([1, 3, 2]) False >>> is_monotonic([1,2,3,4,5,6,5]) False >>> is_monotonic([-3,-2,-1]) True >>> is_monotonic([-5,-6,-7]) True >>> is_monotonic([0,0,0]) True >>> is_monotonic([-100,0,100]) True","all, all, range, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\pairs_with_given_sum.py","","pairs_with_sum","Return the no. of pairs with sum ""sum"" >>> pairs_with_sum([1, 5, 7, 1], 6) 2 >>> pairs_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 2) 28 >>> pairs_with_sum([1, 7, 6, 2, 5, 4, 3, 1, 9, 8], 7) 4","len, combinations"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\permutations.py","","permute_recursive","Return all permutations.  >>> permute_recursive([1, 2, 3]) [[3, 2, 1], [2, 3, 1], [1, 3, 2], [3, 1, 2], [2, 1, 3], [1, 2, 3]]","range, len, len, nums.pop, permute_recursive, result.extend, nums.append, nums.copy, perm.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\permutations.py","","permute_backtrack","Return all permutations of the given list.  >>> permute_backtrack([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]","backtrack, output.append, range, len, len, backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\permutations.py","","backtrack","","output.append, range, len, len, backtrack"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\prefix_sum.py","PrefixSum","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\prefix_sum.py","","__init__","","len, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\prefix_sum.py","","get_sum","The function returns the sum of array from the start to the end indexes. Runtime : O(1) Space: O(1)  >>> PrefixSum([1,2,3]).get_sum(0, 2) 6 >>> PrefixSum([1,2,3]).get_sum(1, 2) 5 >>> PrefixSum([1,2,3]).get_sum(2, 2) 3 >>> PrefixSum([]).get_sum(0, 0) Traceback (most recent call last): ... ValueError: The array is empty. >>> PrefixSum([1,2,3]).get_sum(-1, 2) Traceback (most recent call last): ... ValueError: Invalid range specified. >>> PrefixSum([1,2,3]).get_sum(2, 3) Traceback (most recent call last): ... ValueError: Invalid range specified. >>> PrefixSum([1,2,3]).get_sum(2, 1) Traceback (most recent call last): ... ValueError: Invalid range specified.","ValueError, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\prefix_sum.py","","contains_sum","The function returns True if array contains the target_sum, False otherwise.  Runtime : O(n) Space: O(n)  >>> PrefixSum([1,2,3]).contains_sum(6) True >>> PrefixSum([1,2,3]).contains_sum(5) True >>> PrefixSum([1,2,3]).contains_sum(3) True >>> PrefixSum([1,2,3]).contains_sum(4) False >>> PrefixSum([1,2,3]).contains_sum(7) False >>> PrefixSum([1,-2,3]).contains_sum(2) True","sums.add"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\product_sum.py","","product_sum","Recursively calculates the product sum of an array.  The product sum of an array is defined as the sum of its elements multiplied by their respective depths.  If an element is a list, its product sum is calculated recursively by multiplying the sum of its elements with its depth plus one.  Args:     arr: The array of integers and nested lists.     depth: The current depth level.  Returns:     int: The product sum of the array.  Examples:     >>> product_sum([1, 2, 3], 1)     6     >>> product_sum([-1, 2, [-3, 4]], 2)     8     >>> product_sum([1, 2, 3], -1)     -6     >>> product_sum([1, 2, 3], 0)     0     >>> product_sum([1, 2, 3], 7)     42     >>> product_sum((1, 2, 3), 7)     42     >>> product_sum({1, 2, 3}, 7)     42     >>> product_sum([1, -1], 1)     0     >>> product_sum([1, -2], 1)     -1     >>> product_sum([-3.5, [1, [0.5]]], 1)     1.5","isinstance, product_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\product_sum.py","","product_sum_array","Calculates the product sum of an array.  Args:     array (List[Union[int, List]]): The array of integers and nested lists.  Returns:     int: The product sum of the array.  Examples:     >>> product_sum_array([1, 2, 3])     6     >>> product_sum_array([1, [2, 3]])     11     >>> product_sum_array([1, [2, [3, 4]]])     47     >>> product_sum_array([0])     0     >>> product_sum_array([-3.5, [1, [0.5]]])     1.5     >>> product_sum_array([1, -2])     -1","product_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\rotate_array.py","","rotate_array","Rotates a list to the right by steps positions.  Parameters: arr (List[int]): The list of integers to rotate. steps (int): Number of positions to rotate. Can be negative for left rotation.  Returns: List[int]: Rotated list.  Examples: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([], 3) []","len, reverse, reverse, reverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\rotate_array.py","","reverse","Reverses a portion of the list in place from index start to end.  Parameters: start (int): Starting index of the portion to reverse. end (int): Ending index of the portion to reverse.  Returns: None  Examples: >>> example = [1, 2, 3, 4, 5] >>> def reverse_test(arr, start, end): ...     while start < end: ...         arr[start], arr[end] = arr[end], arr[start] ...         start += 1 ...         end -= 1 >>> reverse_test(example, 0, 2) >>> example [3, 2, 1, 4, 5] >>> reverse_test(example, 2, 4) >>> example [3, 2, 5, 4, 1]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sparse_table.py","","build_sparse_table","Precompute range minimum queries with power of two length and store the precomputed values in a table.  >>> build_sparse_table([8, 1, 0, 3, 4, 9, 3]) [[8, 1, 0, 3, 4, 9, 3], [1, 0, 0, 3, 4, 3, 0], [0, 0, 0, 3, 0, 0, 0]] >>> build_sparse_table([3, 1, 9]) [[3, 1, 9], [1, 1, 0]] >>> build_sparse_table([]) Traceback (most recent call last): ... ValueError: empty number list not allowed","len, enumerate, ValueError, int, log2, range, min, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sparse_table.py","","query",">>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 4) 0 >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 4, 6) 3 >>> query(build_sparse_table([3, 1, 9]), 2, 2) 9 >>> query(build_sparse_table([3, 1, 9]), 0, 1) 1 >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 11) Traceback (most recent call last): ... IndexError: list index out of range >>> query(build_sparse_table([]), 0, 0) Traceback (most recent call last): ... ValueError: empty number list not allowed","int, min, IndexError, log2, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","cross","Cross product of elements in A and elements in B.  >>> cross('AB', '12') ['A1', 'A2', 'B1', 'B2'] >>> cross('ABC', '123') ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] >>> cross('ABC', '1234') ['A1', 'A2', 'A3', 'A4', 'B1', 'B2', 'B3', 'B4', 'C1', 'C2', 'C3', 'C4'] >>> cross('', '12') [] >>> cross('A', '') [] >>> cross('', '') []",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","test","A set of unit tests.","all, all, print, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","parse_grid","Convert grid to a dict of possible values, {square: digits}, or return False if a contradiction is detected.","dict.fromkeys, .items, grid_values, assign"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","grid_values","Convert grid into a dict of {square: char} with '0' or '.' for empties.","dict, len, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","assign","Eliminate all the other values (except d) from values[s] and propagate. Return values, except return False if a contradiction is detected.",".replace, all, eliminate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","eliminate","Eliminate d from values[s]; propagate when values or places <= 2. Return values, except return False if a contradiction is detected.",".replace, len, len, len, all, len, assign, eliminate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","display","Display these values as a 2-D grid.",".join, print, max, print, .join, print, len, .center"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","solve","Solve the grid.","search, parse_grid"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","some","Return some element of seq that is true.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","search","Using depth-first search and propagation, try all possible values.","all, min, some, search, len, len, assign, len, values.copy"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","solve_all","Attempt to solve a sequence of grids. Report results. When showif is a number of seconds, display puzzles that take longer. When showif is None, don't display any puzzles.","zip, time.monotonic, solve, print, time.monotonic, display, print, solved, len, grid_values, display, time_solve, sum, max, sum, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","solved","A puzzle is solved if each unit is a permutation of the digits 1 to 9.","all, set, unitsolved"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","from_file","Parse a file into a list of strings, separated by sep.","open, .split, .strip, file.read"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","random_puzzle","Make a random puzzle with N or more assignments. Restart on contradictions. Note the resulting puzzle is not guaranteed to be solvable, but empirically about 99.8% of them are solvable. Some have multiple solutions.","dict.fromkeys, shuffled, random_puzzle, assign, .join, random.choice, len, len, len, set, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","shuffled","Return a randomly shuffled copy of the input sequence.","list, random.shuffle"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","time_solve","","time.monotonic, solve, time.monotonic, display, print, solved, grid_values, display"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\arrays\sudoku_solver.py","","unitsolved","","set"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","MyQueue","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","MyNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_height","","node.get_height"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","my_max","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","right_rotation","A                      B        / \                    / \       B   C                  Bl  A      / \       -->          /   / \     Bl  Br                 UB Br  C    /  UB UB = unbalanced node","print, node.get_left, node.set_left, ret.set_right, node.set_height, ret.set_height, node.get_data, ret.get_right, my_max, my_max, get_height, get_height, get_height, get_height, node.get_right, node.get_left, ret.get_right, ret.get_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","left_rotation","a mirror symmetry rotation of the left_rotation","print, node.get_right, node.set_right, ret.set_left, node.set_height, ret.set_height, node.get_data, ret.get_left, my_max, my_max, get_height, get_height, get_height, get_height, node.get_right, node.get_left, ret.get_right, ret.get_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","lr_rotation","A              A                    Br        / \            / \                  /  \       B   C    LR    Br  C       RR       B    A      / \       -->  /  \         -->    /     / \     Bl  Br         B   UB              Bl    UB  C          \        /          UB     Bl RR = right_rotation   LR = left_rotation","node.get_left, node.set_left, right_rotation, left_rotation"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","rl_rotation","","node.get_right, node.set_right, left_rotation, right_rotation"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","insert_node","","node.set_height, MyNode, node.get_data, node.set_left, node.set_right, my_max, insert_node, node.get_left, insert_node, node.get_right, get_height, get_height, node.get_left, get_height, get_height, left_child.get_data, right_rotation, lr_rotation, node.get_right, get_height, get_height, right_child.get_data, rl_rotation, left_rotation, node.get_right, node.get_left, node.get_left, node.get_right, node.get_right, node.get_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_right_most","","root.get_data, root.get_right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_left_most","","root.get_data, root.get_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","del_node","","root.get_left, root.get_right, root.get_left, root.get_right, root.set_height, root.get_data, my_max, get_left_most, root.set_data, root.set_right, root.get_data, get_height, get_height, get_height, get_height, left_rotation, rl_rotation, get_height, get_height, del_node, print, root.set_left, root.set_right, right_child.get_right, right_child.get_left, get_height, get_height, get_height, get_height, right_rotation, lr_rotation, root.get_right, root.get_left, del_node, del_node, left_child.get_left, left_child.get_right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","AVLtree","","An AVL tree doctest Examples: >>> t = AVLtree() >>> t.insert(4) insert:4 >>> print(str(t).replace("" \n"",""\n""))  4 ************************************* >>> t.insert(2) insert:2 >>> print(str(t).replace("" \n"",""\n"").replace("" \n"",""\n""))   4  2  * ************************************* >>> t.insert(3) insert:3 right rotation node: 2 left rotation node: 4 >>> print(str(t).replace("" \n"",""\n"").replace("" \n"",""\n""))   3  2  4 ************************************* >>> t.get_height() 2 >>> t.del_node(3) delete:3 >>> print(str(t).replace("" \n"",""\n"").replace("" \n"",""\n""))   4  2  * *************************************",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","_test","","doctest.testmod"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","is_empty","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","push","","self.data.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","pop","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","count","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","print_queue","","print, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_data","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_left","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_right","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_height","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","set_data","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","set_left","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","set_right","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","set_height","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","get_height","","get_height"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","insert","","print, insert_node, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","del_node","","print, del_node, print, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\avl_tree.py","","__str__","","MyQueue, q.push, self.get_height, q.is_empty, q.pop, range, int, q.push, q.push, str, q.push, q.push, math.pow, node.get_data, node.get_left, node.get_right, math.pow"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","BinaryTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","__len__","","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","is_full","","self.left.is_full, self.right.is_full"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","__iter__","","iter"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","__len__","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","small_tree","Return a small binary tree with 3 nodes. >>> binary_tree = BinaryTree.small_tree() >>> len(binary_tree) 3 >>> list(binary_tree) [1, 2, 3]","BinaryTree, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","medium_tree","Return a medium binary tree with 3 nodes. >>> binary_tree = BinaryTree.medium_tree() >>> len(binary_tree) 7 >>> list(binary_tree) [1, 2, 3, 4, 5, 6, 7]","BinaryTree, Node, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","depth","Returns the depth of the tree  >>> BinaryTree(Node(1)).depth() 1 >>> BinaryTree.small_tree().depth() 2 >>> BinaryTree.medium_tree().depth() 4","self._depth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","_depth","","max, self._depth, self._depth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\basic_binary_tree.py","","is_full","Returns True if the tree is full  >>> BinaryTree(Node(1)).is_full() True >>> BinaryTree.small_tree().is_full() True >>> BinaryTree.medium_tree().is_full() False","self.root.is_full"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","BinarySearchTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","inorder","inorder (left, self, right)","inorder, inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","postorder","postOrder (left, right, self)","postorder, postorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__iter__",">>> list(Node(0)) [0] >>> list(Node(0, Node(-1), Node(1), None)) [-1, 0, 1]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__repr__","","pformat, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","is_right","","bool"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__bool__","","bool"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__str__","Return a string of all the Nodes using in order traversal","str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__reassign_nodes","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","empty","Returns True if the tree does not have any element(s). False if the tree has element(s).  >>> BinarySearchTree().empty() True >>> BinarySearchTree().insert(1).empty() False >>> BinarySearchTree().insert(8, 3, 6, 1, 10, 14, 13, 4, 7).empty() False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","__insert","Insert a new node in Binary Search Tree with value label","Node, self.empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","insert","","self.__insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","search",">>> tree = BinarySearchTree().insert(10, 20, 30, 40, 50) >>> tree.search(10) {'10': (None, {'20': (None, {'30': (None, {'40': (None, 50)})})})} >>> tree.search(20) {'20': (None, {'30': (None, {'40': (None, 50)})})} >>> tree.search(30) {'30': (None, {'40': (None, 50)})} >>> tree.search(40) {'40': (None, 50)} >>> tree.search(50) 50 >>> tree.search(5) is None  # element not present True >>> tree.search(0) is None  # element not present True >>> tree.search(-5) is None  # element not present True >>> BinarySearchTree().search(10) Traceback (most recent call last):     ... IndexError: Warning: Tree is empty! please use another.","self.empty, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","get_max","We go deep on the right branch  >>> BinarySearchTree().insert(10, 20, 30, 40, 50).get_max() 50 >>> BinarySearchTree().insert(-5, -1, 0.1, -0.3, -4.5).get_max() {'0.1': (-0.3, None)} >>> BinarySearchTree().insert(1, 78.3, 30, 74.0, 1).get_max() {'78.3': ({'30': (1, 74.0)}, None)} >>> BinarySearchTree().insert(1, 783, 30, 740, 1).get_max() {'783': ({'30': (1, 740)}, None)}","self.empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","get_min","We go deep on the left branch  >>> BinarySearchTree().insert(10, 20, 30, 40, 50).get_min() {'10': (None, {'20': (None, {'30': (None, {'40': (None, 50)})})})} >>> BinarySearchTree().insert(-5, -1, 0, -0.3, -4.5).get_min() {'-5': (None, {'-1': (-4.5, {'0': (-0.3, None)})})} >>> BinarySearchTree().insert(1, 78.3, 30, 74.0, 1).get_min() {'1': (None, {'78.3': ({'30': (1, 74.0)}, None)})} >>> BinarySearchTree().insert(1, 783, 30, 740, 1).get_min() {'1': (None, {'783': ({'30': (1, 740)}, None)})}","self.empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","remove","","self.search, ValueError, self.__reassign_nodes, self.__reassign_nodes, self.__reassign_nodes, self.get_max, self.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","preorder_traverse","","self.preorder_traverse, self.preorder_traverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","traversal_tree","This function traversal the tree. You can pass a function to traversal the tree as needed by client code","self.preorder_traverse, traversal_function"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","inorder","Perform an inorder traversal and append values of the nodes to a list named arr","self.inorder, arr.append, self.inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree.py","","find_kth_smallest","Return the kth smallest element in a binary search tree","self.inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","BinarySearchTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","BinarySearchTreeTest","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","binary_search_tree_example","Example               8              / \             3   10            / \    \           1   6    14              / \   /             4   7 13             \             5  Example After Deletion               4              / \             1   7                  \                   5","BinarySearchTree, t.put, t.put, t.put, t.put, t.put, t.put, t.put, t.put, t.put, t.put, print, print, print, print, print, print, print, print, print, print, print, t.remove, t.remove, t.remove, t.remove, t.remove, t.remove, print, print, print, print, t.exists, t.exists, t.exists, t.exists, t.get_max_label, t.get_min_label, t.get_max_label, t.get_min_label, t.inorder_traversal, t.preorder_traversal, t.inorder_traversal, t.preorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","empty","Empties the tree  >>> t = BinarySearchTree() >>> assert t.root is None >>> t.put(8) >>> assert t.root is not None",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","is_empty","Checks if the tree is empty  >>> t = BinarySearchTree() >>> t.is_empty() True >>> t.put(8) >>> t.is_empty() False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","put","Put a new node in the tree  >>> t = BinarySearchTree() >>> t.put(8) >>> assert t.root.parent is None >>> assert t.root.label == 8  >>> t.put(10) >>> assert t.root.right.parent == t.root >>> assert t.root.right.label == 10  >>> t.put(3) >>> assert t.root.left.parent == t.root >>> assert t.root.left.label == 3","self._put"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_put","","Node, self._put, self._put, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","search","Searches a node in the tree  >>> t = BinarySearchTree() >>> t.put(8) >>> t.put(10) >>> node = t.search(8) >>> assert node.label == 8  >>> node = t.search(3) Traceback (most recent call last):     ... ValueError: Node with label 3 does not exist","self._search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_search","","ValueError, self._search, self._search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","remove","Removes a node in the tree  >>> t = BinarySearchTree() >>> t.put(8) >>> t.put(10) >>> t.remove(8) >>> assert t.root.label == 10  >>> t.remove(3) Traceback (most recent call last):     ... ValueError: Node with label 3 does not exist","self.search, self._get_lowest_node, self._reassign_nodes, self._reassign_nodes, self._reassign_nodes, self._reassign_nodes"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_reassign_nodes","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_get_lowest_node","","self._get_lowest_node, self._reassign_nodes"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","exists","Checks if a node exists in the tree  >>> t = BinarySearchTree() >>> t.put(8) >>> t.put(10) >>> t.exists(8) True  >>> t.exists(3) False","self.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","get_max_label","Gets the max label inserted in the tree  >>> t = BinarySearchTree() >>> t.get_max_label() Traceback (most recent call last):     ... ValueError: Binary search tree is empty  >>> t.put(8) >>> t.put(10) >>> t.get_max_label() 10","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","get_min_label","Gets the min label inserted in the tree  >>> t = BinarySearchTree() >>> t.get_min_label() Traceback (most recent call last):     ... ValueError: Binary search tree is empty  >>> t.put(8) >>> t.put(10) >>> t.get_min_label() 8","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","inorder_traversal","Return the inorder traversal of the tree  >>> t = BinarySearchTree() >>> [i.label for i in t.inorder_traversal()] []  >>> t.put(8) >>> t.put(10) >>> t.put(9) >>> [i.label for i in t.inorder_traversal()] [8, 9, 10]","self._inorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_inorder_traversal","","self._inorder_traversal, self._inorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","preorder_traversal","Return the preorder traversal of the tree  >>> t = BinarySearchTree() >>> [i.label for i in t.preorder_traversal()] []  >>> t.put(8) >>> t.put(10) >>> t.put(9) >>> [i.label for i in t.preorder_traversal()] [8, 10, 9]","self._preorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_preorder_traversal","","self._preorder_traversal, self._preorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","_get_binary_search_tree","8    / \   3   10  / \    \ 1   6    14    / \   /   4   7 13    \     5","BinarySearchTree, t.put, t.put, t.put, t.put, t.put, t.put, t.put, t.put, t.put, t.put"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_put","","BinarySearchTree, t.is_empty, t.put, t.put, t.put, t.put, t.put, pytest.raises, t.put"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_search","","self._get_binary_search_tree, t.search, t.search, pytest.raises, t.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_remove","","self._get_binary_search_tree, t.remove, t.remove, t.remove, t.remove, t.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_remove_2","","self._get_binary_search_tree, t.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_empty","","self._get_binary_search_tree, t.empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_is_empty","","self._get_binary_search_tree, t.empty, t.is_empty, t.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_exists","","self._get_binary_search_tree, t.exists, t.exists"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_get_max_label","","self._get_binary_search_tree, t.empty, t.get_max_label, pytest.raises, t.get_max_label"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_get_min_label","","self._get_binary_search_tree, t.empty, t.get_min_label, pytest.raises, t.get_min_label"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_inorder_traversal","","self._get_binary_search_tree, t.inorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_search_tree_recursive.py","","test_preorder_traversal","","self._get_binary_search_tree, t.preorder_traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_mirror.py","","binary_tree_mirror_dict","","binary_tree_mirror_dict, binary_tree_mirror_dict"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_mirror.py","","binary_tree_mirror",">>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 7: [8,9]}, 1) {1: [3, 2], 2: [5, 4], 3: [7, 6], 7: [9, 8]} >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 1) {1: [3, 2], 2: [5, 4], 3: [7, 6], 4: [11, 10]} >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 5) Traceback (most recent call last):     ... ValueError: root 5 is not present in the binary_tree >>> binary_tree_mirror({}, 5) Traceback (most recent call last):     ... ValueError: binary tree cannot be empty","dict, binary_tree_mirror_dict, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_node_sum.py","Node","","A Node has a value variable and pointers to Nodes to its left and right.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_node_sum.py","BinaryTreeNodeSum","","The below tree looks like this     10    /  \   5   -3  /    / \ 12   8  0  >>> tree = Node(10) >>> sum(BinaryTreeNodeSum(tree)) 10  >>> tree.left = Node(5) >>> sum(BinaryTreeNodeSum(tree)) 15  >>> tree.right = Node(-3) >>> sum(BinaryTreeNodeSum(tree)) 12  >>> tree.left.left = Node(12) >>> sum(BinaryTreeNodeSum(tree)) 24  >>> tree.right.left = Node(8) >>> tree.right.right = Node(0) >>> sum(BinaryTreeNodeSum(tree)) 32",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_node_sum.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_node_sum.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_node_sum.py","","depth_first_search","","self.depth_first_search, self.depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_node_sum.py","","__iter__","","self.depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_path_sum.py","Node","","A Node has value variable and pointers to Nodes to its left and right.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_path_sum.py","BinaryTreePathSum","","The below tree looks like this       10      /  \     5   -3    / \    \   3   2    11  / \   \ 3  -2   1   >>> tree = Node(10) >>> tree.left = Node(5) >>> tree.right = Node(-3) >>> tree.left.left = Node(3) >>> tree.left.right = Node(2) >>> tree.right.right = Node(11) >>> tree.left.left.left = Node(3) >>> tree.left.left.right = Node(-2) >>> tree.left.right.right = Node(1)  >>> BinaryTreePathSum().path_sum(tree, 8) 3 >>> BinaryTreePathSum().path_sum(tree, 7) 2 >>> tree.right.right = Node(10) >>> BinaryTreePathSum().path_sum(tree, 8) 2 >>> BinaryTreePathSum().path_sum(None, 0) 0 >>> BinaryTreePathSum().path_sum(tree, 0) 0  The second tree looks like this       0      / \     5   5  >>> tree2 = Node(0) >>> tree2.left = Node(5) >>> tree2.right = Node(5)  >>> BinaryTreePathSum().path_sum(tree2, 5) 4 >>> BinaryTreePathSum().path_sum(tree2, -1) 0 >>> BinaryTreePathSum().path_sum(tree2, 0) 1",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_path_sum.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_path_sum.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_path_sum.py","","depth_first_search","","self.depth_first_search, self.depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_path_sum.py","","path_sum","","self.depth_first_search, self.path_sum, self.path_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","make_tree","The below tree     1    / \   2   3  / \ 4   5","Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","preorder","Pre-order traversal visits root node, left subtree, right subtree. >>> list(preorder(make_tree())) [1, 2, 4, 5, 3]","preorder, preorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","postorder","Post-order traversal visits left subtree, right subtree, root node. >>> list(postorder(make_tree())) [4, 5, 2, 3, 1]","postorder, postorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","inorder","In-order traversal visits left subtree, root node, right subtree. >>> list(inorder(make_tree())) [4, 2, 5, 1, 3]","inorder, inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","reverse_inorder","Reverse in-order traversal visits right subtree, root node, left subtree. >>> list(reverse_inorder(make_tree())) [3, 1, 5, 2, 4]","reverse_inorder, reverse_inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","height","Recursive function for calculating the height of the binary tree. >>> height(None) 0 >>> height(make_tree()) 3","max, height, height"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","level_order","Returns a list of nodes value from a whole binary tree in Level Order Traverse. Level Order traverse: Visit nodes of the tree level-by-level. >>> list(level_order(make_tree())) [1, 2, 3, 4, 5]","deque, process_queue.popleft, process_queue.append, process_queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","get_nodes_from_left_to_right","Returns a list of nodes value from a particular level: Left to right direction of the binary tree. >>> list(get_nodes_from_left_to_right(make_tree(), 1)) [1] >>> list(get_nodes_from_left_to_right(make_tree(), 2)) [2, 3]","populate_output, populate_output, populate_output"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","get_nodes_from_right_to_left","Returns a list of nodes value from a particular level: Right to left direction of the binary tree. >>> list(get_nodes_from_right_to_left(make_tree(), 1)) [1] >>> list(get_nodes_from_right_to_left(make_tree(), 2)) [3, 2]","populate_output, populate_output, populate_output"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","zigzag","ZigZag traverse: Returns a list of nodes value from left to right and right to left, alternatively. >>> list(zigzag(make_tree())) [1, 3, 2, 4, 5]","height, range, get_nodes_from_left_to_right, get_nodes_from_right_to_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","main","","make_tree, print, print, print, print, print, print, print, print, range, print, print, print, height, list, list, list, list, list, height, list, get_nodes_from_left_to_right, list, inorder, reverse_inorder, preorder, postorder, level_order, zigzag"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","populate_output","","populate_output, populate_output"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\binary_tree_traversals.py","","populate_output","","populate_output, populate_output"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diameter_of_binary_tree.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diameter_of_binary_tree.py","","depth",">>> root = Node(1) >>> root.depth() 1 >>> root.left = Node(2) >>> root.depth() 2 >>> root.left.depth() 1 >>> root.right = Node(3) >>> root.depth() 2","self.left.depth, self.right.depth, max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diameter_of_binary_tree.py","","diameter",">>> root = Node(1) >>> root.diameter() 1 >>> root.left = Node(2) >>> root.diameter() 2 >>> root.left.diameter() 1 >>> root.right = Node(3) >>> root.diameter() 3","self.left.depth, self.right.depth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","TreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","make_tree",">>> make_tree().val 3","TreeNode, TreeNode, TreeNode, TreeNode, TreeNode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","binary_tree_right_side_view","Function returns the right side view of binary tree.     3       <-  3  / \ 9   20    <-  20    /  \   15   7  <-  7  >>> binary_tree_right_side_view(make_tree()) [3, 20, 7] >>> binary_tree_right_side_view(None) []","depth_first_search, depth_first_search, depth_first_search, len, right_view.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","binary_tree_left_side_view","Function returns the left side view of binary tree.  3  ->    3         / \ 9  ->  9   20           /  \ 15 ->    15   7  >>> binary_tree_left_side_view(make_tree()) [3, 9, 15] >>> binary_tree_left_side_view(None) []","depth_first_search, depth_first_search, depth_first_search, len, left_view.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","binary_tree_top_side_view","Function returns the top side view of binary tree.  9 3 20 7         3  / \ 9   20    /  \   15   7  >>> binary_tree_top_side_view(make_tree()) [9, 3, 20, 7] >>> binary_tree_top_side_view(None) []","breadth_first_search, defaultdict, sorted, queue.pop, .append, lookup.items, top_view.append, queue.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","binary_tree_bottom_side_view","Function returns the bottom side view of binary tree    3  / \ 9   20    /  \   15   7       9 15 20 7  >>> binary_tree_bottom_side_view(make_tree()) [9, 15, 20, 7] >>> binary_tree_bottom_side_view(None) []","breadth_first_search, defaultdict, sorted, queue.pop, .append, lookup.items, bottom_view.append, queue.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","depth_first_search","A depth first search preorder traversal to append the values at right side of tree.","depth_first_search, depth_first_search, len, right_view.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","depth_first_search","A depth first search preorder traversal to append the values at left side of tree.","depth_first_search, depth_first_search, len, left_view.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","breadth_first_search","A breadth first search traversal with defaultdict ds to append the values of tree from top view","defaultdict, sorted, queue.pop, .append, lookup.items, top_view.append, queue.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\diff_views_of_binary_tree.py","","breadth_first_search","A breadth first search traversal with defaultdict ds to append the values of tree from bottom view","defaultdict, sorted, queue.pop, .append, lookup.items, bottom_view.append, queue.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\distribute_coins.py","TreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\distribute_coins.py","CoinsDistribResult","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\distribute_coins.py","","distribute_coins",">>> distribute_coins(TreeNode(3, TreeNode(0), TreeNode(0))) 2 >>> distribute_coins(TreeNode(0, TreeNode(3), TreeNode(0))) 3 >>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(3))) 3 >>> distribute_coins(None) 0 >>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(0))) Traceback (most recent call last):  ... ValueError: The nodes number should be same as the number of coins >>> distribute_coins(TreeNode(0, TreeNode(1), TreeNode(1))) Traceback (most recent call last):  ... ValueError: The nodes number should be same as the number of coins","count_nodes, count_coins, ValueError, get_distrib, get_distrib, CoinsDistribResult, get_distrib, CoinsDistribResult, abs, count_nodes, count_nodes, count_coins, count_coins, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\distribute_coins.py","","count_nodes",">>> count_nodes(None) 0","count_nodes, count_nodes"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\distribute_coins.py","","count_coins",">>> count_coins(None) 0","count_coins, count_coins"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\distribute_coins.py","","get_distrib",">>> get_distrib(None) namedtuple(""CoinsDistribResult"", ""0 2"")","get_distrib, get_distrib, CoinsDistribResult, CoinsDistribResult, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","FenwickTree","","Fenwick Tree  More info: https://en.wikipedia.org/wiki/Fenwick_tree",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","__init__","Constructor for the Fenwick tree  Parameters:     arr (list): list of elements to initialize the tree with (optional)     size (int): size of the Fenwick tree (if arr is None)","self.init, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","init","Initialize the Fenwick tree with arr in O(N)  Parameters:     arr (list): list of elements to initialize the tree with  Returns:     None  >>> a = [1, 2, 3, 4, 5] >>> f1 = FenwickTree(a) >>> f2 = FenwickTree(size=len(a)) >>> for index, value in enumerate(a): ...     f2.add(index, value) >>> f1.tree == f2.tree True","len, deepcopy, range, self.next_"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","get_array","Get the Normal Array of the Fenwick tree in O(N)  Returns:     list: Normal Array of the Fenwick tree  >>> a = [i for i in range(128)] >>> f = FenwickTree(a) >>> f.get_array() == a True","range, self.next_"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","next_","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","prev","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","add","Add a value to index in O(lg N)  Parameters:     index (int): index to add value to     value (int): value to add to index  Returns:     None  >>> f = FenwickTree([1, 2, 3, 4, 5]) >>> f.add(0, 1) >>> f.add(1, 2) >>> f.add(2, 3) >>> f.add(3, 4) >>> f.add(4, 5) >>> f.get_array() [2, 4, 6, 8, 10]","self.next_"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","update","Set the value of index in O(lg N)  Parameters:     index (int): index to set value to     value (int): value to set in index  Returns:     None  >>> f = FenwickTree([5, 4, 3, 2, 1]) >>> f.update(0, 1) >>> f.update(1, 2) >>> f.update(2, 3) >>> f.update(3, 4) >>> f.update(4, 5) >>> f.get_array() [1, 2, 3, 4, 5]","self.add, self.get"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","prefix","Prefix sum of all elements in [0, right) in O(lg N)  Parameters:     right (int): right bound of the query (exclusive)  Returns:     int: sum of all elements in [0, right)  >>> a = [i for i in range(128)] >>> f = FenwickTree(a) >>> res = True >>> for i in range(len(a)): ...     res = res and f.prefix(i) == sum(a[:i]) >>> res True","self.prev"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","query","Query the sum of all elements in [left, right) in O(lg N)  Parameters:     left (int): left bound of the query (inclusive)     right (int): right bound of the query (exclusive)  Returns:     int: sum of all elements in [left, right)  >>> a = [i for i in range(128)] >>> f = FenwickTree(a) >>> res = True >>> for i in range(len(a)): ...     for j in range(i + 1, len(a)): ...         res = res and f.query(i, j) == sum(a[i:j]) >>> res True","self.prefix, self.prefix"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","get","Get value at index in O(lg N)  Parameters:     index (int): index to get the value  Returns:     int: Value of element at index  >>> a = [i for i in range(128)] >>> f = FenwickTree(a) >>> res = True >>> for i in range(len(a)): ...     res = res and f.get(i) == a[i] >>> res True","self.query"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\fenwick_tree.py","","rank_query","Find the largest index with prefix(i) <= value in O(lg N) NOTE: Requires that all values are non-negative!  Parameters:     value (int): value to find the largest index of  Returns:     -1: if value is smaller than all elements in prefix sum     int: largest index with prefix(i) <= value  >>> f = FenwickTree([1, 2, 0, 3, 0, 5]) >>> f.rank_query(0) -1 >>> f.rank_query(2) 0 >>> f.rank_query(1) 0 >>> f.rank_query(3) 2 >>> f.rank_query(5) 2 >>> f.rank_query(6) 4 >>> f.rank_query(11) 5",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py","TreeNode","","A TreeNode has data variable and pointers to TreeNode objects for its left and right children.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py","","build_tree","Build and return a sample binary tree.  Returns:     TreeNode: The root of the binary tree.  Examples:     >>> root = build_tree()     >>> root.data     1     >>> root.left.data     2     >>> root.right.data     5     >>> root.left.left.data     3     >>> root.left.right.data     4     >>> root.right.right.data     6","TreeNode, TreeNode, TreeNode, TreeNode, TreeNode, TreeNode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py","","flatten","Flatten a binary tree into a linked list in-place, where the linked list is represented using the right pointers of the tree nodes.  Args:     root (TreeNode): The root of the binary tree to be flattened.  Examples:     >>> root = TreeNode(1)     >>> root.left = TreeNode(2)     >>> root.right = TreeNode(5)     >>> root.left.left = TreeNode(3)     >>> root.left.right = TreeNode(4)     >>> root.right.right = TreeNode(6)     >>> flatten(root)     >>> root.data     1     >>> root.right.right is None     False     >>> root.right.right = TreeNode(3)     >>> root.right.right.right is None     True","flatten, flatten"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py","","display_linked_list","Display the flattened linked list.  Args:     root (TreeNode | None): The root of the flattened linked list.  Examples:     >>> root = TreeNode(1)     >>> root.right = TreeNode(2)     >>> root.right.right = TreeNode(3)     >>> display_linked_list(root)     1 2 3     >>> root = None     >>> display_linked_list(root)","print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\flatten_binarytree_to_linkedlist.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\floor_and_ceiling.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\floor_and_ceiling.py","","floor_ceiling","Find the floor and ceiling values for a given key in a Binary Search Tree (BST).  Args:     root: The root of the binary search tree.     key: The key for which to find the floor and ceiling.  Returns:     A tuple containing the floor and ceiling values, respectively.  Examples:     >>> root = Node(10)     >>> root.left = Node(5)     >>> root.right = Node(20)     >>> root.left.left = Node(3)     >>> root.left.right = Node(7)     >>> root.right.left = Node(15)     >>> root.right.right = Node(25)     >>> tuple(root)     (3, 5, 7, 10, 15, 20, 25)     >>> floor_ceiling(root, 8)     (7, 10)     >>> floor_ceiling(root, 14)     (10, 15)     >>> floor_ceiling(root, -1)     (None, 3)     >>> floor_ceiling(root, 30)     (25, None)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\floor_and_ceiling.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\floor_and_ceiling.py","","__len__","","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\inorder_tree_traversal_2022.py","BinaryTreeNode","","Defining the structure of BinaryTreeNode",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\inorder_tree_traversal_2022.py","","insert","If the binary search tree is empty, make a new node and declare it as root. >>> node_a = BinaryTreeNode(12345) >>> node_b = insert(node_a, 67890) >>> node_a.left_child == node_b.left_child True >>> node_a.right_child == node_b.right_child True >>> node_a.data == node_b.data True","BinaryTreeNode, insert, insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\inorder_tree_traversal_2022.py","","inorder",">>> inorder(make_tree()) [6, 10, 14, 15, 20, 25, 60]","inorder, inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\inorder_tree_traversal_2022.py","","make_tree","","insert, insert, insert, insert, insert, insert, insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\inorder_tree_traversal_2022.py","","main","","make_tree, print, inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\inorder_tree_traversal_2022.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sorted.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sorted.py","","__iter__",">>> root = Node(data=2.1) >>> list(root) [2.1] >>> root.left=Node(data=2.0) >>> list(root) [2.0, 2.1] >>> root.right=Node(data=2.2) >>> list(root) [2.0, 2.1, 2.2]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sorted.py","","is_sorted",">>> Node(data='abc').is_sorted True >>> Node(data=2, ...      left=Node(data=1.999), ...      right=Node(data=3)).is_sorted True >>> Node(data=0, ...      left=Node(data=0), ...      right=Node(data=0)).is_sorted True >>> Node(data=0, ...      left=Node(data=-11), ...      right=Node(data=3)).is_sorted True >>> Node(data=5, ...      left=Node(data=1), ...      right=Node(data=4, left=Node(data=3))).is_sorted False >>> Node(data='a', ...      left=Node(data=1), ...      right=Node(data=4, left=Node(data=3))).is_sorted Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int' >>> Node(data=2, ...      left=Node([]), ...      right=Node(data=4, left=Node(data=3))).is_sorted Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'int' and 'list'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","BinaryTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","__iter__",">>> root = Node(2) >>> list(root) [2] >>> root.left = Node(1) >>> tuple(root) (1, 2)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","__len__",">>> root = Node(2) >>> len(root) 1 >>> root.left = Node(1) >>> len(root) 2","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","is_sum_node",">>> root = Node(3) >>> root.is_sum_node True >>> root.left = Node(1) >>> root.is_sum_node False >>> root.right = Node(2) >>> root.is_sum_node True","all, sum, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","__iter__",">>> list(BinaryTree.build_a_tree()) [1, 2, 7, 11, 15, 29, 35, 40]","iter"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","__len__",">>> len(BinaryTree.build_a_tree()) 8","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","__str__","Returns a string representation of the inorder traversal of the binary tree.  >>> str(list(BinaryTree.build_a_tree())) '[1, 2, 7, 11, 15, 29, 35, 40]'","str, list"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","is_sum_tree",">>> BinaryTree.build_a_tree().is_sum_tree False >>> BinaryTree.build_a_sum_tree().is_sum_tree True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","build_a_tree","Create a binary tree with the specified structure:       11    /     \   2       29  / \     /  \ 1   7  15    40                \                 35 >>> list(BinaryTree.build_a_tree()) [1, 2, 7, 11, 15, 29, 35, 40]","BinaryTree, Node, Node, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\is_sum_tree.py","","build_a_sum_tree","Create a binary tree with the specified structure:      26     /  \   10    3  /  \    \ 4    6    3 >>> list(BinaryTree.build_a_sum_tree()) [4, 10, 6, 26, 3, 3]","BinaryTree, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","SegmentTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","__init__","","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","left",">>> segment_tree = SegmentTree(15) >>> segment_tree.left(1) 2 >>> segment_tree.left(2) 4 >>> segment_tree.left(12) 24",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","right",">>> segment_tree = SegmentTree(15) >>> segment_tree.right(1) 3 >>> segment_tree.right(2) 5 >>> segment_tree.right(12) 25",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","build","","self.build, self.build, max, self.left, self.right, self.left, self.right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","update","update with O(lg n) (Normal segment tree without lazy update will take O(nlg n) for each update)  update(1, 1, size, a, b, v) for update val v to [a,b]","self.update, self.update, max, self.left, self.right, self.left, self.right, self.left, self.right, self.left, self.right, self.left, self.right, self.left, self.right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","query","query(1, 1, size, a, b) for query max of [a,b] >>> A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8] >>> segment_tree = SegmentTree(15) >>> segment_tree.build(1, 1, 15, A) >>> segment_tree.query(1, 1, 15, 4, 6) 7 >>> segment_tree.query(1, 1, 15, 7, 11) 14 >>> segment_tree.query(1, 1, 15, 7, 12) 15","self.query, self.query, max, self.left, self.right, self.left, self.right, self.left, self.right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lazy_segment_tree.py","","__str__","","str, self.query, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lowest_common_ancestor.py","","swap","Return a tuple (b, a) when given two integers a and b >>> swap(2,3) (3, 2) >>> swap(3,4) (4, 3) >>> swap(67, 12) (12, 67) >>> swap(3,-4) (-4, 3)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lowest_common_ancestor.py","","create_sparse","creating sparse table which saves each nodes 2^i-th parent >>> max_node = 6 >>> parent = [[0, 0, 1, 1, 2, 2, 3]] + [[0] * 7 for _ in range(19)] >>> parent = create_sparse(max_node=max_node, parent=parent) >>> parent[0] [0, 0, 1, 1, 2, 2, 3] >>> parent[1] [0, 0, 0, 0, 1, 1, 1] >>> parent[2] [0, 0, 0, 0, 0, 0, 0]  >>> max_node = 1 >>> parent = [[0, 0]] + [[0] * 2 for _ in range(19)] >>> parent = create_sparse(max_node=max_node, parent=parent) >>> parent[0] [0, 0] >>> parent[1] [0, 0]","range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lowest_common_ancestor.py","","lowest_common_ancestor","Return the lowest common ancestor between u and v  >>> level = [-1, 0, 1, 1, 2, 2, 2] >>> parent = [[0, 0, 1, 1, 2, 2, 3],[0, 0, 0, 0, 1, 1, 1]] +                     [[0] * 7 for _ in range(17)] >>> lowest_common_ancestor(u=4, v=5, level=level, parent=parent) 2 >>> lowest_common_ancestor(u=4, v=6, level=level, parent=parent) 1 >>> lowest_common_ancestor(u=2, v=3, level=level, parent=parent) 1 >>> lowest_common_ancestor(u=6, v=6, level=level, parent=parent) 6","range, range, swap"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lowest_common_ancestor.py","","breadth_first_search","sets every nodes direct parent parent of root node is set to 0 calculates depth of each node from root node >>> level = [-1] * 7 >>> parent = [[0] * 7 for _ in range(20)] >>> graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []} >>> level, parent = breadth_first_search( ...     level=level, parent=parent, max_node=6, graph=graph, root=1) >>> level [-1, 0, 1, 1, 2, 2, 2] >>> parent[0] [0, 0, 1, 1, 2, 2, 3]   >>> level = [-1] * 2 >>> parent = [[0] * 2 for _ in range(20)] >>> graph = {1: []} >>> level, parent = breadth_first_search( ...     level=level, parent=parent, max_node=1, graph=graph, root=1) >>> level [-1, 0] >>> parent[0] [0, 0]","Queue, q.put, q.qsize, q.get, q.put"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\lowest_common_ancestor.py","","main","","breadth_first_search, create_sparse, print, print, print, print, print, print, lowest_common_ancestor, lowest_common_ancestor, lowest_common_ancestor, lowest_common_ancestor, lowest_common_ancestor, lowest_common_ancestor, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_fenwick_tree.py","MaxFenwickTree","","Maximum Fenwick Tree  More info: https://cp-algorithms.com/data_structures/fenwick.html --------- >>> ft = MaxFenwickTree(5) >>> ft.query(0, 5) 0 >>> ft.update(4, 100) >>> ft.query(0, 5) 100 >>> ft.update(4, 0) >>> ft.update(2, 20) >>> ft.query(0, 5) 20 >>> ft.update(4, 10) >>> ft.query(2, 5) 20 >>> ft.query(1, 5) 20 >>> ft.update(2, 0) >>> ft.query(0, 5) 10 >>> ft = MaxFenwickTree(10000) >>> ft.update(255, 30) >>> ft.query(0, 10000) 30 >>> ft = MaxFenwickTree(6) >>> ft.update(5, 1) >>> ft.query(5, 6) 1 >>> ft = MaxFenwickTree(6) >>> ft.update(0, 1000) >>> ft.query(0, 1) 1000",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_fenwick_tree.py","","__init__","Create empty Maximum Fenwick Tree with specified size  Parameters:     size: size of Array  Returns:     None",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_fenwick_tree.py","","get_next","Get next index in O(1)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_fenwick_tree.py","","get_prev","Get previous index in O(1)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_fenwick_tree.py","","update","Set index to value in O(lg^2 N)  Parameters:     index: index to update     value: value to set  Returns:     None","self.get_next, self.get_prev, max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_fenwick_tree.py","","query","Answer the query of maximum range [l, r) in O(lg^2 N)  Parameters:     left: left index of query range (inclusive)     right: right index of query range (exclusive)  Returns:     Maximum value of range [left, right)","self.get_prev, max, max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_sum_bst.py","TreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_sum_bst.py","","max_sum_bst","The solution traverses a binary tree to find the maximum sum of keys in any subtree that is a Binary Search Tree (BST). It uses recursion to validate BST properties and calculates sums, returning the highest sum found among all valid BST subtrees.  >>> t1 = TreeNode(4) >>> t1.left = TreeNode(3) >>> t1.left.left = TreeNode(1) >>> t1.left.right = TreeNode(2) >>> print(max_sum_bst(t1)) 2 >>> t2 = TreeNode(-4) >>> t2.left = TreeNode(-2) >>> t2.right = TreeNode(-5) >>> print(max_sum_bst(t2)) 0 >>> t3 = TreeNode(1) >>> t3.left = TreeNode(4) >>> t3.left.left = TreeNode(2) >>> t3.left.right = TreeNode(4) >>> t3.right = TreeNode(3) >>> t3.right.left = TreeNode(2) >>> t3.right.right = TreeNode(5) >>> t3.right.right.left = TreeNode(4) >>> t3.right.right.right = TreeNode(6) >>> print(max_sum_bst(t3)) 20","solver, solver, solver, max, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\maximum_sum_bst.py","","solver","Returns the maximum sum by making recursive calls >>> t1 = TreeNode(1) >>> print(solver(t1)) 1","solver, solver, max, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\merge_two_binary_trees.py","Node","","A binary node has value variable and pointers to its left and right node.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\merge_two_binary_trees.py","","merge_two_binary_trees","Returns root node of the merged tree.  >>> tree1 = Node(5) >>> tree1.left = Node(6) >>> tree1.right = Node(7) >>> tree1.left.left = Node(2) >>> tree2 = Node(4) >>> tree2.left = Node(5) >>> tree2.right = Node(8) >>> tree2.left.right = Node(1) >>> tree2.right.right = Node(4) >>> merged_tree = merge_two_binary_trees(tree1, tree2) >>> print_preorder(merged_tree) 9 11 2 1 15 4","merge_two_binary_trees, merge_two_binary_trees"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\merge_two_binary_trees.py","","print_preorder","Print pre-order traversal of the tree.  >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> print_preorder(root) 1 2 3 >>> print_preorder(root.right) 3","print, print_preorder, print_preorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\merge_two_binary_trees.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","Node","","A Node has value variable and pointers to Nodes to its left and right.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","","make_tree_seven","Return a binary tree with 7 nodes that looks like this: ::         1      /   \     2     3    / \   / \   4   5 6   7  >>> tree_seven = make_tree_seven() >>> len(tree_seven) 7 >>> list(tree_seven) [4, 2, 5, 1, 6, 3, 7]","Node, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","","make_tree_nine","Return a binary tree with 9 nodes that looks like this: ::          1        / \       2   3      / \   \     4   5   6    / \   \   7   8   9  >>> tree_nine = make_tree_nine() >>> len(tree_nine) 9 >>> list(tree_nine) [7, 4, 8, 2, 5, 9, 1, 3, 6]","Node, Node, Node, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","","main","Mirror binary trees with the given root and returns the root  >>> tree = make_tree_nine() >>> tuple(tree) (7, 4, 8, 2, 5, 9, 1, 3, 6) >>> tuple(tree.mirror()) (6, 3, 1, 9, 5, 2, 8, 4, 7)  nine_tree::          1        / \       2   3      / \   \     4   5   6    / \   \   7   8   9  The mirrored tree looks like this::        1      / \     3   2    /   / \   6   5   4      /   / \     9   8   7","trees.items, Node, make_tree_seven, make_tree_nine, print, print, tuple, tuple, tree.mirror"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","","__len__","","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\mirror_binary_tree.py","","mirror","Mirror the binary tree rooted at this node by swapping left and right children.  >>> tree = Node(0) >>> list(tree) [0] >>> list(tree.mirror()) [0] >>> tree = Node(1, Node(0), Node(3, Node(2), Node(4, None, Node(5)))) >>> tuple(tree) (0, 1, 2, 3, 4, 5) >>> tuple(tree.mirror()) (5, 4, 3, 2, 1, 0)","self.left.mirror, self.right.mirror"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\non_recursive_segment_tree.py","SegmentTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\non_recursive_segment_tree.py","","__init__","Segment Tree constructor, it works just with commutative combiner. :param arr: list of elements for the segment tree :param fnc: commutative function for combine two elements  >>> SegmentTree(['a', 'b', 'c'], lambda a, b: f'{a}{b}').query(0, 2) 'abc' >>> SegmentTree([(1, 2), (2, 3), (3, 4)], ...             lambda a, b: (a[0] + b[0], a[1] + b[1])).query(0, 2) (6, 9)","len, self.build, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\non_recursive_segment_tree.py","","build","","range, self.fn"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\non_recursive_segment_tree.py","","update","Update an element in log(N) time :param p: position to be update :param v: new value  >>> st = SegmentTree([3, 1, 2, 4], min) >>> st.query(0, 3) 1 >>> st.update(2, -1) >>> st.query(0, 3) -1","self.fn"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\non_recursive_segment_tree.py","","query","Get range query value in log(N) time :param left: left element index :param right: right element index :return: element combined in the range [left, right]  >>> st = SegmentTree([1, 2, 3, 4], lambda a, b: a + b) >>> st.query(0, 2) 6 >>> st.query(1, 2) 5 >>> st.query(0, 3) 10 >>> st.query(2, 3) 7","self.fn, self.fn"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\non_recursive_segment_tree.py","","test_all_segments","Test all possible segments","range, len, range, len, reduce, reduce, reduce, min_segment_tree.query, max_segment_tree.query, sum_segment_tree.query"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\number_of_possible_binary_trees.py","","binomial_coefficient","Since Here we Find the Binomial Coefficient: https://en.wikipedia.org/wiki/Binomial_coefficient C(n,k) = n! / k!(n-k)! :param n: 2 times of Number of nodes :param k: Number of nodes :return:  Integer Value  >>> binomial_coefficient(4, 2) 6","min, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\number_of_possible_binary_trees.py","","catalan_number","We can find Catalan number many ways but here we use Binomial Coefficient because it does the job in O(n)  return the Catalan number of n using 2nCn/(n+1). :param n: number of nodes :return: Catalan number of n nodes  >>> catalan_number(5) 42 >>> catalan_number(6) 132","binomial_coefficient"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\number_of_possible_binary_trees.py","","factorial","Return the factorial of a number. :param n: Number to find the Factorial of. :return: Factorial of n.  >>> import math >>> all(factorial(i) == math.factorial(i) for i in range(10)) True >>> factorial(-5)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... ValueError: factorial() not defined for negative values","range, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\number_of_possible_binary_trees.py","","binary_tree_count","Return the number of possible of binary trees. :param n: number of nodes :return: Number of possible binary trees  >>> binary_tree_count(5) 5040 >>> binary_tree_count(6) 95040","catalan_number, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","RedBlackTree","","A Red-Black tree, which is a self-balancing BST (binary search tree). This tree has similar performance to AVL trees, but the balancing is less strict, so it will perform faster for writing/deleting nodes and slower for reading in the average case, though, because they're both balanced binary search trees, both will get the same asymptotic performance. To read more about them, https://en.wikipedia.org/wiki/Red-black_tree Unless otherwise specified, all asymptotic runtimes are specified in terms of the size of the tree.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","color","Returns the color of a node, allowing for None leaves.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_rotations","Test that the rotate_left and rotate_right functions work.","RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, tree.rotate_left, tree.rotate_right, tree.rotate_right, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_insertion_speed","Test that the tree balances inserts to O(log(n)) by doing a lot of them.","RedBlackTree, range, tree.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_insert","Test the insert() method of the tree correctly balances, colors, and inserts.","RedBlackTree, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree, RedBlackTree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_insert_and_search","Tests searching through the tree for values.","RedBlackTree, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, any, all"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_insert_delete","Test the insert() and delete() method of the tree, verifying the insertion and removal of elements, and the balancing of the tree.","RedBlackTree, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.remove, tree.remove, tree.remove, tree.check_color_properties, list, tree.inorder_traverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_floor_ceil","Tests the floor and ceiling functions in the tree.","RedBlackTree, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.floor, tree.ceil"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_min_max","Tests the min and max functions in the tree.","RedBlackTree, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.get_max, tree.get_min"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_tree_traversal","Tests the three different tree traversal functions.","RedBlackTree, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, tree.insert, list, list, list, tree.inorder_traverse, tree.preorder_traverse, tree.postorder_traverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","test_tree_chaining","Tests the three different tree chaining functions.","RedBlackTree, .insert, list, list, list, .insert, tree.inorder_traverse, tree.preorder_traverse, tree.postorder_traverse, .insert, .insert, .insert, tree.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","print_results","","print, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","pytests","","test_rotations, test_insert, test_insert_and_search, test_insert_delete, test_floor_ceil, test_tree_traversal, test_tree_chaining"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","main",">>> pytests()","print_results, print_results, print_results, print_results, print_results, print_results, print_results, print, print, test_insertion_speed, print, test_rotations, test_insert, test_insert_and_search, test_insert_delete, test_floor_ceil, test_tree_traversal, test_tree_chaining"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","__init__","Initialize a new Red-Black Tree node with the given values: label: The value associated with this node color: 0 if black, 1 if red parent: The parent to this node left: This node's left child right: This node's right child",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","rotate_left","Rotate the subtree rooted at this node to the left and returns the new root to this subtree. Performing one rotation can be done in O(1).",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","rotate_right","Rotate the subtree rooted at this node to the right and returns the new root to this subtree. Performing one rotation can be done in O(1).",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","insert","Inserts label into the subtree rooted at self, performs any rotations necessary to maintain balance, and then returns the new root to this subtree (likely self). This is guaranteed to run in O(log(n)) time.","self.left.insert, RedBlackTree, self.left._insert_repair, self.right.insert, RedBlackTree, self.right._insert_repair"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","_insert_repair","Repair the coloring from inserting into a tree.","color, color, self.is_left, self.parent.is_right, self.parent.rotate_right, self.grandparent._insert_repair, self.right._insert_repair, self.is_right, self.parent.is_left, self.parent.rotate_left, self.is_left, self.left._insert_repair, self.grandparent.rotate_right, self.grandparent.rotate_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","remove","Remove label from this tree.","self.left.get_max, self.left.remove, self.left.remove, self.right.remove, self.is_left, RedBlackTree, self._remove_repair, self.is_left"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","_remove_repair","Repair the coloring of the tree that may have been messed up.","color, self.is_left, self.parent._remove_repair, self.is_left, self.sibling.rotate_right, self.is_right, self.sibling.rotate_left, self.is_left, self.parent.rotate_left, self.is_right, self.parent.rotate_right, self.parent.rotate_left, self.parent.rotate_right, color, color, color, color, color, color, color, color, color, color, color, color, color, color, color, color, color, color"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","check_color_properties","Check the coloring of the tree, and return True iff the tree is colored in a way which matches these five properties: (wording stolen from wikipedia article)  1. Each node is either red or black.  2. The root node is black.  3. All leaves are black.  4. If a node is red, then both its children are black.  5. Every path from any node to all of its descendent NIL nodes     has the same number of black nodes. This function runs in O(n) time, because properties 4 and 5 take that long to check.","print, self.check_coloring, print, self.black_height, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","check_coloring","A helper function to recursively check Property 4 of a Red-Black Tree. See check_color_properties for more info.","self.left.check_coloring, color, color, self.right.check_coloring"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","black_height","Returns the number of black nodes from this node to the leaves of the tree, or None if there isn't one such value (the tree is color incorrectly).","RedBlackTree.black_height, RedBlackTree.black_height"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","__contains__","Search through the tree for label, returning True iff it is found somewhere in the tree. Guaranteed to run in O(log(n)) time.","self.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","search","Search through the tree for label, returning its node if it's found, and None otherwise. This method is guaranteed to run in O(log(n)) time.","self.right.search, self.left.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","floor","Returns the largest element in this tree which is at most label. This method is guaranteed to run in O(log(n)) time.","self.left.floor, self.right.floor"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","ceil","Returns the smallest element in this tree which is at least label. This method is guaranteed to run in O(log(n)) time.","self.right.ceil, self.left.ceil"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","get_max","Returns the largest element in this tree. This method is guaranteed to run in O(log(n)) time.","self.right.get_max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","get_min","Returns the smallest element in this tree. This method is guaranteed to run in O(log(n)) time.","self.left.get_min"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","grandparent","Get the current node's grandparent, or None if it doesn't exist.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","sibling","Get the current node's sibling, or None if it doesn't exist.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","is_left","Returns true iff this node is the left child of its parent.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","is_right","Returns true iff this node is the right child of its parent.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","__bool__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","__len__","Return the number of nodes in this tree.","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","preorder_traverse","","self.left.preorder_traverse, self.right.preorder_traverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","inorder_traverse","","self.left.inorder_traverse, self.right.inorder_traverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","postorder_traverse","","self.left.postorder_traverse, self.right.postorder_traverse"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","__repr__","","pformat"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\red_black_tree.py","","__eq__","Test if two trees are equal.","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","SegmentTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","__init__","","len, self.build"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","left","Returns the left child index for a given index in a binary tree.  >>> s = SegmentTree([1, 2, 3]) >>> s.left(1) 2 >>> s.left(2) 4",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","right","Returns the right child index for a given index in a binary tree.  >>> s = SegmentTree([1, 2, 3]) >>> s.right(1) 3 >>> s.right(2) 5",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","build","","self.build, self.build, max, self.left, self.right, self.left, self.right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","update","Update the values in the segment tree in the range [a,b] with the given value.  >>> s = SegmentTree([1, 2, 3, 4, 5]) >>> s.update(2, 4, 10) True >>> s.query(1, 5) 10","self.update_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","update_recursive","update(1, 1, N, a, b, v) for update val v to [a,b]","self.update_recursive, self.update_recursive, max, self.left, self.right, self.left, self.right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","query","Query the maximum value in the range [a,b].  >>> s = SegmentTree([1, 2, 3, 4, 5]) >>> s.query(1, 3) 3 >>> s.query(1, 5) 5","self.query_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","query_recursive","query(1, 1, N, a, b) for query max of [a,b]","self.query_recursive, self.query_recursive, max, self.left, self.right"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree.py","","show_data","","range, print, self.query"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","SegmentTreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","SegmentTree","",">>> import operator >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add) >>> tuple(num_arr.traverse())  # doctest: +NORMALIZE_WHITESPACE (SegmentTreeNode(start=0, end=4, val=15),     SegmentTreeNode(start=0, end=2, val=8),     SegmentTreeNode(start=3, end=4, val=7),     SegmentTreeNode(start=0, end=1, val=3),     SegmentTreeNode(start=2, end=2, val=5),     SegmentTreeNode(start=3, end=3, val=3),     SegmentTreeNode(start=4, end=4, val=4),     SegmentTreeNode(start=0, end=0, val=2),     SegmentTreeNode(start=1, end=1, val=1)) >>> >>> num_arr.update(1, 5) >>> tuple(num_arr.traverse())  # doctest: +NORMALIZE_WHITESPACE (SegmentTreeNode(start=0, end=4, val=19),     SegmentTreeNode(start=0, end=2, val=12),     SegmentTreeNode(start=3, end=4, val=7),     SegmentTreeNode(start=0, end=1, val=7),     SegmentTreeNode(start=2, end=2, val=5),     SegmentTreeNode(start=3, end=3, val=3),     SegmentTreeNode(start=4, end=4, val=4),     SegmentTreeNode(start=0, end=0, val=2),     SegmentTreeNode(start=1, end=1, val=5)) >>> >>> num_arr.query_range(3, 4) 7 >>> num_arr.query_range(2, 2) 5 >>> num_arr.query_range(1, 3) 13 >>> >>> max_arr = SegmentTree([2, 1, 5, 3, 4], max) >>> for node in max_arr.traverse(): ...     print(node) ... SegmentTreeNode(start=0, end=4, val=5) SegmentTreeNode(start=0, end=2, val=5) SegmentTreeNode(start=3, end=4, val=4) SegmentTreeNode(start=0, end=1, val=2) SegmentTreeNode(start=2, end=2, val=5) SegmentTreeNode(start=3, end=3, val=3) SegmentTreeNode(start=4, end=4, val=4) SegmentTreeNode(start=0, end=0, val=2) SegmentTreeNode(start=1, end=1, val=1) >>> >>> max_arr.update(1, 5) >>> for node in max_arr.traverse(): ...     print(node) ... SegmentTreeNode(start=0, end=4, val=5) SegmentTreeNode(start=0, end=2, val=5) SegmentTreeNode(start=3, end=4, val=4) SegmentTreeNode(start=0, end=1, val=5) SegmentTreeNode(start=2, end=2, val=5) SegmentTreeNode(start=3, end=3, val=3) SegmentTreeNode(start=4, end=4, val=4) SegmentTreeNode(start=0, end=0, val=2) SegmentTreeNode(start=1, end=1, val=5) >>> >>> max_arr.query_range(3, 4) 4 >>> max_arr.query_range(2, 2) 5 >>> max_arr.query_range(1, 3) 5 >>> >>> min_arr = SegmentTree([2, 1, 5, 3, 4], min) >>> for node in min_arr.traverse(): ...     print(node) ... SegmentTreeNode(start=0, end=4, val=1) SegmentTreeNode(start=0, end=2, val=1) SegmentTreeNode(start=3, end=4, val=3) SegmentTreeNode(start=0, end=1, val=1) SegmentTreeNode(start=2, end=2, val=5) SegmentTreeNode(start=3, end=3, val=3) SegmentTreeNode(start=4, end=4, val=4) SegmentTreeNode(start=0, end=0, val=2) SegmentTreeNode(start=1, end=1, val=1) >>> >>> min_arr.update(1, 5) >>> for node in min_arr.traverse(): ...     print(node) ... SegmentTreeNode(start=0, end=4, val=2) SegmentTreeNode(start=0, end=2, val=2) SegmentTreeNode(start=3, end=4, val=3) SegmentTreeNode(start=0, end=1, val=2) SegmentTreeNode(start=2, end=2, val=5) SegmentTreeNode(start=3, end=3, val=3) SegmentTreeNode(start=4, end=4, val=4) SegmentTreeNode(start=0, end=0, val=2) SegmentTreeNode(start=1, end=1, val=5) >>> >>> min_arr.query_range(3, 4) 3 >>> min_arr.query_range(2, 2) 5 >>> min_arr.query_range(1, 3) 3 >>>",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","__init__","","self._build_tree, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","update","Update an element in log(N) time :param i: position to be update :param val: new value >>> import operator >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add) >>> num_arr.update(1, 5) >>> num_arr.query_range(1, 3) 13","self._update_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","query_range","Get range query value in log(N) time :param i: left element index :param j: right element index :return: element combined in the range [i, j] >>> import operator >>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add) >>> num_arr.update(1, 5) >>> num_arr.query_range(3, 4) 7 >>> num_arr.query_range(2, 2) 5 >>> num_arr.query_range(1, 3) 13 >>>","self._query_range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","_build_tree","","self._build_tree, self._build_tree, SegmentTreeNode, SegmentTreeNode, self.fn"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","_update_tree","","self.fn, self._update_tree, self._update_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","_query_range","","self._query_range, self._query_range, self.fn, self._query_range, self._query_range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\segment_tree_other.py","","traverse","","Queue, queue.put, queue.empty, queue.get, queue.put, queue.put"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","TreeNode","","A binary tree node has a value, left child, and right child.  Props:     value: The value of the node.     left: The left child of the node.     right: The right child of the node.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","deserialize","Deserialize a string to a binary tree.  Args:     data(str): The serialized string.  Returns:     The root of the binary tree.  >>> root = TreeNode.five_tree() >>> serialzed_data = repr(root) >>> deserialized = deserialize(serialzed_data) >>> root == deserialized True >>> root is deserialized  # two separate trees False >>> root.right.right.value = 6 >>> root == deserialized False >>> serialzed_data = repr(root) >>> deserialized = deserialize(serialzed_data) >>> root == deserialized True >>> deserialize("""") Traceback (most recent call last):     ... ValueError: Data cannot be empty.","data.split, build_tree, ValueError, nodes.pop, TreeNode, build_tree, build_tree, int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","__post_init__","","isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","__iter__","Iterate through the tree in preorder.  Returns:     An iterator of the tree nodes.  >>> list(TreeNode(1)) [1,null,null] >>> tuple(TreeNode(1, TreeNode(2), TreeNode(3))) (1,2,null,null,3,null,null, 2,null,null, 3,null,null)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","__len__","Count the number of nodes in the tree.  Returns:     The number of nodes in the tree.  >>> len(TreeNode(1)) 1 >>> len(TreeNode(1, TreeNode(2), TreeNode(3))) 3","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","__repr__","Represent the tree as a string.  Returns:     A string representation of the tree.  >>> repr(TreeNode(1)) '1,null,null' >>> repr(TreeNode(1, TreeNode(2), TreeNode(3))) '1,2,null,null,3,null,null' >>> repr(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))) '1,2,null,null,3,4,null,null,5,null,null'",".replace"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","five_tree",">>> repr(TreeNode.five_tree()) '1,2,null,null,3,4,null,null,5,null,null'","TreeNode, TreeNode, TreeNode, TreeNode, TreeNode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\serialize_deserialize_binary_tree.py","","build_tree","","nodes.pop, TreeNode, build_tree, build_tree, int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\symmetric_tree.py","Node","","A Node represents an element of a binary tree, which contains:  Attributes: data: The value stored in the node (int). left: Pointer to the left child node (Node or None). right: Pointer to the right child node (Node or None).  Example: >>> node = Node(1, Node(2), Node(3)) >>> node.data 1 >>> node.left.data 2 >>> node.right.data 3",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\symmetric_tree.py","","make_symmetric_tree","Create a symmetric tree for testing.  The tree looks like this:        1      /   \     2     2   / \    / \  3   4   4  3  Returns: Node: Root node of a symmetric tree.  Example: >>> tree = make_symmetric_tree() >>> tree.data 1 >>> tree.left.data == tree.right.data True >>> tree.left.left.data == tree.right.right.data True","Node, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\symmetric_tree.py","","make_asymmetric_tree","Create an asymmetric tree for testing.  The tree looks like this:        1      /   \     2     2   / \    / \  3   4   3  4  Returns: Node: Root node of an asymmetric tree.  Example: >>> tree = make_asymmetric_tree() >>> tree.data 1 >>> tree.left.data == tree.right.data True >>> tree.left.left.data == tree.right.right.data False","Node, Node, Node, Node, Node, Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\symmetric_tree.py","","is_symmetric_tree","Check if a binary tree is symmetric (i.e., a mirror of itself).  Parameters: tree: The root node of the binary tree.  Returns: bool: True if the tree is symmetric, False otherwise.  Example: >>> is_symmetric_tree(make_symmetric_tree()) True >>> is_symmetric_tree(make_asymmetric_tree()) False","is_mirror"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\symmetric_tree.py","","is_mirror","Check if two subtrees are mirror images of each other.  Parameters: left: The root node of the left subtree. right: The root node of the right subtree.  Returns: bool: True if the two subtrees are mirrors of each other, False otherwise.  Example: >>> tree1 = make_symmetric_tree() >>> is_mirror(tree1.left, tree1.right) True >>> tree2 = make_asymmetric_tree() >>> is_mirror(tree2.left, tree2.right) False","is_mirror, is_mirror"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","Node","","Treap's node Treap is a binary tree by value and heap by priority",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","split","We split current tree into 2 trees with value:  Left tree contains all values less than split value. Right tree contains all values greater or equal, than split value","split, split"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","merge","We merge 2 trees into one. Note: all left tree's values must be less than all right tree's","merge, merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","insert","Insert element  Split current tree with a value into left, right, Insert new node into the middle Merge left, node, right into root","Node, split, merge, merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","erase","Erase element  Split all nodes with values less into left, Split all nodes with values greater into right. Merge left, right","split, split, merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","inorder","Just recursive print of a tree","inorder, print, inorder"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","interact_treap","Commands: + value to add value into treap - value to erase all nodes with value      >>> root = interact_treap(None, ""+1"")     >>> inorder(root)     1,     >>> root = interact_treap(root, ""+3 +5 +17 +19 +2 +16 +4 +0"")     >>> inorder(root)     0,1,2,3,4,5,16,17,19,     >>> root = interact_treap(root, ""+4 +4 +4"")     >>> inorder(root)     0,1,2,3,4,4,4,4,5,16,17,19,     >>> root = interact_treap(root, ""-0"")     >>> inorder(root)     1,2,3,4,4,4,4,5,16,17,19,     >>> root = interact_treap(root, ""-4"")     >>> inorder(root)     1,2,3,5,16,17,19,     >>> root = interact_treap(root, ""=0"")     Unknown command","args.split, insert, int, erase, print, int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","main","After each command, program prints treap","print, input, print, interact_treap, print, input"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","__init__","","random"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","__repr__","","pformat"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\treap.py","","__str__","","str, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","build_tree","Builds the tree for arr and returns the root of the constructed tree  >>> build_tree(test_array) Node(min_value=0 max_value=9)","Node, enumerate, build_tree, build_tree, len, min, max, len, left_arr.append, right_arr.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","rank_till_index","Returns the number of occurrences of num in interval [0, index] in the list  >>> root = build_tree(test_array) >>> rank_till_index(root, 6, 6) 1 >>> rank_till_index(root, 2, 0) 1 >>> rank_till_index(root, 1, 10) 2 >>> rank_till_index(root, 17, 7) 0 >>> rank_till_index(root, 0, 9) 1","rank_till_index, rank_till_index"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","rank","Returns the number of occurrences of num in interval [start, end] in the list  >>> root = build_tree(test_array) >>> rank(root, 6, 3, 13) 2 >>> rank(root, 2, 0, 19) 4 >>> rank(root, 9, 2 ,2) 0 >>> rank(root, 0, 5, 10) 2","rank_till_index, rank_till_index"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","quantile","Returns the index'th smallest element in interval [start, end] in the list index is 0-indexed  >>> root = build_tree(test_array) >>> quantile(root, 2, 2, 5) 5 >>> quantile(root, 5, 2, 13) 4 >>> quantile(root, 0, 6, 6) 8 >>> quantile(root, 4, 2, 5) -1","quantile, quantile"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","range_counting","Returns the number of elements in range [start_num, end_num] in interval [start, end] in the list  >>> root = build_tree(test_array) >>> range_counting(root, 1, 10, 3, 7) 3 >>> range_counting(root, 2, 2, 1, 4) 1 >>> range_counting(root, 0, 19, 0, 100) 20 >>> range_counting(root, 1, 0, 1, 100) 0 >>> range_counting(root, 0, 17, 100, 1) 0","range_counting, range_counting"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\binary_tree\wavelet_tree.py","","__repr__",">>> node = Node(length=27) >>> repr(node) 'Node(min_value=-1 max_value=-1)' >>> repr(node) == str(node) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\alternate_disjoint_set.py","DisjointSet","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\alternate_disjoint_set.py","","__init__","Initialize with a list of the number of items in each set and with rank = 1 for each set","max, len, list, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\alternate_disjoint_set.py","","merge","Merge two sets together using Union by rank heuristic Return True if successful Merge two disjoint sets >>> A = DisjointSet([1, 1, 1]) >>> A.merge(1, 2) True >>> A.merge(0, 2) True >>> A.merge(0, 1) False","self.get_parent, self.get_parent, max"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\alternate_disjoint_set.py","","get_parent","Find the Parent of a given set >>> A = DisjointSet([1, 1, 1]) >>> A.merge(1, 2) True >>> A.get_parent(0) 0 >>> A.get_parent(1) 2","self.get_parent"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","","make_set","Make x as a set.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","","union_set","Union of two sets. set with bigger rank should be parent, so that the disjoint set tree will be more flat.","find_set, find_set"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","","find_set","Return the parent of x","find_set"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","","find_python_set","Return a Python Standard Library set that contains i.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","","test_disjoint_set",">>> test_disjoint_set()","union_set, union_set, union_set, union_set, Node, make_set, range, .isdisjoint, find_python_set, find_python_set, find_set, find_set, find_set, find_set"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\disjoint_set\disjoint_set.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","Bloom","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","add","","self.hash_"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","exists","","self.hash_"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","__contains__","","self.exists"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","format_bin","","res.zfill, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","bitstring","","self.format_bin"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","hash_","","int.from_bytes, .digest, func, value.encode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","format_hash","","self.format_bin, self.hash_"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\bloom_filter.py","","estimated_error_rate","",".count, len, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\double_hash.py","DoubleHash","","Hash Table example with open addressing and Double Hash",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\double_hash.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\double_hash.py","","__hash_function_2","","next_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\double_hash.py","","__hash_double_function","","self.__hash_function_2"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\double_hash.py","","_collision_resolution","Examples:  1. Try to add three data elements when the size is three >>> dh = DoubleHash(3) >>> dh.insert_data(10) >>> dh.insert_data(20) >>> dh.insert_data(30) >>> dh.keys() {1: 10, 2: 20, 0: 30}  2. Try to add three data elements when the size is two >>> dh = DoubleHash(2) >>> dh.insert_data(10) >>> dh.insert_data(20) >>> dh.insert_data(30) >>> dh.keys() {10: 10, 9: 20, 8: 30}  3. Try to add three data elements when the size is four >>> dh = DoubleHash(4) >>> dh.insert_data(10) >>> dh.insert_data(20) >>> dh.insert_data(30) >>> dh.keys() {9: 20, 10: 10, 8: 30}","self.hash_function, self.__hash_double_function, self.balanced_factor"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","_Item","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","_DeletedItem","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","HashMap","","Hash map with open addressing.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__bool__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_get_bucket_index","","hash, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_get_next_ind","Get next index.  Implements linear open addressing. >>> HashMap(5)._get_next_ind(3) 4 >>> HashMap(5)._get_next_ind(5) 1 >>> HashMap(5)._get_next_ind(6) 2 >>> HashMap(5)._get_next_ind(9) 0","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_try_set","Try to add value to the bucket.  If bucket is empty or key is the same, does insert and return True.  If bucket has another key that means that we need to check next bucket.","_Item"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_is_full","Return true if we have reached safe capacity.  So we need to increase the number of buckets to avoid collisions.  >>> hm = HashMap(2) >>> hm._add_item(1, 10) >>> hm._add_item(2, 20) >>> hm._is_full() True >>> HashMap(2)._is_full() False","len, len, int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_is_sparse","Return true if we need twice fewer buckets when we have now.","len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_resize","","self._add_item"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_size_up","","self._resize, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_size_down","","self._resize, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_iterate_buckets","","self._get_bucket_index, range, len, self._get_next_ind"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","_add_item","Try to add 3 elements when the size is 5 >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm._add_item(2, 20) >>> hm._add_item(3, 30) >>> hm HashMap(1: 10, 2: 20, 3: 30)  Try to add 3 elements when the size is 5 >>> hm = HashMap(5) >>> hm._add_item(-5, 10) >>> hm._add_item(6, 30) >>> hm._add_item(-7, 20) >>> hm HashMap(-5: 10, 6: 30, -7: 20)  Try to add 3 elements when size is 1 >>> hm = HashMap(1) >>> hm._add_item(10, 13.2) >>> hm._add_item(6, 5.26) >>> hm._add_item(7, 5.155) >>> hm HashMap(10: 13.2)  Trying to add an element with a key that is a floating point value >>> hm = HashMap(5) >>> hm._add_item(1.5, 10) >>> hm HashMap(1.5: 10)  5. Trying to add an item with the same key >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm._add_item(1, 20) >>> hm HashMap(1: 20)","self._iterate_buckets, self._try_set"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__setitem__","1. Changing value of item whose key is present >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm.__setitem__(1, 20) >>> hm HashMap(1: 20)  2. Changing value of item whose key is not present >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm.__setitem__(0, 20) >>> hm HashMap(0: 20, 1: 10)  3. Changing the value of the same item multiple times >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm.__setitem__(1, 20) >>> hm.__setitem__(1, 30) >>> hm HashMap(1: 30)","self._is_full, self._add_item, self._size_up"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__delitem__",">>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm._add_item(2, 20) >>> hm._add_item(3, 30) >>> hm.__delitem__(3) >>> hm HashMap(1: 10, 2: 20) >>> hm = HashMap(5) >>> hm._add_item(-5, 10) >>> hm._add_item(6, 30) >>> hm._add_item(-7, 20) >>> hm.__delitem__(-5) >>> hm HashMap(6: 30, -7: 20)  # Trying to remove a non-existing item >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm._add_item(2, 20) >>> hm._add_item(3, 30) >>> hm.__delitem__(4) Traceback (most recent call last): ... KeyError: 4  # Test resize down when sparse ## Setup: resize up >>> hm = HashMap(initial_block_size=100, capacity_factor=0.75) >>> len(hm._buckets) 100 >>> for i in range(75): ...     hm[i] = i >>> len(hm._buckets) 100 >>> hm[75] = 75 >>> len(hm._buckets) 200  ## Resize down >>> del hm[75] >>> len(hm._buckets) 200 >>> del hm[74] >>> len(hm._buckets) 100","self._iterate_buckets, self._is_sparse, self._size_down, KeyError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__getitem__","Returns the item at the given key  >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm.__getitem__(1) 10  >>> hm = HashMap(5) >>> hm._add_item(10, -10) >>> hm._add_item(20, -20) >>> hm.__getitem__(20) -20  >>> hm = HashMap(5) >>> hm._add_item(-1, 10) >>> hm.__getitem__(-1) 10","self._iterate_buckets, KeyError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__len__","Returns the number of items present in hashmap  >>> hm = HashMap(5) >>> hm._add_item(1, 10) >>> hm._add_item(2, 20) >>> hm._add_item(3, 30) >>> hm.__len__() 3  >>> hm = HashMap(5) >>> hm.__len__() 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_map.py","","__repr__","",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","HashTable","","Basic Hash Table example with open addressing and linear probing",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","keys","The keys function returns a dictionary containing the key value pairs. key being the index number in hash table and value being the data value.  Examples: 1. creating HashTable with size 10 and inserting 3 elements >>> ht = HashTable(10) >>> ht.insert_data(10) >>> ht.insert_data(20) >>> ht.insert_data(30) >>> ht.keys() {0: 10, 1: 20, 2: 30}  2. creating HashTable with size 5 and inserting 5 elements >>> ht = HashTable(5) >>> ht.insert_data(5) >>> ht.insert_data(4) >>> ht.insert_data(3) >>> ht.insert_data(2) >>> ht.insert_data(1) >>> ht.keys() {0: 5, 4: 4, 3: 3, 2: 2, 1: 1}",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","balanced_factor","","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","hash_function","Generates hash for the given key value  Examples:  Creating HashTable with size 5 >>> ht = HashTable(5) >>> ht.hash_function(10) 0 >>> ht.hash_function(20) 0 >>> ht.hash_function(4) 4 >>> ht.hash_function(18) 3 >>> ht.hash_function(-18) 2 >>> ht.hash_function(18.5) 3.5 >>> ht.hash_function(0) 0 >>> ht.hash_function(-0) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","_step_by_step","","print, print, print, list, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","bulk_insert","bulk_insert is used for entering more than one element at a time in the HashTable.  Examples: 1. >>> ht = HashTable(5) >>> ht.bulk_insert((10,20,30)) step 1 [0, 1, 2, 3, 4] [10, None, None, None, None] step 2 [0, 1, 2, 3, 4] [10, 20, None, None, None] step 3 [0, 1, 2, 3, 4] [10, 20, 30, None, None]  2. >>> ht = HashTable(5) >>> ht.bulk_insert([5,4,3,2,1]) step 1 [0, 1, 2, 3, 4] [5, None, None, None, None] step 2 [0, 1, 2, 3, 4] [5, None, None, None, 4] step 3 [0, 1, 2, 3, 4] [5, None, None, 3, 4] step 4 [0, 1, 2, 3, 4] [5, None, 2, 3, 4] step 5 [0, 1, 2, 3, 4] [5, 1, 2, 3, 4]","self.insert_data, self._step_by_step"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","_set_value","_set_value functions allows to update value at a particular hash  Examples: 1. _set_value in HashTable of size 5 >>> ht = HashTable(5) >>> ht.insert_data(10) >>> ht.insert_data(20) >>> ht.insert_data(30) >>> ht._set_value(0,15) >>> ht.keys() {0: 15, 1: 20, 2: 30}  2. _set_value in HashTable of size 2 >>> ht = HashTable(2) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99) >>> ht._set_value(3,15) >>> ht.keys() {3: 15, 2: 17, 4: 99}  3. _set_value in HashTable when hash is not present >>> ht = HashTable(2) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99) >>> ht._set_value(0,15) >>> ht.keys() {3: 18, 2: 17, 4: 99, 0: 15}  4. _set_value in HashTable when multiple hash are not present >>> ht = HashTable(2) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99) >>> ht._set_value(0,15) >>> ht._set_value(1,20) >>> ht.keys() {3: 18, 2: 17, 4: 99, 0: 15, 1: 20}",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","_collision_resolution","This method is a type of open addressing which is used for handling collision.  In this implementation the concept of linear probing has been used.  The hash table is searched sequentially from the original location of the hash, if the new hash/location we get is already occupied we check for the next hash/location.  references:     - https://en.wikipedia.org/wiki/Linear_probing  Examples: 1. The collision will be with keys 18 & 99, so new hash will be created for 99 >>> ht = HashTable(3) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99) >>> ht.keys() {2: 17, 0: 18, 1: 99}  2. The collision will be with keys 17 & 101, so new hash will be created for 101 >>> ht = HashTable(4) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99) >>> ht.insert_data(101) >>> ht.keys() {1: 17, 2: 18, 3: 99, 0: 101}  2. The collision will be with all keys, so new hash will be created for all >>> ht = HashTable(1) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99) >>> ht.keys() {2: 17, 3: 18, 4: 99}  3. Trying to insert float key in hash >>> ht = HashTable(1) >>> ht.insert_data(17) >>> ht.insert_data(18) >>> ht.insert_data(99.99) Traceback (most recent call last): ... TypeError: list indices must be integers or slices, not float","self.hash_function, self.values.count, self.hash_function"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","rehashing","","next_prime, self._keys.clear, self.insert_data"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table.py","","insert_data","insert_data is used for inserting a single element at a time in the HashTable.  Examples:  >>> ht = HashTable(3) >>> ht.insert_data(5) >>> ht.keys() {2: 5} >>> ht = HashTable(5) >>> ht.insert_data(30) >>> ht.insert_data(50) >>> ht.keys() {0: 30, 1: 50}","self.hash_function, self._set_value, self._collision_resolution, self._set_value, self.rehashing, self.insert_data"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table_with_linked_list.py","HashTableWithLinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table_with_linked_list.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table_with_linked_list.py","","_set_value","",".appendleft, deque"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table_with_linked_list.py","","balanced_factor","","sum, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\hash_table_with_linked_list.py","","_collision_resolution","","._collision_resolution, super, len, self.values.count"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\quadratic_probing.py","QuadraticProbing","","Basic Hash Table example with open addressing using Quadratic Probing",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\quadratic_probing.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\quadratic_probing.py","","_collision_resolution","Quadratic probing is an open addressing scheme used for resolving collisions in hash table.  It works by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until open slot is found.  Hash + 1, Hash + 2, Hash + 3 .... Hash + n  reference:     - https://en.wikipedia.org/wiki/Quadratic_probing e.g: 1. Create hash table with size 7 >>> qp = QuadraticProbing(7) >>> qp.insert_data(90) >>> qp.insert_data(340) >>> qp.insert_data(24) >>> qp.insert_data(45) >>> qp.insert_data(99) >>> qp.insert_data(73) >>> qp.insert_data(7) >>> qp.keys() {11: 45, 14: 99, 7: 24, 0: 340, 5: 73, 6: 90, 8: 7}  2. Create hash table with size 8 >>> qp = QuadraticProbing(8) >>> qp.insert_data(0) >>> qp.insert_data(999) >>> qp.insert_data(111) >>> qp.keys() {0: 0, 7: 999, 3: 111}  3. Try to add three data elements when the size is two >>> qp =  QuadraticProbing(2) >>> qp.insert_data(0) >>> qp.insert_data(999) >>> qp.insert_data(111) >>> qp.keys() {0: 0, 4: 999, 1: 111}  4. Try to add three data elements when the size is one >>> qp =  QuadraticProbing(1) >>> qp.insert_data(0) >>> qp.insert_data(999) >>> qp.insert_data(111) >>> qp.keys() {4: 999, 1: 111}","self.hash_function, self.hash_function, self.balanced_factor"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\number_theory\prime_numbers.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False","range, isinstance, int, any, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\number_theory\prime_numbers.py","","next_prime","","is_prime, next_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","_get","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","_set","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","_del","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","_run_operation","","fun"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","test_hash_map_is_the_same_as_dict","","pytest.mark.parametrize, HashMap, enumerate, _run_operation, _run_operation, pytest.param, pytest.param, pytest.param, pytest.param, pytest.param, pytest.param, str, str, set, set, len, len, set, set, my.items, py.items"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","test_no_new_methods_was_added_to_api","","name.startswith, dir, is_public, dir, is_public, HashMap"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\hashing\tests\test_hash_map.py","","is_public","","name.startswith"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","Node","","Node in a doubly-linked binomial tree, containing:     - value     - size of left subtree     - link to left, right and parent nodes",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","BinomialHeap","","Min-oriented priority queue implemented with the Binomial Heap data structure implemented with the BinomialHeap class. It supports:     - Insert element in a heap with n elements: Guaranteed logn, amoratized 1     - Merge (meld) heaps of size m and n: O(logn + logm)     - Delete Min: O(logn)     - Peek (return min without deleting it): O(1)  Example:  Create a random permutation of 30 integers to be inserted and 19 of them deleted >>> import numpy as np >>> permutation = np.random.permutation(list(range(30)))  Create a Heap and insert the 30 integers __init__() test >>> first_heap = BinomialHeap()  30 inserts - insert() test >>> for number in permutation: ...     first_heap.insert(number)  Size test >>> first_heap.size 30  Deleting - delete() test >>> [int(first_heap.delete_min()) for _ in range(20)] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]  Create a new Heap >>> second_heap = BinomialHeap() >>> vals = [17, 20, 31, 34] >>> for value in vals: ...     second_heap.insert(value)   The heap should have the following structure:                  17                /  \               #    31                   /  \                 20    34                /  \  /  \               #    # #   #  preOrder() test >>> "" "".join(str(x) for x in second_heap.pre_order()) ""(17, 0) ('#', 1) (31, 1) (20, 2) ('#', 3) ('#', 3) (34, 2) ('#', 3) ('#', 3)""  printing Heap - __str__() test >>> print(second_heap) 17 -# -31 --20 ---# ---# --34 ---# ---#  mergeHeaps() test >>> >>> merged = second_heap.merge_heaps(first_heap) >>> merged.peek() 17  values in merged heap; (merge is inplace) >>> results = [] >>> while not first_heap.is_empty(): ...     results.append(int(first_heap.delete_min())) >>> results [17, 20, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31, 34]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","merge_trees","In-place merge of two binomial trees of equal size. Returns the root of the resulting tree",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","merge_heaps","In-place merge of two binomial heaps. Both of them become the resulting merged heap","range, combined_roots_list.append, combined_roots_list.append, len, i.merge_trees"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","insert","insert a value in the heap","Node, Node, self.bottom_root.merge_trees"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","peek","return min element without deleting it",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","is_empty","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","delete_min","delete min element and return it","BinomialHeap, self.merge_heaps, int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","pre_order","Returns the Pre-order representation of the heap including values of nodes plus their level distance from the root; Empty nodes appear as #","self.__traversal"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","__traversal","Pre-order traversal of nodes","preorder.append, self.__traversal, self.__traversal, preorder.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\binomial_heap.py","","__str__","Overwriting str for a pre-order print of nodes in heap; Performance is poor, so use only for small examples","self.is_empty, self.pre_order, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","Comparable","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","Heap","","A Max Heap Implementation  >>> unsorted = [103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5] >>> h = Heap() >>> h.build_max_heap(unsorted) >>> h [209, 201, 25, 103, 107, 15, 1, 9, 7, 11, 5] >>> >>> h.extract_max() 209 >>> h [201, 107, 25, 103, 11, 15, 1, 9, 7, 5] >>> >>> h.insert(100) >>> h [201, 107, 25, 103, 100, 15, 1, 9, 7, 5, 11] >>> >>> h.heap_sort() >>> h [1, 5, 7, 9, 11, 15, 25, 100, 103, 107, 201]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","__gt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","__eq__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","__repr__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","parent_index","returns the parent index based on the given child index  >>> h = Heap() >>> h.build_max_heap([103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5]) >>> h [209, 201, 25, 103, 107, 15, 1, 9, 7, 11, 5]  >>> h.parent_index(-1)  # returns none if index is <=0  >>> h.parent_index(0)   # returns none if index is <=0  >>> h.parent_index(1) 0 >>> h.parent_index(2) 0 >>> h.parent_index(3) 1 >>> h.parent_index(4) 1 >>> h.parent_index(5) 2 >>> h.parent_index(10.5) 4.0 >>> h.parent_index(209.0) 104.0 >>> h.parent_index(""Test"") Traceback (most recent call last): ... TypeError: '>' not supported between instances of 'str' and 'int'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","left_child_idx","return the left child index if the left child exists. if not, return None.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","right_child_idx","return the right child index if the right child exists. if not, return None.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","max_heapify","correct a single violation of the heap property in a subtree's root.  It is the function that is responsible for restoring the property of Max heap i.e the maximum element is always at top.","self.left_child_idx, self.right_child_idx, self.max_heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","build_max_heap","build max heap from an unsorted array  >>> h = Heap() >>> h.build_max_heap([20,40,50,20,10]) >>> h [50, 40, 20, 20, 10]  >>> h = Heap() >>> h.build_max_heap([1,2,3,4,5,6,7,8,9,0]) >>> h [9, 8, 7, 4, 5, 6, 3, 2, 1, 0]  >>> h = Heap() >>> h.build_max_heap([514,5,61,57,8,99,105]) >>> h [514, 57, 105, 5, 8, 99, 61]  >>> h = Heap() >>> h.build_max_heap([514,5,61.6,57,8,9.9,105]) >>> h [514, 57, 105, 5, 8, 9.9, 61.6]","list, len, range, self.max_heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","extract_max","get and remove max from heap  >>> h = Heap() >>> h.build_max_heap([20,40,50,20,10]) >>> h.extract_max() 50  >>> h = Heap() >>> h.build_max_heap([514,5,61,57,8,99,105]) >>> h.extract_max() 514  >>> h = Heap() >>> h.build_max_heap([1,2,3,4,5,6,7,8,9,0]) >>> h.extract_max() 9","self.h.pop, self.max_heapify, self.h.pop, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","insert","insert a new value into the max heap  >>> h = Heap() >>> h.insert(10) >>> h [10]  >>> h = Heap() >>> h.insert(10) >>> h.insert(10) >>> h [10, 10]  >>> h = Heap() >>> h.insert(10) >>> h.insert(10.1) >>> h [10.1, 10]  >>> h = Heap() >>> h.insert(0.1) >>> h.insert(0) >>> h.insert(9) >>> h.insert(5) >>> h [9, 5, 0.1, 0]","self.h.append, self.max_heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap.py","","heap_sort","","range, self.max_heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","Heap","","A generic Heap class, can be used as min or max by passing the key function accordingly.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","test_heap",">>> h = Heap()  # Max-heap >>> h.insert_item(5, 34) >>> h.insert_item(6, 31) >>> h.insert_item(7, 37) >>> h.get_top() [7, 37] >>> h.extract_top() [7, 37] >>> h.extract_top() [5, 34] >>> h.extract_top() [6, 31] >>> h = Heap(key=lambda x: -x)  # Min heap >>> h.insert_item(5, 34) >>> h.insert_item(6, 31) >>> h.insert_item(7, 37) >>> h.get_top() [6, -31] >>> h.extract_top() [6, -31] >>> h.extract_top() [5, -34] >>> h.extract_top() [7, -37] >>> h.insert_item(8, 45) >>> h.insert_item(9, 40) >>> h.insert_item(10, 50) >>> h.get_top() [9, -40] >>> h.update_item(10, 30) >>> h.get_top() [10, -30] >>> h.delete_item(10) >>> h.get_top() [9, -40]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_parent","Returns parent index of given index if exists else None","int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_left","Returns left-child-index of given index if exists else None","int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_right","Returns right-child-index of given index if exists else None","int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_swap","Performs changes required for swapping two elements in the heap",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_cmp","Compares the two items using default comparison",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_get_valid_parent","Returns index of valid parent as per desired ordering among given index and both it's children","self._left, self._right, self._cmp, self._cmp"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_heapify_up","Fixes the heap in upward direction of given index","self._parent, self._swap, self._cmp, self._parent"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","_heapify_down","Fixes the heap in downward direction of given index","self._get_valid_parent, self._swap, self._get_valid_parent"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","update_item","Updates given item value in heap if present","self._heapify_up, self._heapify_down, self.key"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","delete_item","Deletes given item from heap if present","self._heapify_up, self._heapify_down"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","insert_item","Inserts given item with given value in heap","len, self._heapify_up, self.arr.append, self.key, self.key"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","get_top","Returns top item tuple (Calculated value, item) from heap if present",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\heap_generic.py","","extract_top","Return top item tuple (Calculated value, item) from heap and removes it as well if present","self.get_top, self.delete_item"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","BinaryHeap","","A max-heap implementation in Python >>> binary_heap = BinaryHeap() >>> binary_heap.insert(6) >>> binary_heap.insert(10) >>> binary_heap.insert(15) >>> binary_heap.insert(12) >>> binary_heap.pop() 15 >>> binary_heap.pop() 12 >>> binary_heap.get_list [10, 6] >>> len(binary_heap) 2",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","__swap_up","Swap the element up",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","insert","Insert new element","self.__heap.append, self.__swap_up"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","__swap_down","Swap the element down",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","pop","Pop the root element","self.__heap.pop, self.__swap_down"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","get_list","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\max_heap.py","","__len__","Length of the array",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","MinHeap","",">>> r = Node(""R"", -1) >>> b = Node(""B"", 6) >>> a = Node(""A"", 3) >>> x = Node(""X"", 1) >>> e = Node(""E"", 4) >>> print(b) Node(B, 6) >>> myMinHeap = MinHeap([r, b, a, x, e]) >>> myMinHeap.decrease_key(b, -17) >>> print(b) Node(B, -17) >>> myMinHeap[""B""] -17",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","__init__","","self.build_heap"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","__getitem__","","self.get_value"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","get_parent_idx","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","get_left_child_idx","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","get_right_child_idx","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","get_value","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","build_heap","","self.get_parent_idx, enumerate, range, len, self.sift_down"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","sift_down","","self.get_left_child_idx, self.get_right_child_idx, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","sift_up","","self.get_parent_idx, self.get_parent_idx"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","peek","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","remove","","self.heap.pop, self.sift_down"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","insert","","self.heap.append, self.sift_up, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","is_empty","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\min_heap.py","","decrease_key","","self.sift_up"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","RandomizedHeapNode","","One node of the randomized heap. Contains the value and references to two children.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","RandomizedHeap","","A data structure that allows inserting a new value and to pop the smallest values. Both operations take O(logN) time where N is the size of the structure. Wiki: https://en.wikipedia.org/wiki/Randomized_meldable_heap  >>> RandomizedHeap([2, 3, 1, 5, 1, 7]).to_sorted_list() [1, 1, 2, 3, 5, 7]  >>> rh = RandomizedHeap() >>> rh.pop() Traceback (most recent call last):     ... IndexError: Can't get top element for the empty heap.  >>> rh.insert(1) >>> rh.insert(-1) >>> rh.insert(0) >>> rh.to_sorted_list() [-1, 0, 1]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","value","Return the value of the node.  >>> rhn = RandomizedHeapNode(10) >>> rhn.value 10 >>> rhn = RandomizedHeapNode(-10) >>> rhn.value -10",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","merge","Merge 2 nodes together.  >>> rhn1 = RandomizedHeapNode(10) >>> rhn2 = RandomizedHeapNode(20) >>> RandomizedHeapNode.merge(rhn1, rhn2).value 10  >>> rhn1 = RandomizedHeapNode(20) >>> rhn2 = RandomizedHeapNode(10) >>> RandomizedHeapNode.merge(rhn1, rhn2).value 10  >>> rhn1 = RandomizedHeapNode(5) >>> rhn2 = RandomizedHeapNode(0) >>> RandomizedHeapNode.merge(rhn1, rhn2).value 0","random.choice, RandomizedHeapNode.merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","__init__",">>> rh = RandomizedHeap([3, 1, 3, 7]) >>> rh.to_sorted_list() [1, 3, 3, 7]","self.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","insert","Insert the value into the heap.  >>> rh = RandomizedHeap() >>> rh.insert(3) >>> rh.insert(1) >>> rh.insert(3) >>> rh.insert(7) >>> rh.to_sorted_list() [1, 3, 3, 7]","RandomizedHeapNode.merge, RandomizedHeapNode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","pop","Pop the smallest value from the heap and return it.  >>> rh = RandomizedHeap([3, 1, 3, 7]) >>> rh.pop() 1 >>> rh.pop() 3 >>> rh.pop() 3 >>> rh.pop() 7 >>> rh.pop() Traceback (most recent call last):     ... IndexError: Can't get top element for the empty heap.","self.top, RandomizedHeapNode.merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","top","Return the smallest value from the heap.  >>> rh = RandomizedHeap() >>> rh.insert(3) >>> rh.top() 3 >>> rh.insert(1) >>> rh.top() 1 >>> rh.insert(3) >>> rh.top() 1 >>> rh.insert(7) >>> rh.top() 1","IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","clear","Clear the heap.  >>> rh = RandomizedHeap([3, 1, 3, 7]) >>> rh.clear() >>> rh.pop() Traceback (most recent call last):     ... IndexError: Can't get top element for the empty heap.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","to_sorted_list","Returns sorted list containing all the values in the heap.  >>> rh = RandomizedHeap([3, 1, 3, 7]) >>> rh.to_sorted_list() [1, 3, 3, 7]","result.append, self.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\randomized_heap.py","","__bool__","Check if the heap is not empty.  >>> rh = RandomizedHeap() >>> bool(rh) False >>> rh.insert(1) >>> bool(rh) True >>> rh.clear() >>> bool(rh) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","SkewNode","","One node of the skew heap. Contains the value and references to two children.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","SkewHeap","","A data structure that allows inserting a new value and to pop the smallest values. Both operations take O(logN) time where N is the size of the structure. Wiki: https://en.wikipedia.org/wiki/Skew_heap Visualization: https://www.cs.usfca.edu/~galles/visualization/SkewHeap.html  >>> list(SkewHeap([2, 3, 1, 5, 1, 7])) [1, 1, 2, 3, 5, 7]  >>> sh = SkewHeap() >>> sh.pop() Traceback (most recent call last):     ... IndexError: Can't get top element for the empty heap.  >>> sh.insert(1) >>> sh.insert(-1) >>> sh.insert(0) >>> list(sh) [-1, 0, 1]",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","value","Return the value of the node.  >>> SkewNode(0).value 0 >>> SkewNode(3.14159).value 3.14159 >>> SkewNode(""hello"").value 'hello' >>> SkewNode(None).value  >>> SkewNode(True).value True >>> SkewNode([]).value [] >>> SkewNode({}).value {} >>> SkewNode(set()).value set() >>> SkewNode(0.0).value 0.0 >>> SkewNode(-1e-10).value -1e-10 >>> SkewNode(10).value 10 >>> SkewNode(-10.5).value -10.5 >>> SkewNode().value Traceback (most recent call last): ... TypeError: SkewNode.__init__() missing 1 required positional argument: 'value'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","merge","Merge 2 nodes together. >>> SkewNode.merge(SkewNode(10),SkewNode(-10.5)).value -10.5 >>> SkewNode.merge(SkewNode(10),SkewNode(10.5)).value 10 >>> SkewNode.merge(SkewNode(10),SkewNode(10)).value 10 >>> SkewNode.merge(SkewNode(-100),SkewNode(-10.5)).value -100","SkewNode.merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","__init__",">>> sh = SkewHeap([3, 1, 3, 7]) >>> list(sh) [1, 3, 3, 7]","self.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","__bool__","Check if the heap is not empty.  >>> sh = SkewHeap() >>> bool(sh) False >>> sh.insert(1) >>> bool(sh) True >>> sh.clear() >>> bool(sh) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","__iter__","Returns sorted list containing all the values in the heap.  >>> sh = SkewHeap([3, 1, 3, 7]) >>> list(sh) [1, 3, 3, 7]","iter, result.append, self.insert, self.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","insert","Insert the value into the heap.  >>> sh = SkewHeap() >>> sh.insert(3) >>> sh.insert(1) >>> sh.insert(3) >>> sh.insert(7) >>> list(sh) [1, 3, 3, 7]","SkewNode.merge, SkewNode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","pop","Pop the smallest value from the heap and return it.  >>> sh = SkewHeap([3, 1, 3, 7]) >>> sh.pop() 1 >>> sh.pop() 3 >>> sh.pop() 3 >>> sh.pop() 7 >>> sh.pop() Traceback (most recent call last):     ... IndexError: Can't get top element for the empty heap.","self.top, SkewNode.merge"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","top","Return the smallest value from the heap.  >>> sh = SkewHeap() >>> sh.insert(3) >>> sh.top() 3 >>> sh.insert(1) >>> sh.top() 1 >>> sh.insert(3) >>> sh.top() 1 >>> sh.insert(7) >>> sh.top() 1","IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\heap\skew_heap.py","","clear","Clear the heap.  >>> sh = SkewHeap([3, 1, 3, 7]) >>> sh.clear() >>> sh.pop() Traceback (most recent call last):     ... IndexError: Can't get top element for the empty heap.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\build_kdtree.py","","build_kdtree","Builds a KD-Tree from a list of points.  Args:     points: The list of points to build the KD-Tree from.     depth: The current depth in the tree                  (used to determine axis for splitting).  Returns:     The root node of the KD-Tree,                    or None if no points are provided.","len, points.sort, KDNode, len, build_kdtree, build_kdtree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\kd_node.py","KDNode","","Represents a node in a KD-Tree.  Attributes:     point: The point stored in this node.     left: The left child node.     right: The right child node.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\kd_node.py","","__init__","Initializes a KDNode with the given point and child nodes.  Args:     point (list[float]): The point stored in this node.     left (Optional[KDNode]): The left child node.     right (Optional[KDNode]): The right child node.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\nearest_neighbour_search.py","","nearest_neighbour_search","Performs a nearest neighbor search in a KD-Tree for a given query point.  Args:     root (KDNode | None): The root node of the KD-Tree.     query_point (list[float]): The point for which the nearest neighbor                                 is being searched.  Returns:     tuple[list[float] | None, float, int]:         - The nearest point found in the KD-Tree to the query point,           or None if no point is found.         - The squared distance to the nearest point.         - The number of nodes visited during the search.","float, search, sum, len, search, search, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\nearest_neighbour_search.py","","search","Recursively searches for the nearest neighbor in the KD-Tree.  Args:     node: The current node in the KD-Tree.     depth: The current depth in the KD-Tree.","sum, len, search, search, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\example\example_usage.py","","main","Demonstrates the use of KD-Tree by building it from random points in a 10-dimensional hypercube and performing a nearest neighbor search.","hypercube_points, build_kdtree, np.random.default_rng, .tolist, nearest_neighbour_search, print, print, print, print, points.tolist, rng.random"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\example\hypercube_points.py","","hypercube_points","Generates random points uniformly distributed within an n-dimensional hypercube.  Args:     num_points: Number of points to generate.     hypercube_size: Size of the hypercube.     num_dimensions: Number of dimensions of the hypercube.  Returns:     An array of shape (num_points, num_dimensions)                 with generated points.","np.random.default_rng, rng.random"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\tests\test_kdtree.py","","test_build_kdtree","Test that KD-Tree is built correctly.  Cases:     - Empty points list.     - Positive depth value.     - Negative depth value.","pytest.mark.parametrize, build_kdtree, .tolist, isinstance, len, hypercube_points, len, type"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\tests\test_kdtree.py","","test_nearest_neighbour_search","Test the nearest neighbor search function.","hypercube_points, build_kdtree, np.random.default_rng, .tolist, nearest_neighbour_search, points.tolist, rng.random"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\kd_tree\tests\test_kdtree.py","","test_edge_cases","Test edge cases such as an empty KD-Tree.","build_kdtree, nearest_neighbour_search, float"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","CircularLinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","test_circular_linked_list","Test cases for the CircularLinkedList class. >>> test_circular_linked_list()","CircularLinkedList, range, circular_linked_list.insert_tail, circular_linked_list.insert_head, circular_linked_list.insert_nth, len, circular_linked_list.is_empty, str, circular_linked_list.delete_front, circular_linked_list.delete_tail, circular_linked_list.delete_nth, circular_linked_list.delete_nth, circular_linked_list.is_empty, circular_linked_list.insert_nth, str, .join, str, .join, str, .join, circular_linked_list.delete_front, circular_linked_list.delete_tail, str, .join, circular_linked_list.delete_nth, str, .join, circular_linked_list.is_empty, len, str, str, str, str, str, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","__iter__","Iterate through all nodes in the Circular Linked List yielding their data. Yields:     The data of each node in the linked list.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","__len__","Get the length (number of nodes) in the Circular Linked List.","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","__repr__","Generate a string representation of the Circular Linked List. Returns:     A string of the format ""1->2->....->N"".",".join, str, iter"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","insert_tail","Insert a node with the given data at the end of the Circular Linked List.","self.insert_nth, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","insert_head","Insert a node with the given data at the beginning of the Circular Linked List.","self.insert_nth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","insert_nth","Insert the data of the node at the nth pos in the Circular Linked List. Args:     index: The index at which the data should be inserted.     data: The data to be inserted.  Raises:     IndexError: If the index is out of range.","Node, IndexError, len, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","delete_front","Delete and return the data of the node at the front of the Circular Linked List. Raises:     IndexError: If the list is empty.","self.delete_nth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","delete_tail","Delete and return the data of the node at the end of the Circular Linked List. Returns:     Any: The data of the deleted node. Raises:     IndexError: If the index is out of range.","self.delete_nth, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","delete_nth","Delete and return the data of the node at the nth pos in Circular Linked List. Args:     index (int): The index of the node to be deleted. Defaults to 0. Returns:     Any: The data of the deleted node. Raises:     IndexError: If the index is out of range.","IndexError, len, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\circular_linked_list.py","","is_empty","Check if the Circular Linked List is empty. Returns:     bool: True if the list is empty, False otherwise.","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","_DoublyLinkedBase","","A Private class (to be inherited)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","LinkedDeque","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","_Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","__init__","","self._Node, self._Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","__len__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","is_empty","","self.__len__"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","_insert","","self._Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","_delete","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","first","return first element >>> d = LinkedDeque() >>> d.add_first('A').first() 'A' >>> d.add_first('B').first() 'B'","self.is_empty, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","last","return last element >>> d = LinkedDeque() >>> d.add_last('A').last() 'A' >>> d.add_last('B').last() 'B'","self.is_empty, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","add_first","insertion in the front >>> LinkedDeque().add_first('AV').first() 'AV'","self._insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","add_last","insertion in the end >>> LinkedDeque().add_last('B').last() 'B'","self._insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","remove_first","removal from the front >>> d = LinkedDeque() >>> d.is_empty() True >>> d.remove_first() Traceback (most recent call last):    ... IndexError: remove_first from empty list >>> d.add_first('A') # doctest: +ELLIPSIS <data_structures.linked_list.deque_doubly.LinkedDeque object at ... >>> d.remove_first() 'A' >>> d.is_empty() True","self.is_empty, self._delete, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","remove_last","removal in the end >>> d = LinkedDeque() >>> d.is_empty() True >>> d.remove_last() Traceback (most recent call last):    ... IndexError: remove_first from empty list >>> d.add_first('A') # doctest: +ELLIPSIS <data_structures.linked_list.deque_doubly.LinkedDeque object at ... >>> d.remove_last() 'A' >>> d.is_empty() True","self.is_empty, self._delete, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\deque_doubly.py","","has_next_and_prev","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","DoublyLinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","test_doubly_linked_list",">>> test_doubly_linked_list()","DoublyLinkedList, range, linked_list.insert_at_head, linked_list.insert_at_tail, linked_list.is_empty, str, linked_list.delete_head, linked_list.delete_tail, linked_list.insert_at_nth, str, .join, str, .join, linked_list.delete_head, linked_list.delete_at_nth, linked_list.delete_tail, len, str, .join, len, str, str, str, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","__iter__",">>> linked_list = DoublyLinkedList() >>> linked_list.insert_at_head('b') >>> linked_list.insert_at_head('a') >>> linked_list.insert_at_tail('c') >>> tuple(linked_list) ('a', 'b', 'c')",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","__str__",">>> linked_list = DoublyLinkedList() >>> linked_list.insert_at_tail('a') >>> linked_list.insert_at_tail('b') >>> linked_list.insert_at_tail('c') >>> str(linked_list) 'a->b->c'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","__len__",">>> linked_list = DoublyLinkedList() >>> for i in range(0, 5): ...     linked_list.insert_at_nth(i, i + 1) >>> len(linked_list) == 5 True","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","insert_at_head","","self.insert_at_nth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","insert_at_tail","","self.insert_at_nth, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","insert_at_nth",">>> linked_list = DoublyLinkedList() >>> linked_list.insert_at_nth(-1, 666) Traceback (most recent call last):     .... IndexError: list index out of range >>> linked_list.insert_at_nth(1, 666) Traceback (most recent call last):     .... IndexError: list index out of range >>> linked_list.insert_at_nth(0, 2) >>> linked_list.insert_at_nth(0, 1) >>> linked_list.insert_at_nth(2, 4) >>> linked_list.insert_at_nth(2, 3) >>> str(linked_list) '1->2->3->4' >>> linked_list.insert_at_nth(5, 5) Traceback (most recent call last):     .... IndexError: list index out of range","len, Node, IndexError, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","delete_head","","self.delete_at_nth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","delete_tail","","self.delete_at_nth, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","delete_at_nth",">>> linked_list = DoublyLinkedList() >>> linked_list.delete_at_nth(0) Traceback (most recent call last):     .... IndexError: list index out of range >>> for i in range(0, 5): ...     linked_list.insert_at_nth(i, i + 1) >>> linked_list.delete_at_nth(0) == 1 True >>> linked_list.delete_at_nth(3) == 5 True >>> linked_list.delete_at_nth(1) == 3 True >>> str(linked_list) '2->4' >>> linked_list.delete_at_nth(2) Traceback (most recent call last):     .... IndexError: list index out of range","len, IndexError, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","delete","","self.delete_head, ValueError, self.delete_tail"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list.py","","is_empty",">>> linked_list = DoublyLinkedList() >>> linked_list.is_empty() True >>> linked_list.insert_at_tail(1) >>> linked_list.is_empty() False","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","LinkedListIterator","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","LinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","create_linked_list",">>> new_linked_list = LinkedList() >>> new_linked_list.get_head_data() is None True >>> new_linked_list.get_tail_data() is None True >>> new_linked_list.is_empty() True >>> new_linked_list.insert(10) >>> new_linked_list.get_head_data() 10 >>> new_linked_list.get_tail_data() 10 >>> new_linked_list.insert_at_position(position=3, value=20) >>> new_linked_list.get_head_data() 10 >>> new_linked_list.get_tail_data() 20 >>> new_linked_list.set_head(Node(1000)) >>> new_linked_list.get_head_data() 1000 >>> new_linked_list.get_tail_data() 20 >>> new_linked_list.set_tail(Node(2000)) >>> new_linked_list.get_head_data() 1000 >>> new_linked_list.get_tail_data() 2000 >>> for value in new_linked_list: ...    print(value) 1000 10 20 2000 >>> new_linked_list.is_empty() False >>> for value in new_linked_list: ...    print(value) 1000 10 20 2000 >>> 10 in new_linked_list True >>> new_linked_list.delete_value(value=10) >>> 10 in new_linked_list False >>> new_linked_list.delete_value(value=2000) >>> new_linked_list.get_tail_data() 20 >>> new_linked_list.delete_value(value=1000) >>> new_linked_list.get_tail_data() 20 >>> new_linked_list.get_head_data() 20 >>> for value in new_linked_list: ...    print(value) 20 >>> new_linked_list.delete_value(value=20) >>> for value in new_linked_list: ...    print(value) >>> for value in range(1,10): ...    new_linked_list.insert(value=value) >>> for value in new_linked_list: ...    print(value) 1 2 3 4 5 6 7 8 9 >>> linked_list = LinkedList() >>> linked_list.insert_at_position(position=1, value=10) >>> str(linked_list) '10' >>> linked_list.insert_at_position(position=2, value=20) >>> str(linked_list) '10 20' >>> linked_list.insert_at_position(position=1, value=30) >>> str(linked_list) '30 10 20' >>> linked_list.insert_at_position(position=3, value=40) >>> str(linked_list) '30 10 40 20' >>> linked_list.insert_at_position(position=5, value=50) >>> str(linked_list) '30 10 40 20 50'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__next__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__str__","",".join, nodes.append, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__contains__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","__iter__","","LinkedListIterator"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","get_head_data","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","get_tail_data","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","set_head","","self.insert_before_node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","set_tail","","self.insert_after_node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","insert","","Node, self.set_head, self.set_tail"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","insert_before_node","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","insert_after_node","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","insert_at_position","","Node, self.set_tail, self.insert_before_node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","get_node","","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","delete_value","","self.remove_node_pointers, self.get_node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","remove_node_pointers","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\doubly_linked_list_two.py","","is_empty","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\floyds_cycle_detection.py","Node","","A class representing a node in a singly linked list.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\floyds_cycle_detection.py","LinkedList","","A class representing a singly linked list.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\floyds_cycle_detection.py","","__iter__","Iterates through the linked list.  Returns:     Iterator: An iterator over the linked list.  Examples: >>> linked_list = LinkedList() >>> list(linked_list) [] >>> linked_list.add_node(1) >>> tuple(linked_list) (1,)","visited.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\floyds_cycle_detection.py","","add_node","Adds a new node to the end of the linked list.  Args:     data (Any): The data to be stored in the new node.  Examples: >>> linked_list = LinkedList() >>> linked_list.add_node(1) >>> linked_list.add_node(2) >>> linked_list.add_node(3) >>> linked_list.add_node(4) >>> tuple(linked_list) (1, 2, 3, 4)","Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\floyds_cycle_detection.py","","detect_cycle","Detects if there is a cycle in the linked list using Floyd's cycle detection algorithm.  Returns:     bool: True if there is a cycle, False otherwise.  Examples: >>> linked_list = LinkedList() >>> linked_list.add_node(1) >>> linked_list.add_node(2) >>> linked_list.add_node(3) >>> linked_list.add_node(4)  >>> linked_list.detect_cycle() False  # Create a cycle in the linked list >>> linked_list.head.next_node.next_node.next_node = linked_list.head.next_node  >>> linked_list.detect_cycle() True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\from_sequence.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\from_sequence.py","","make_linked_list","Creates a Linked List from the elements of the given sequence (list/tuple) and returns the head of the Linked List.  >>> make_linked_list([]) Traceback (most recent call last):     ... ValueError: The Elements List is empty >>> make_linked_list(()) Traceback (most recent call last):     ... ValueError: The Elements List is empty >>> make_linked_list([1]) <1> ---> <END> >>> make_linked_list((1,)) <1> ---> <END> >>> make_linked_list([1, 3, 5, 32, 44, 12, 43]) <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END> >>> make_linked_list((1, 3, 5, 32, 44, 12, 43)) <1> ---> <3> ---> <5> ---> <32> ---> <44> ---> <12> ---> <43> ---> <END>","Node, ValueError, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\from_sequence.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\from_sequence.py","","__repr__","Returns a visual representation of the node and all its following nodes.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\has_loop.py","ContainsLoopError","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\has_loop.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\has_loop.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\has_loop.py","","__iter__","","set, visited.add"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\has_loop.py","","has_loop","A loop is when the exact same Node appears more than once in a linked list. >>> root_node = Node(1) >>> root_node.next_node = Node(2) >>> root_node.next_node.next_node = Node(3) >>> root_node.next_node.next_node.next_node = Node(4) >>> root_node.has_loop False >>> root_node.next_node.next_node.next_node = root_node.next_node >>> root_node.has_loop True","list"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\is_palindrome.py","ListNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\is_palindrome.py","","is_palindrome","Check if a linked list is a palindrome.  Args:     head: The head of the linked list.  Returns:     bool: True if the linked list is a palindrome, False otherwise.  Examples:     >>> is_palindrome(None)     True      >>> is_palindrome(ListNode(1))     True      >>> is_palindrome(ListNode(1, ListNode(2)))     False      >>> is_palindrome(ListNode(1, ListNode(2, ListNode(1))))     True      >>> is_palindrome(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))     True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\is_palindrome.py","","is_palindrome_stack","Check if a linked list is a palindrome using a stack.  Args:     head (ListNode): The head of the linked list.  Returns:     bool: True if the linked list is a palindrome, False otherwise.  Examples:     >>> is_palindrome_stack(None)     True      >>> is_palindrome_stack(ListNode(1))     True      >>> is_palindrome_stack(ListNode(1, ListNode(2)))     False      >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(1))))     True      >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))     True","stack.append, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\is_palindrome.py","","is_palindrome_dict","Check if a linked list is a palindrome using a dictionary.  Args:     head (ListNode): The head of the linked list.  Returns:     bool: True if the linked list is a palindrome, False otherwise.  Examples:     >>> is_palindrome_dict(None)     True      >>> is_palindrome_dict(ListNode(1))     True      >>> is_palindrome_dict(ListNode(1, ListNode(2)))     False      >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(1))))     True      >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))     True      >>> is_palindrome_dict(     ...     ListNode(     ...         1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(1)))))     ...     )     ... )     False","d.values, .append, enumerate, len, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","SortedLinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","","merge_lists",">>> SSL = SortedLinkedList >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even)) >>> len(merged) 16 >>> str(merged) '-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10' >>> list(merged) == list(sorted(test_data_odd + test_data_even)) True","SortedLinkedList, list, list"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","","__init__","","sorted, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","","__iter__",">>> tuple(SortedLinkedList(test_data_odd)) == tuple(sorted(test_data_odd)) True >>> tuple(SortedLinkedList(test_data_even)) == tuple(sorted(test_data_even)) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","","__len__",">>> for i in range(3): ...     len(SortedLinkedList(range(i))) == i True True True >>> len(SortedLinkedList(test_data_odd)) 8","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\merge_two_lists.py","","__str__",">>> str(SortedLinkedList([])) '' >>> str(SortedLinkedList(test_data_odd)) '-11 -> -1 -> 0 -> 1 -> 3 -> 5 -> 7 -> 9' >>> str(SortedLinkedList(test_data_even)) '-2 -> 0 -> 2 -> 3 -> 4 -> 6 -> 8 -> 10'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\middle_element_of_linked_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\middle_element_of_linked_list.py","LinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\middle_element_of_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\middle_element_of_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\middle_element_of_linked_list.py","","push","","Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\middle_element_of_linked_list.py","","middle_element",">>> link = LinkedList() >>> link.middle_element() No element found. >>> link.push(5) 5 >>> link.push(6) 6 >>> link.push(8) 8 >>> link.push(8) 8 >>> link.push(10) 10 >>> link.push(12) 12 >>> link.push(17) 17 >>> link.push(7) 7 >>> link.push(3) 3 >>> link.push(20) 20 >>> link.push(-20) -20 >>> link.middle_element() 12 >>>","print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","LinkedList","","A class to represent a Linked List. Use a tail pointer to speed up the append() operation.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","make_linked_list","Creates a Linked List from the elements of the given sequence (list/tuple) and returns the head of the Linked List. >>> make_linked_list([]) Traceback (most recent call last):     ... Exception: The Elements List is empty >>> make_linked_list([7]) 7 >>> make_linked_list(['abc']) abc >>> make_linked_list([7, 25]) 7 -> 25","LinkedList, linked_list.extend, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","in_reverse","Prints the elements of the given Linked List in reverse order >>> in_reverse(LinkedList()) '' >>> in_reverse(make_linked_list([69, 88, 73])) '73 <- 88 <- 69'",".join, str, reversed, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","__init__","Initialize a LinkedList with the head node set to None. >>> linked_list = LinkedList() >>> (linked_list.head, linked_list.tail) (None, None)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","__iter__","Iterate the LinkedList yielding each Node's data. >>> linked_list = LinkedList() >>> items = (1, 2, 3, 4, 5) >>> linked_list.extend(items) >>> tuple(linked_list) == items True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","__repr__","Returns a string representation of the LinkedList. >>> linked_list = LinkedList() >>> str(linked_list) '' >>> linked_list.append(1) >>> str(linked_list) '1' >>> linked_list.extend([2, 3, 4, 5]) >>> str(linked_list) '1 -> 2 -> 3 -> 4 -> 5'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","append","Appends a new node with the given data to the end of the LinkedList. >>> linked_list = LinkedList() >>> str(linked_list) '' >>> linked_list.append(1) >>> str(linked_list) '1' >>> linked_list.append(2) >>> str(linked_list) '1 -> 2'","Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\print_reverse.py","","extend","Appends each item to the end of the LinkedList. >>> linked_list = LinkedList() >>> linked_list.extend([]) >>> str(linked_list) '' >>> linked_list.extend([1, 2]) >>> str(linked_list) '1 -> 2' >>> linked_list.extend([3,4]) >>> str(linked_list) '1 -> 2 -> 3 -> 4'","self.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","LinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","","__init__","","self.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","","__iter__",">>> ints = [] >>> list(LinkedList(ints)) == ints True >>> ints = tuple(range(5)) >>> tuple(LinkedList(ints)) == ints True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","","__len__",">>> for i in range(3): ...     len(LinkedList(range(i))) == i True True True >>> len(LinkedList(""abcdefgh"")) 8","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","","__str__",">>> str(LinkedList([])) '' >>> str(LinkedList(range(5))) '0 -> 1 -> 2 -> 3 -> 4'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","","append",">>> ll = LinkedList([1, 2]) >>> tuple(ll) (1, 2) >>> ll.append(3) >>> tuple(ll) (1, 2, 3) >>> ll.append(4) >>> tuple(ll) (1, 2, 3, 4) >>> len(ll) 4","Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\reverse_k_group.py","","reverse_k_nodes","reverse nodes within groups of size k >>> ll = LinkedList([1, 2, 3, 4, 5]) >>> ll.reverse_k_nodes(2) >>> tuple(ll) (2, 1, 4, 3, 5) >>> str(ll) '2 -> 1 -> 4 -> 3 -> 5'","len, Node, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\rotate_to_the_right.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\rotate_to_the_right.py","","print_linked_list","Print the entire linked list iteratively.      This function prints the elements of a linked list separated by '->'.      Parameters:         head (Node | None): The head of the linked list to be printed, or None if the linked list is empty.      >>> head = insert_node(None, 0)     >>> head = insert_node(head, 2)     >>> head = insert_node(head, 1)     >>> print_linked_list(head)     0->2->1     >>> head = insert_node(head, 4)     >>> head = insert_node(head, 5)     >>> print_linked_list(head)     0->2->1->4->5","print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\rotate_to_the_right.py","","insert_node","Insert a new node at the end of a linked list and return the new head.  Parameters:     head (Node | None): The head of the linked list.     data (int): The data to be inserted into the new node.  Returns:     Node: The new head of the linked list.  >>> head = insert_node(None, 10) >>> head = insert_node(head, 9) >>> head = insert_node(head, 8) >>> print_linked_list(head) 10->9->8","Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\rotate_to_the_right.py","","rotate_to_the_right","Rotate a linked list to the right by places times.  Parameters:     head: The head of the linked list.     places: The number of places to rotate.  Returns:     Node: The head of the rotated linked list.  >>> rotate_to_the_right(None, places=1) Traceback (most recent call last):     ... ValueError: The linked list is empty. >>> head = insert_node(None, 1) >>> rotate_to_the_right(head, places=1) == head True >>> head = insert_node(None, 1) >>> head = insert_node(head, 2) >>> head = insert_node(head, 3) >>> head = insert_node(head, 4) >>> head = insert_node(head, 5) >>> new_head = rotate_to_the_right(head, places=2) >>> print_linked_list(new_head) 4->5->1->2->3","range, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","Node","","Create and initialize Node class instance. >>> Node(20) Node(20) >>> Node(""Hello, world!"") Node(Hello, world!) >>> Node(None) Node(None) >>> Node(True) Node(True)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","LinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","test_singly_linked_list",">>> test_singly_linked_list()","LinkedList, range, linked_list.insert_head, linked_list.insert_tail, range, linked_list.reverse, linked_list.is_empty, str, linked_list.delete_head, linked_list.delete_tail, linked_list.insert_nth, str, .join, str, .join, linked_list.delete_head, linked_list.delete_nth, linked_list.delete_tail, len, str, .join, all, all, str, .join, len, str, str, str, str, range, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","test_singly_linked_list_2","This section of the test used varying data types for input. >>> test_singly_linked_list_2()","LinkedList, linked_list.delete_head, linked_list.delete_tail, linked_list.delete_nth, linked_list.insert_head, linked_list.insert_tail, linked_list.reverse, Node, Node, linked_list.insert_tail, linked_list.is_empty, str, str, str, str, Node, str, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","main","","testmod, LinkedList, linked_list.insert_head, linked_list.insert_head, print, linked_list.print_list, linked_list.insert_tail, linked_list.insert_tail, print, linked_list.print_list, print, linked_list.delete_head, print, linked_list.delete_tail, print, linked_list.print_list, print, linked_list.reverse, print, linked_list.print_list, print, print, print, print, .strip, print, print, print, .strip, .strip, .strip, .strip, input, input, input, input, input, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__repr__","Get the string representation of this node. >>> Node(10).__repr__() 'Node(10)' >>> repr(Node(10)) 'Node(10)' >>> str(Node(10)) 'Node(10)' >>> Node(10) Node(10)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__init__","Create and initialize LinkedList class instance. >>> linked_list = LinkedList() >>> linked_list.head is None True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__iter__","This function is intended for iterators to access and iterate through data inside linked list. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""tail"") >>> linked_list.insert_tail(""tail_1"") >>> linked_list.insert_tail(""tail_2"") >>> for node in linked_list: # __iter__ used here. ...     node 'tail' 'tail_1' 'tail_2'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__len__","Return length of linked list i.e. number of nodes >>> linked_list = LinkedList() >>> len(linked_list) 0 >>> linked_list.insert_tail(""tail"") >>> len(linked_list) 1 >>> linked_list.insert_head(""head"") >>> len(linked_list) 2 >>> _ = linked_list.delete_tail() >>> len(linked_list) 1 >>> _ = linked_list.delete_head() >>> len(linked_list) 0","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__repr__","String representation/visualization of a Linked Lists >>> linked_list = LinkedList() >>> linked_list.insert_tail(1) >>> linked_list.insert_tail(3) >>> linked_list.__repr__() '1 -> 3' >>> repr(linked_list) '1 -> 3' >>> str(linked_list) '1 -> 3' >>> linked_list.insert_tail(5) >>> f""{linked_list}"" '1 -> 3 -> 5'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__getitem__","Indexing Support. Used to get a node at particular position >>> linked_list = LinkedList() >>> for i in range(0, 10): ...     linked_list.insert_nth(i, i) >>> all(str(linked_list[i]) == str(i) for i in range(0, 10)) True >>> linked_list[-10] Traceback (most recent call last):     ... ValueError: list index out of range. >>> linked_list[len(linked_list)] Traceback (most recent call last):     ... ValueError: list index out of range.","enumerate, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","__setitem__",">>> linked_list = LinkedList() >>> for i in range(0, 10): ...     linked_list.insert_nth(i, i) >>> linked_list[0] = 666 >>> linked_list[0] 666 >>> linked_list[5] = -666 >>> linked_list[5] -666 >>> linked_list[-10] = 666 Traceback (most recent call last):     ... ValueError: list index out of range. >>> linked_list[len(linked_list)] = 666 Traceback (most recent call last):     ... ValueError: list index out of range.","range, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","insert_tail","Insert data to the end of linked list. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""tail"") >>> linked_list tail >>> linked_list.insert_tail(""tail_2"") >>> linked_list tail -> tail_2 >>> linked_list.insert_tail(""tail_3"") >>> linked_list tail -> tail_2 -> tail_3","self.insert_nth, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","insert_head","Insert data to the beginning of linked list. >>> linked_list = LinkedList() >>> linked_list.insert_head(""head"") >>> linked_list head >>> linked_list.insert_head(""head_2"") >>> linked_list head_2 -> head >>> linked_list.insert_head(""head_3"") >>> linked_list head_3 -> head_2 -> head","self.insert_nth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","insert_nth","Insert data at given index. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""first"") >>> linked_list.insert_tail(""second"") >>> linked_list.insert_tail(""third"") >>> linked_list first -> second -> third >>> linked_list.insert_nth(1, ""fourth"") >>> linked_list first -> fourth -> second -> third >>> linked_list.insert_nth(3, ""fifth"") >>> linked_list first -> fourth -> second -> fifth -> third","Node, IndexError, len, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","print_list","This method prints every node data. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""first"") >>> linked_list.insert_tail(""second"") >>> linked_list.insert_tail(""third"") >>> linked_list first -> second -> third","print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","delete_head","Delete the first node and return the node's data. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""first"") >>> linked_list.insert_tail(""second"") >>> linked_list.insert_tail(""third"") >>> linked_list first -> second -> third >>> linked_list.delete_head() 'first' >>> linked_list second -> third >>> linked_list.delete_head() 'second' >>> linked_list third >>> linked_list.delete_head() 'third' >>> linked_list.delete_head() Traceback (most recent call last):     ... IndexError: List index out of range.","self.delete_nth"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","delete_tail","Delete the tail end node and return the node's data. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""first"") >>> linked_list.insert_tail(""second"") >>> linked_list.insert_tail(""third"") >>> linked_list first -> second -> third >>> linked_list.delete_tail() 'third' >>> linked_list first -> second >>> linked_list.delete_tail() 'second' >>> linked_list first >>> linked_list.delete_tail() 'first' >>> linked_list.delete_tail() Traceback (most recent call last):     ... IndexError: List index out of range.","self.delete_nth, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","delete_nth","Delete node at given index and return the node's data. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""first"") >>> linked_list.insert_tail(""second"") >>> linked_list.insert_tail(""third"") >>> linked_list first -> second -> third >>> linked_list.delete_nth(1) # delete middle 'second' >>> linked_list first -> third >>> linked_list.delete_nth(5) # this raises error Traceback (most recent call last):     ... IndexError: List index out of range. >>> linked_list.delete_nth(-1) # this also raises error Traceback (most recent call last):     ... IndexError: List index out of range.","IndexError, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","is_empty","Check if linked list is empty. >>> linked_list = LinkedList() >>> linked_list.is_empty() True >>> linked_list.insert_head(""first"") >>> linked_list.is_empty() False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\singly_linked_list.py","","reverse","This reverses the linked list order. >>> linked_list = LinkedList() >>> linked_list.insert_tail(""first"") >>> linked_list.insert_tail(""second"") >>> linked_list.insert_tail(""third"") >>> linked_list first -> second -> third >>> linked_list.reverse() >>> linked_list third -> second -> first",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","SkipList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_insert","","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_insert_overrides_existing_value","","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, len, print, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_searching_empty_list_returns_none","","SkipList, skip_list.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_search","","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_deleting_item_from_empty_list_do_nothing","","SkipList, skip_list.delete, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_deleted_items_are_not_founded_by_find_method","","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.delete, skip_list.delete, skip_list.find, skip_list.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_delete_removes_only_given_key","","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.delete, skip_list.delete, skip_list.delete, skip_list.delete, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find, skip_list.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_delete_doesnt_leave_dead_nodes","","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.delete, len, set, traverse_keys, traverse_keys"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","test_iter_always_yields_sorted_values","","SkipList, range, is_sorted, skip_list.delete, skip_list.delete, skip_list.delete, is_sorted, skip_list.insert, skip_list.insert, is_sorted, all, skip_list.insert, list, list, list, pairwise"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","pytests","","range, test_insert, test_insert_overrides_existing_value, test_searching_empty_list_returns_none, test_search, test_deleting_item_from_empty_list_do_nothing, test_deleted_items_are_not_founded_by_find_method, test_delete_removes_only_given_key, test_delete_doesnt_leave_dead_nodes, test_iter_always_yields_sorted_values"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","main",">>> pytests()","SkipList, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.insert, skip_list.delete, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","__repr__",":return: Visual representation of Node  >>> node = Node(""Key"", 2) >>> repr(node) 'Node(Key: 2)'",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","level",":return: Number of forward references  >>> node = Node(""Key"", 2) >>> node.level 0 >>> node.forward.append(Node(""Key2"", 4)) >>> node.level 1 >>> node.forward.append(Node(""Key3"", 6)) >>> node.level 2","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","__str__",":return: Visual representation of SkipList  >>> skip_list = SkipList() >>> print(skip_list) SkipList(level=0) >>> skip_list.insert(""Key1"", ""Value"") >>> print(skip_list) # doctest: +ELLIPSIS SkipList(level=... [root]--... [Key1]--Key1... None    *... >>> skip_list.insert(""Key2"", ""OtherValue"") >>> print(skip_list) # doctest: +ELLIPSIS SkipList(level=... [root]--... [Key1]--Key1... [Key2]--Key2... None    *...","list, max, node.forward.copy, lines.append, lines.append, lines.append, len, max, len, lines.append, lines.append, .join, len, .ljust, .ljust, str, len, len, .ljust, .join, len, len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","__iter__","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","random_level",":return: Random level from [1, self.max_level] interval.          Higher values are less likely.","random"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","_locate_node",":param key: Searched key, :return: Tuple with searched node (or None if given key is not present)          and list of nodes that refer (if key is present) of should refer to          given node.","reversed, update_vector.reverse, range, update_vector.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","delete",":param key: Key to remove from list.  >>> skip_list = SkipList() >>> skip_list.insert(2, ""Two"") >>> skip_list.insert(1, ""One"") >>> skip_list.insert(3, ""Three"") >>> list(skip_list) [1, 2, 3] >>> skip_list.delete(2) >>> list(skip_list) [1, 3]","self._locate_node, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","insert",":param key: Key to insert. :param value: Value associated with given key.  >>> skip_list = SkipList() >>> skip_list.insert(2, ""Two"") >>> skip_list.find(2) 'Two' >>> list(skip_list) [2]","self._locate_node, self.random_level, Node, enumerate, range, update_vector.append, new_node.forward.append, update_node.forward.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","find",":param key: Search key. :return: Value associated with given key or None if given key is not present.  >>> skip_list = SkipList() >>> skip_list.find(2) >>> skip_list.insert(2, ""Two"") >>> skip_list.find(2) 'Two' >>> skip_list.insert(2, ""Three"") >>> skip_list.find(2) 'Three'","self._locate_node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","traverse_keys","","traverse_keys"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\skip_list.py","","is_sorted","","all, pairwise"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\swap_nodes.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\swap_nodes.py","LinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\swap_nodes.py","","__iter__",">>> linked_list = LinkedList() >>> list(linked_list) [] >>> linked_list.push(0) >>> tuple(linked_list) (0,)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\swap_nodes.py","","__len__",">>> linked_list = LinkedList() >>> len(linked_list) 0 >>> linked_list.push(0) >>> len(linked_list) 1","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\swap_nodes.py","","push","Add a new node with the given data to the beginning of the Linked List.  Args:     new_data (Any): The data to be added to the new node.  Returns:     None  Examples:     >>> linked_list = LinkedList()     >>> linked_list.push(5)     >>> linked_list.push(4)     >>> linked_list.push(3)     >>> linked_list.push(2)     >>> linked_list.push(1)     >>> list(linked_list)     [1, 2, 3, 4, 5]","Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\swap_nodes.py","","swap_nodes","Swap the positions of two nodes in the Linked List based on their data values.  Args:     node_data_1: Data value of the first node to be swapped.     node_data_2: Data value of the second node to be swapped.   Note:     If either of the specified data values isn't found then, no swapping occurs.  Examples: When both values are present in a linked list.     >>> linked_list = LinkedList()     >>> linked_list.push(5)     >>> linked_list.push(4)     >>> linked_list.push(3)     >>> linked_list.push(2)     >>> linked_list.push(1)     >>> list(linked_list)     [1, 2, 3, 4, 5]     >>> linked_list.swap_nodes(1, 5)     >>> tuple(linked_list)     (5, 2, 3, 4, 1)  When one value is present and the other isn't in the linked list.     >>> second_list = LinkedList()     >>> second_list.push(6)     >>> second_list.push(7)     >>> second_list.push(8)     >>> second_list.push(9)     >>> second_list.swap_nodes(1, 6) is None     True  When both values are absent in the linked list.     >>> second_list = LinkedList()     >>> second_list.push(10)     >>> second_list.push(9)     >>> second_list.push(8)     >>> second_list.push(7)     >>> second_list.swap_nodes(1, 3) is None     True  When linkedlist is empty.     >>> second_list = LinkedList()     >>> second_list.swap_nodes(1, 3) is None     True  Returns:     None",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","LinkedList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","add","Add an item to the LinkedList at the specified position. Default position is 0 (the head).  Args:     item (Any): The item to add to the LinkedList.     position (int, optional): The position at which to add the item.         Defaults to 0.  Raises:     ValueError: If the position is negative or out of bounds.  >>> linked_list = LinkedList() >>> linked_list.add(1) >>> linked_list.add(2) >>> linked_list.add(3) >>> linked_list.add(4, 2) >>> print(linked_list) 3 --> 2 --> 4 --> 1  # Test adding to a negative position >>> linked_list.add(5, -3) Traceback (most recent call last):     ... ValueError: Position must be non-negative  # Test adding to an out-of-bounds position >>> linked_list.add(5,7) Traceback (most recent call last):     ... ValueError: Out of bounds >>> linked_list.add(5, 4) >>> print(linked_list) 3 --> 2 --> 4 --> 1 --> 5","ValueError, Node, range, Node, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","remove","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","is_empty","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","__str__",">>> linked_list = LinkedList() >>> linked_list.add(23) >>> linked_list.add(14) >>> linked_list.add(9) >>> print(linked_list) 9 --> 14 --> 23","self.is_empty, .join, item_list.append, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\linked_list\__init__.py","","__len__",">>> linked_list = LinkedList() >>> len(linked_list) 0 >>> linked_list.add(""a"") >>> len(linked_list) 1 >>> linked_list.add(""b"") >>> len(linked_list) 2 >>> _ = linked_list.remove() >>> len(linked_list) 1 >>> _ = linked_list.remove() >>> len(linked_list) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","CircularQueue","","Circular FIFO queue with a fixed capacity",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","","__len__",">>> cq = CircularQueue(5) >>> len(cq) 0 >>> cq.enqueue(""A"")  # doctest: +ELLIPSIS <data_structures.queues.circular_queue.CircularQueue object at ...> >>> cq.array ['A', None, None, None, None] >>> len(cq) 1",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","","is_empty","Checks whether the queue is empty or not >>> cq = CircularQueue(5) >>> cq.is_empty() True >>> cq.enqueue(""A"").is_empty() False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","","first","Returns the first element of the queue >>> cq = CircularQueue(5) >>> cq.first() False >>> cq.enqueue(""A"").first() 'A'","self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","","enqueue","This function inserts an element at the end of the queue using self.rear value as an index.  >>> cq = CircularQueue(5) >>> cq.enqueue(""A"")  # doctest: +ELLIPSIS <data_structures.queues.circular_queue.CircularQueue object at ...> >>> (cq.size, cq.first()) (1, 'A') >>> cq.enqueue(""B"")  # doctest: +ELLIPSIS <data_structures.queues.circular_queue.CircularQueue object at ...> >>> cq.array ['A', 'B', None, None, None] >>> (cq.size, cq.first()) (2, 'A') >>> cq.enqueue(""C"").enqueue(""D"").enqueue(""E"")  # doctest: +ELLIPSIS <data_structures.queues.circular_queue.CircularQueue object at ...> >>> cq.enqueue(""F"") Traceback (most recent call last):    ... Exception: QUEUE IS FULL","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue.py","","dequeue","This function removes an element from the queue using on self.front value as an index and returns it  >>> cq = CircularQueue(5) >>> cq.dequeue() Traceback (most recent call last):    ... Exception: UNDERFLOW >>> cq.enqueue(""A"").enqueue(""B"").dequeue() 'A' >>> (cq.size, cq.first()) (1, 'B') >>> cq.dequeue() 'B' >>> cq.dequeue() Traceback (most recent call last):    ... Exception: UNDERFLOW","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","CircularQueueLinkedList","","Circular FIFO list with the given capacity (default queue length : 6)  >>> cq = CircularQueueLinkedList(2) >>> cq.enqueue('a') >>> cq.enqueue('b') >>> cq.enqueue('c') Traceback (most recent call last):    ... Exception: Full Queue",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","__init__","","self.create_linked_list"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","create_linked_list","","Node, range, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","is_empty","Checks whether the queue is empty or not >>> cq = CircularQueueLinkedList() >>> cq.is_empty() True >>> cq.enqueue('a') >>> cq.is_empty() False >>> cq.dequeue() 'a' >>> cq.is_empty() True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","first","Returns the first element of the queue >>> cq = CircularQueueLinkedList() >>> cq.first() Traceback (most recent call last):    ... Exception: Empty Queue >>> cq.enqueue('a') >>> cq.first() 'a' >>> cq.dequeue() 'a' >>> cq.first() Traceback (most recent call last):    ... Exception: Empty Queue >>> cq.enqueue('b') >>> cq.enqueue('c') >>> cq.first() 'b'","self.check_can_perform_operation"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","enqueue","Saves data at the end of the queue  >>> cq = CircularQueueLinkedList() >>> cq.enqueue('a') >>> cq.enqueue('b') >>> cq.dequeue() 'a' >>> cq.dequeue() 'b' >>> cq.dequeue() Traceback (most recent call last):    ... Exception: Empty Queue","self.check_is_full, self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","dequeue","Removes and retrieves the first element of the queue  >>> cq = CircularQueueLinkedList() >>> cq.dequeue() Traceback (most recent call last):    ... Exception: Empty Queue >>> cq.enqueue('a') >>> cq.dequeue() 'a' >>> cq.dequeue() Traceback (most recent call last):    ... Exception: Empty Queue","self.check_can_perform_operation"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","check_can_perform_operation","","self.is_empty, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","check_is_full","","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\circular_queue_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","Deque","","Deque data structure. Operations ---------- append(val: Any) -> None appendleft(val: Any) -> None extend(iterable: Iterable) -> None extendleft(iterable: Iterable) -> None pop() -> Any popleft() -> Any Observers --------- is_empty() -> bool Attributes ---------- _front: _Node     front of the deque a.k.a. the first element _back: _Node     back of the element a.k.a. the last element _len: int     the number of nodes",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","_Node","","Representation of a node. Contains a value and a pointer to the next node as well as to the previous one.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","_Iterator","","Helper class for iteration. Will be used to implement iteration. Attributes ---------- _cur: _Node     the current node of the iteration.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__init__","","self.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","append","Adds val to the end of the deque. Time complexity: O(1) >>> our_deque_1 = Deque([1, 2, 3]) >>> our_deque_1.append(4) >>> our_deque_1 [1, 2, 3, 4] >>> our_deque_2 = Deque('ab') >>> our_deque_2.append('c') >>> our_deque_2 ['a', 'b', 'c'] >>> from collections import deque >>> deque_collections_1 = deque([1, 2, 3]) >>> deque_collections_1.append(4) >>> deque_collections_1 deque([1, 2, 3, 4]) >>> deque_collections_2 = deque('ab') >>> deque_collections_2.append('c') >>> deque_collections_2 deque(['a', 'b', 'c']) >>> list(our_deque_1) == list(deque_collections_1) True >>> list(our_deque_2) == list(deque_collections_2) True","self._Node, self.is_empty, self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","appendleft","Adds val to the beginning of the deque. Time complexity: O(1) >>> our_deque_1 = Deque([2, 3]) >>> our_deque_1.appendleft(1) >>> our_deque_1 [1, 2, 3] >>> our_deque_2 = Deque('bc') >>> our_deque_2.appendleft('a') >>> our_deque_2 ['a', 'b', 'c'] >>> from collections import deque >>> deque_collections_1 = deque([2, 3]) >>> deque_collections_1.appendleft(1) >>> deque_collections_1 deque([1, 2, 3]) >>> deque_collections_2 = deque('bc') >>> deque_collections_2.appendleft('a') >>> deque_collections_2 deque(['a', 'b', 'c']) >>> list(our_deque_1) == list(deque_collections_1) True >>> list(our_deque_2) == list(deque_collections_2) True","self._Node, self.is_empty, self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","extend","Appends every value of iterable to the end of the deque. Time complexity: O(n) >>> our_deque_1 = Deque([1, 2, 3]) >>> our_deque_1.extend([4, 5]) >>> our_deque_1 [1, 2, 3, 4, 5] >>> our_deque_2 = Deque('ab') >>> our_deque_2.extend('cd') >>> our_deque_2 ['a', 'b', 'c', 'd'] >>> from collections import deque >>> deque_collections_1 = deque([1, 2, 3]) >>> deque_collections_1.extend([4, 5]) >>> deque_collections_1 deque([1, 2, 3, 4, 5]) >>> deque_collections_2 = deque('ab') >>> deque_collections_2.extend('cd') >>> deque_collections_2 deque(['a', 'b', 'c', 'd']) >>> list(our_deque_1) == list(deque_collections_1) True >>> list(our_deque_2) == list(deque_collections_2) True","self.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","extendleft","Appends every value of iterable to the beginning of the deque. Time complexity: O(n) >>> our_deque_1 = Deque([1, 2, 3]) >>> our_deque_1.extendleft([0, -1]) >>> our_deque_1 [-1, 0, 1, 2, 3] >>> our_deque_2 = Deque('cd') >>> our_deque_2.extendleft('ba') >>> our_deque_2 ['a', 'b', 'c', 'd'] >>> from collections import deque >>> deque_collections_1 = deque([1, 2, 3]) >>> deque_collections_1.extendleft([0, -1]) >>> deque_collections_1 deque([-1, 0, 1, 2, 3]) >>> deque_collections_2 = deque('cd') >>> deque_collections_2.extendleft('ba') >>> deque_collections_2 deque(['a', 'b', 'c', 'd']) >>> list(our_deque_1) == list(deque_collections_1) True >>> list(our_deque_2) == list(deque_collections_2) True","self.appendleft"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","pop","Removes the last element of the deque and returns it. Time complexity: O(1) @returns topop.val: the value of the node to pop. >>> our_deque1 = Deque([1]) >>> our_popped1 = our_deque1.pop() >>> our_popped1 1 >>> our_deque1 []  >>> our_deque2 = Deque([1, 2, 3, 15182]) >>> our_popped2 = our_deque2.pop() >>> our_popped2 15182 >>> our_deque2 [1, 2, 3]  >>> from collections import deque >>> deque_collections = deque([1, 2, 3, 15182]) >>> collections_popped = deque_collections.pop() >>> collections_popped 15182 >>> deque_collections deque([1, 2, 3]) >>> list(our_deque2) == list(deque_collections) True >>> our_popped2 == collections_popped True","self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","popleft","Removes the first element of the deque and returns it. Time complexity: O(1) @returns topop.val: the value of the node to pop. >>> our_deque1 = Deque([1]) >>> our_popped1 = our_deque1.pop() >>> our_popped1 1 >>> our_deque1 [] >>> our_deque2 = Deque([15182, 1, 2, 3]) >>> our_popped2 = our_deque2.popleft() >>> our_popped2 15182 >>> our_deque2 [1, 2, 3] >>> from collections import deque >>> deque_collections = deque([15182, 1, 2, 3]) >>> collections_popped = deque_collections.popleft() >>> collections_popped 15182 >>> deque_collections deque([1, 2, 3]) >>> list(our_deque2) == list(deque_collections) True >>> our_popped2 == collections_popped True","self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","is_empty","Checks if the deque is empty. Time complexity: O(1) >>> our_deque = Deque([1, 2, 3]) >>> our_deque.is_empty() False >>> our_empty_deque = Deque() >>> our_empty_deque.is_empty() True >>> from collections import deque >>> empty_deque_collections = deque() >>> list(our_empty_deque) == list(empty_deque_collections) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__len__","Implements len() function. Returns the length of the deque. Time complexity: O(1) >>> our_deque = Deque([1, 2, 3]) >>> len(our_deque) 3 >>> our_empty_deque = Deque() >>> len(our_empty_deque) 0 >>> from collections import deque >>> deque_collections = deque([1, 2, 3]) >>> len(deque_collections) 3 >>> empty_deque_collections = deque() >>> len(empty_deque_collections) 0 >>> len(our_empty_deque) == len(empty_deque_collections) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__eq__","Implements ""=="" operator. Returns if *self* is equal to *other*. Time complexity: O(n) >>> our_deque_1 = Deque([1, 2, 3]) >>> our_deque_2 = Deque([1, 2, 3]) >>> our_deque_1 == our_deque_2 True >>> our_deque_3 = Deque([1, 2]) >>> our_deque_1 == our_deque_3 False >>> from collections import deque >>> deque_collections_1 = deque([1, 2, 3]) >>> deque_collections_2 = deque([1, 2, 3]) >>> deque_collections_1 == deque_collections_2 True >>> deque_collections_3 = deque([1, 2]) >>> deque_collections_1 == deque_collections_3 False >>> (our_deque_1 == our_deque_2) == (deque_collections_1 == deque_collections_2) True >>> (our_deque_1 == our_deque_3) == (deque_collections_1 == deque_collections_3) True","isinstance, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__iter__","Implements iteration. Time complexity: O(1) >>> our_deque = Deque([1, 2, 3]) >>> for v in our_deque: ...     print(v) 1 2 3 >>> from collections import deque >>> deque_collections = deque([1, 2, 3]) >>> for v in deque_collections: ...     print(v) 1 2 3","Deque._Iterator"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__repr__","Implements representation of the deque. Represents it as a list, with its values between '[' and ']'. Time complexity: O(n) >>> our_deque = Deque([1, 2, 3]) >>> our_deque [1, 2, 3]","values_list.append, .join, repr"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__iter__",">>> our_deque = Deque([1, 2, 3]) >>> iterator = iter(our_deque)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\double_ended_queue.py","","__next__",">>> our_deque = Deque([1, 2, 3]) >>> iterator = iter(our_deque) >>> next(iterator) 1 >>> next(iterator) 2 >>> next(iterator) 3",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","LinkedQueue","",">>> queue = LinkedQueue() >>> queue.is_empty() True >>> queue.put(5) >>> queue.put(9) >>> queue.put('python') >>> queue.is_empty() False >>> queue.get() 5 >>> queue.put('algorithms') >>> queue.get() 9 >>> queue.get() 'python' >>> queue.get() 'algorithms' >>> queue.is_empty() True >>> queue.get() Traceback (most recent call last):     ... IndexError: dequeue from empty queue",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","__len__",">>> queue = LinkedQueue() >>> for i in range(1, 6): ...     queue.put(i) >>> len(queue) 5 >>> for i in range(1, 6): ...     assert len(queue) == 6 - i ...     _ = queue.get() >>> len(queue) 0","len, tuple, iter"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","__str__",">>> queue = LinkedQueue() >>> for i in range(1, 4): ...     queue.put(i) >>> queue.put(""Python"") >>> queue.put(3.14) >>> queue.put(True) >>> str(queue) '1 <- 2 <- 3 <- Python <- 3.14 <- True'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","is_empty",">>> queue = LinkedQueue() >>> queue.is_empty() True >>> for i in range(1, 6): ...     queue.put(i) >>> queue.is_empty() False","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","put",">>> queue = LinkedQueue() >>> queue.get() Traceback (most recent call last):     ... IndexError: dequeue from empty queue >>> for i in range(1, 6): ...     queue.put(i) >>> str(queue) '1 <- 2 <- 3 <- 4 <- 5'","Node, self.is_empty, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","get",">>> queue = LinkedQueue() >>> queue.get() Traceback (most recent call last):     ... IndexError: dequeue from empty queue >>> queue = LinkedQueue() >>> for i in range(1, 6): ...     queue.put(i) >>> for i in range(1, 6): ...     assert queue.get() == i >>> len(queue) 0","self.is_empty, isinstance, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\linked_queue.py","","clear",">>> queue = LinkedQueue() >>> for i in range(1, 6): ...     queue.put(i) >>> queue.clear() >>> len(queue) 0 >>> str(queue) ''",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","OverFlowError","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","UnderFlowError","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","FixedPriorityQueue","","Tasks can be added to a Priority Queue at any time and in any order but when Tasks are removed then the Task with the highest priority is removed in FIFO order.  In code we will use three levels of priority with priority zero Tasks being the most urgent (high priority) and priority 2 tasks being the least urgent.  Examples >>> fpq = FixedPriorityQueue() >>> fpq.enqueue(0, 10) >>> fpq.enqueue(1, 70) >>> fpq.enqueue(0, 100) >>> fpq.enqueue(2, 1) >>> fpq.enqueue(2, 5) >>> fpq.enqueue(1, 7) >>> fpq.enqueue(2, 4) >>> fpq.enqueue(1, 64) >>> fpq.enqueue(0, 128) >>> print(fpq) Priority 0: [10, 100, 128] Priority 1: [70, 7, 64] Priority 2: [1, 5, 4] >>> fpq.dequeue() 10 >>> fpq.dequeue() 100 >>> fpq.dequeue() 128 >>> fpq.dequeue() 70 >>> fpq.dequeue() 7 >>> print(fpq) Priority 0: [] Priority 1: [64] Priority 2: [1, 5, 4] >>> fpq.dequeue() 64 >>> fpq.dequeue() 1 >>> fpq.dequeue() 5 >>> fpq.dequeue() 4 >>> fpq.dequeue() Traceback (most recent call last):     ... data_structures.queues.priority_queue_using_list.UnderFlowError: All queues are empty >>> print(fpq) Priority 0: [] Priority 1: [] Priority 2: []",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","ElementPriorityQueue","","Element Priority Queue is the same as Fixed Priority Queue except that the value of the element itself is the priority. The rules for priorities are the same the as Fixed Priority Queue.  >>> epq = ElementPriorityQueue() >>> epq.enqueue(10) >>> epq.enqueue(70) >>> epq.enqueue(4) >>> epq.enqueue(1) >>> epq.enqueue(5) >>> epq.enqueue(7) >>> epq.enqueue(4) >>> epq.enqueue(64) >>> epq.enqueue(128) >>> print(epq) [10, 70, 4, 1, 5, 7, 4, 64, 128] >>> epq.dequeue() 1 >>> epq.dequeue() 4 >>> epq.dequeue() 4 >>> epq.dequeue() 5 >>> epq.dequeue() 7 >>> epq.dequeue() 10 >>> print(epq) [70, 64, 128] >>> epq.dequeue() 64 >>> epq.dequeue() 70 >>> epq.dequeue() 128 >>> epq.dequeue() Traceback (most recent call last):     ... data_structures.queues.priority_queue_using_list.UnderFlowError: The queue is empty >>> print(epq) []",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","fixed_priority_queue","","FixedPriorityQueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, fpq.enqueue, print, print, print, print, print, print, print, print, print, print, print, print, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue, fpq.dequeue"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","element_priority_queue","","ElementPriorityQueue, epq.enqueue, epq.enqueue, epq.enqueue, epq.enqueue, epq.enqueue, epq.enqueue, epq.enqueue, epq.enqueue, epq.enqueue, print, print, print, print, print, print, print, print, print, print, print, print, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue, epq.dequeue"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","enqueue","Add an element to a queue based on its priority. If the priority is invalid ValueError is raised. If the queue is full an OverFlowError is raised.",".append, len, OverflowError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","dequeue","Return the highest priority element in FIFO order. If the queue is empty then an under flow exception is raised.","UnderFlowError, queue.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","__str__","",".join, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","enqueue","This function enters the element into the queue If the queue is full an Exception is raised saying Over Flow!","self.queue.append, len, OverFlowError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","dequeue","Return the highest priority element in FIFO order. If the queue is empty then an under flow exception is raised.","UnderFlowError, min, self.queue.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\priority_queue_using_list.py","","__str__","Prints all the elements within the Element Priority Queue","str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","QueueByList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","__init__",">>> QueueByList() Queue(()) >>> QueueByList([10, 20, 30]) Queue((10, 20, 30)) >>> QueueByList((i**2 for i in range(1, 4))) Queue((1, 4, 9))","list"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","__len__",">>> len(QueueByList()) 0 >>> from string import ascii_lowercase >>> len(QueueByList(ascii_lowercase)) 26 >>> queue = QueueByList() >>> for i in range(1, 11): ...     queue.put(i) >>> len(queue) 10 >>> for i in range(2): ...   queue.get() 1 2 >>> len(queue) 8","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","__repr__",">>> queue = QueueByList() >>> queue Queue(()) >>> str(queue) 'Queue(())' >>> queue.put(10) >>> queue Queue((10,)) >>> queue.put(20) >>> queue.put(30) >>> queue Queue((10, 20, 30))","tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","put","Put `item` to the Queue  >>> queue = QueueByList() >>> queue.put(10) >>> queue.put(20) >>> len(queue) 2 >>> queue Queue((10, 20))","self.entries.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","get","Get `item` from the Queue  >>> queue = QueueByList((10, 20, 30)) >>> queue.get() 10 >>> queue.put(40) >>> queue.get() 20 >>> queue.get() 30 >>> len(queue) 1 >>> queue.get() 40 >>> queue.get() Traceback (most recent call last):     ... IndexError: Queue is empty","self.entries.pop, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","rotate","Rotate the items of the Queue `rotation` times  >>> queue = QueueByList([10, 20, 30, 40]) >>> queue Queue((10, 20, 30, 40)) >>> queue.rotate(1) >>> queue Queue((20, 30, 40, 10)) >>> queue.rotate(2) >>> queue Queue((40, 10, 20, 30))","range, put, get"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_list.py","","get_front","Get the front item from the Queue  >>> queue = QueueByList((10, 20, 30)) >>> queue.get_front() 10 >>> queue Queue((10, 20, 30)) >>> queue.get() 10 >>> queue.get_front() 20",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_two_stacks.py","QueueByTwoStacks","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_two_stacks.py","","__init__",">>> QueueByTwoStacks() Queue(()) >>> QueueByTwoStacks([10, 20, 30]) Queue((10, 20, 30)) >>> QueueByTwoStacks((i**2 for i in range(1, 4))) Queue((1, 4, 9))","list"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_two_stacks.py","","__len__",">>> len(QueueByTwoStacks()) 0 >>> from string import ascii_lowercase >>> len(QueueByTwoStacks(ascii_lowercase)) 26 >>> queue = QueueByTwoStacks() >>> for i in range(1, 11): ...     queue.put(i) ... >>> len(queue) 10 >>> for i in range(2): ...   queue.get() 1 2 >>> len(queue) 8","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_two_stacks.py","","__repr__",">>> queue = QueueByTwoStacks() >>> queue Queue(()) >>> str(queue) 'Queue(())' >>> queue.put(10) >>> queue Queue((10,)) >>> queue.put(20) >>> queue.put(30) >>> queue Queue((10, 20, 30))","tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_two_stacks.py","","put","Put `item` into the Queue  >>> queue = QueueByTwoStacks() >>> queue.put(10) >>> queue.put(20) >>> len(queue) 2 >>> queue Queue((10, 20))","self._stack1.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_by_two_stacks.py","","get","Get `item` from the Queue  >>> queue = QueueByTwoStacks((10, 20, 30)) >>> queue.get() 10 >>> queue.put(40) >>> queue.get() 20 >>> queue.get() 30 >>> len(queue) 1 >>> queue.get() 40 >>> queue.get() Traceback (most recent call last):     ... IndexError: Queue is empty","self._stack2.pop, IndexError, stack2_append, stack1_pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","Queue","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","__str__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","put","","self.stack.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","get","","self.rotate, self.rotate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","rotate","","range, self.put"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","front","","self.get, self.put, self.rotate"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\queues\queue_on_pseudo_stack.py","","size","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\balanced_parentheses.py","","balanced_parentheses","Use a stack to check if a string of parentheses is balanced. >>> balanced_parentheses(""([]{})"") True >>> balanced_parentheses(""[()]{}{[()()]()}"") True >>> balanced_parentheses(""[(])"") False >>> balanced_parentheses(""1+2*3-4"") True >>> balanced_parentheses("""") True","Stack, stack.is_empty, stack.push, stack.is_empty, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\dijkstras_two_stack_algorithm.py","","dijkstras_two_stack_algorithm","DocTests >>> dijkstras_two_stack_algorithm(""(5 + 3)"") 8 >>> dijkstras_two_stack_algorithm(""((9 - (2 + 9)) + (8 - 1))"") 5 >>> dijkstras_two_stack_algorithm(""((((3 - 2) - (2 + 3)) + (2 - 4)) + 3)"") -3  :param equation: a string :return: result: an integer","Stack, Stack, operand_stack.peek, i.isdigit, operand_stack.push, int, operator_stack.push, operator_stack.peek, operator_stack.pop, operand_stack.peek, operand_stack.pop, operand_stack.peek, operand_stack.pop, , operand_stack.push"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\infix_to_postfix_conversion.py","","precedence","Return integer value representing an operator's precedence, or order of operation. https://en.wikipedia.org/wiki/Order_of_operations","PRECEDENCES.get"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\infix_to_postfix_conversion.py","","associativity","Return the associativity of the operator `char`. https://en.wikipedia.org/wiki/Operator_associativity",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\infix_to_postfix_conversion.py","","infix_to_postfix",">>> infix_to_postfix(""(1*(2+3)+4))"") Traceback (most recent call last):     ... ValueError: Mismatched parentheses >>> infix_to_postfix("""") '' >>> infix_to_postfix(""3+2"") '3 2 +' >>> infix_to_postfix(""(3+4)*5-6"") '3 4 + 5 * 6 -' >>> infix_to_postfix(""(1+2)*3/4-5"") '1 2 + 3 * 4 / 5 -' >>> infix_to_postfix(""a+b*c+(d*e+f)*g"") 'a b c * + d e * f + g * +' >>> infix_to_postfix(""x^y/(5*z)+2"") 'x y ^ 5 z * / 2 +' >>> infix_to_postfix(""2^3^2"") '2 3 2 ^ ^'","Stack, .join, balanced_parentheses, ValueError, stack.is_empty, postfix.append, char.isalpha, char.isdigit, postfix.append, stack.pop, stack.push, stack.pop, postfix.append, stack.is_empty, precedence, precedence, postfix.append, stack.is_empty, stack.peek, stack.pop, stack.push, stack.peek, stack.push, postfix.append, associativity, stack.push, stack.pop, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\infix_to_prefix_conversion.py","","infix_2_postfix",">>> infix_2_postfix(""a+b^c"")  # doctest: +NORMALIZE_WHITESPACE  Symbol  |  Stack  | Postfix ----------------------------    a     |         | a    +     | +       | a    b     | +       | ab    ^     | +^      | ab    c     | +^      | abc          | +       | abc^          |         | abc^+ 'abc^+'  >>> infix_2_postfix(""1*((-a)*2+b)"")   # doctest: +NORMALIZE_WHITESPACE   Symbol  |    Stack     |   Postfix -------------------------------------------    1     |              | 1    *     | *            | 1    (     | *(           | 1    (     | *((          | 1    -     | *((-         | 1    a     | *((-         | 1a    )     | *(           | 1a-    *     | *(*          | 1a-    2     | *(*          | 1a-2    +     | *(+          | 1a-2*    b     | *(+          | 1a-2*b    )     | *            | 1a-2*b+          |              | 1a-2*b+* '1a-2*b+*'  >>> infix_2_postfix("""")  Symbol  |  Stack  | Postfix ---------------------------- ''  >>> infix_2_postfix(""(()"") Traceback (most recent call last):     ... ValueError: invalid expression  >>> infix_2_postfix(""())"") Traceback (most recent call last):     ... IndexError: list index out of range","max, print, print, .join, len, .center, .center, .center, print, len, post_fix.append, print, x.isalpha, x.isdigit, post_fix.append, x.center, .ljust, .ljust, ValueError, stack.pop, .center, .ljust, .ljust, stack.append, stack.pop, .join, .join, .join, .join, len, IndexError, post_fix.append, len, stack.append, stack.append, stack.pop, post_fix.append, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\infix_to_prefix_conversion.py","","infix_2_prefix",">>> infix_2_prefix(""a+b^c"")  # doctest: +NORMALIZE_WHITESPACE  Symbol  |  Stack  | Postfix ----------------------------    c     |         | c    ^     | ^       | c    b     | ^       | cb    +     | +       | cb^    a     | +       | cb^a          |         | cb^a+ '+a^bc'  >>> infix_2_prefix(""1*((-a)*2+b)"") # doctest: +NORMALIZE_WHITESPACE  Symbol  |    Stack     |   Postfix -------------------------------------------    (     | (            |    b     | (            | b    +     | (+           | b    2     | (+           | b2    *     | (+*          | b2    (     | (+*(         | b2    a     | (+*(         | b2a    -     | (+*(-        | b2a    )     | (+*          | b2a-    )     |              | b2a-*+    *     | *            | b2a-*+    1     | *            | b2a-*+1          |              | b2a-*+1* '*1+*-a2b'  >>> infix_2_prefix('')  Symbol  |  Stack  | Postfix ---------------------------- ''  >>> infix_2_prefix('(()') Traceback (most recent call last):     ... IndexError: list index out of range  >>> infix_2_prefix('())') Traceback (most recent call last):     ... ValueError: invalid expression","list, range, len, infix_2_postfix, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\largest_rectangle_histogram.py","","largest_rectangle_area","Inputs an array of integers representing the heights of bars, and returns the area of the largest rectangle that can be formed  >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10  >>> largest_rectangle_area([2, 4]) 4  >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12  >>> largest_rectangle_area([1]) 1","len, range, stack.append, max, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\lexicographical_numbers.py","","lexical_order","Generate numbers in lexical order from 1 to max_number.  >>> "" "".join(map(str, lexical_order(13))) '1 10 11 12 13 2 3 4 5 6 7 8 9' >>> list(lexical_order(1)) [1] >>> "" "".join(map(str, lexical_order(20))) '1 10 11 12 13 14 15 16 17 18 19 2 20 3 4 5 6 7 8 9' >>> "" "".join(map(str, lexical_order(25))) '1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 3 4 5 6 7 8 9' >>> list(lexical_order(12)) [1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9]","stack.pop, stack.append, stack.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\next_greater_element.py","","next_greatest_element_slow","Get the Next Greatest Element (NGE) for each element in the array by checking all subsequent elements to find the next greater one.  This is a brute-force implementation, and it has a time complexity of O(n^2), where n is the size of the array.  Args:     arr: List of numbers for which the NGE is calculated.  Returns:     List containing the next greatest elements. If no     greater element is found, -1 is placed in the result.  Example: >>> next_greatest_element_slow(arr) == expect True","len, range, range, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\next_greater_element.py","","next_greatest_element_fast","Find the Next Greatest Element (NGE) for each element in the array using a more readable approach. This implementation utilizes enumerate() for the outer loop and slicing for the inner loop.  While this improves readability over next_greatest_element_slow(), it still has a time complexity of O(n^2).  Args:     arr: List of numbers for which the NGE is calculated.  Returns:     List containing the next greatest elements. If no     greater element is found, -1 is placed in the result.  Example: >>> next_greatest_element_fast(arr) == expect True","enumerate, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\next_greater_element.py","","next_greatest_element","Efficient solution to find the Next Greatest Element (NGE) for all elements using a stack. The time complexity is reduced to O(n), making it suitable for larger arrays.  The stack keeps track of elements for which the next greater element hasn't been found yet. By iterating through the array in reverse (from the last element to the first), the stack is used to efficiently determine the next greatest element for each element.  Args:     arr: List of numbers for which the NGE is calculated.  Returns:     List containing the next greatest elements. If no     greater element is found, -1 is placed in the result.  Example: >>> next_greatest_element(arr) == expect True","len, reversed, range, stack.append, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\postfix_evaluation.py","","parse_token","Converts the given data to the appropriate number if it is indeed a number, else returns the data as it is with a False flag. This function also serves as a check of whether the input is a number or not.  Parameters ---------- token: The data that needs to be converted to the appropriate operator or number.  Returns ------- float or str     Returns a float if `token` is a number or a str if `token` is an operator","float, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\postfix_evaluation.py","","evaluate","Evaluate postfix expression using a stack. >>> evaluate([""0""]) 0.0 >>> evaluate([""-0""]) -0.0 >>> evaluate([""1""]) 1.0 >>> evaluate([""-1""]) -1.0 >>> evaluate([""-1.1""]) -1.1 >>> evaluate([""2"", ""1"", ""+"", ""3"", ""*""]) 9.0 >>> evaluate([""2"", ""1.9"", ""+"", ""3"", ""*""]) 11.7 >>> evaluate([""2"", ""-1.9"", ""+"", ""3"", ""*""]) 0.30000000000000027 >>> evaluate([""4"", ""13"", ""5"", ""/"", ""+""]) 6.6 >>> evaluate([""2"", ""-"", ""3"", ""+""]) 1.0 >>> evaluate([""-4"", ""5"", ""*"", ""6"", ""-""]) -26.0 >>> evaluate([]) 0 >>> evaluate([""4"", ""-"", ""6"", ""7"", ""/"", ""9"", ""8""]) Traceback (most recent call last): ... ArithmeticError: Input is not a valid postfix expression  Parameters ---------- post_fix:     The postfix expression is tokenized into operators and operands and stored     as a Python list  verbose:     Display stack contents while evaluating the expression if verbose is True  Returns ------- float     The evaluated value","float, parse_token, print, print, stack.pop, stack.pop, stack.append, len, ArithmeticError, .center, .center, stack.append, stack.pop, stack.append, print, print, , print, print, len, print, print, .rjust, .ljust, .rjust, .ljust, .rjust, .ljust, len, .rjust, .ljust, .rjust, .ljust, .rjust, .ljust, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\prefix_evaluation.py","","is_operand","Return True if the given char c is an operand, e.g. it is a number  >>> is_operand(""1"") True >>> is_operand(""+"") False","c.isdigit"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\prefix_evaluation.py","","evaluate","Evaluate a given expression in prefix notation. Asserts that the given expression is valid.  >>> evaluate(""+ 9 * 2 6"") 21 >>> evaluate(""/ * 10 2 + 4 1 "") 4.0 >>> evaluate(""2"") 2 >>> evaluate(""+ * 2 3 / 8 4"") 8.0","stack.pop, expression.split, is_operand, stack.append, stack.pop, stack.pop, stack.append, int, "
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\prefix_evaluation.py","","evaluate_recursive","Alternative recursive implementation  >>> evaluate_recursive(['2']) 2 >>> expression = ['+', '*', '2', '3', '/', '8', '4'] >>> evaluate_recursive(expression) 8.0 >>> expression [] >>> evaluate_recursive(['+', '9', '*', '2', '6']) 21 >>> evaluate_recursive(['/', '*', '10', '2', '+', '4', '1']) 4.0","expression.pop, is_operand, evaluate_recursive, evaluate_recursive, operation, int"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","StackOverflowError","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","StackUnderflowError","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","Stack","","A stack is an abstract data type that serves as a collection of elements with two principal operations: push() and pop(). push() adds an element to the top of the stack, and pop() removes an element from the top of a stack. The order in which elements come off of a stack are Last In, First Out (LIFO). https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","test_stack",">>> test_stack()","Stack, range, bool, stack.is_full, stack.push, bool, stack.is_empty, stack.is_full, str, stack.pop, stack.peek, stack.push, stack.is_empty, str, str, stack.pop, stack.peek, str, str, stack.push, stack.is_empty, stack.size, stack.size, list, range"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","__bool__","","bool"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","__str__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","push","Push an element to the top of the stack.  >>> S = Stack(2) # stack size = 2 >>> S.push(10) >>> S.push(20) >>> print(S) [10, 20]  >>> S = Stack(1) # stack size = 1 >>> S.push(10) >>> S.push(20) Traceback (most recent call last): ... data_structures.stacks.stack.StackOverflowError","self.stack.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","pop","Pop an element off of the top of the stack.  >>> S = Stack() >>> S.push(-5) >>> S.push(10) >>> S.pop() 10  >>> Stack().pop() Traceback (most recent call last):     ... data_structures.stacks.stack.StackUnderflowError","self.stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","peek","Peek at the top-most element of the stack.  >>> S = Stack() >>> S.push(-5) >>> S.push(10) >>> S.peek() 10  >>> Stack().peek() Traceback (most recent call last):     ... data_structures.stacks.stack.StackUnderflowError",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","is_empty","Check if a stack is empty.  >>> S = Stack() >>> S.is_empty() True  >>> S = Stack() >>> S.push(10) >>> S.is_empty() False","bool"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","is_full",">>> S = Stack() >>> S.is_full() False  >>> S = Stack(1) >>> S.push(10) >>> S.is_full() True","self.size"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","size","Return the size of the stack.  >>> S = Stack(3) >>> S.size() 0  >>> S = Stack(3) >>> S.push(10) >>> S.size() 1  >>> S = Stack(3) >>> S.push(10) >>> S.push(20) >>> S.size() 2","len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack.py","","__contains__","Check if item is in stack  >>> S = Stack(3) >>> S.push(10) >>> 10 in S True  >>> S = Stack(3) >>> S.push(10) >>> 20 in S False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_using_two_queues.py","StackWithQueues","","https://www.geeksforgeeks.org/implement-stack-using-queue/  >>> stack = StackWithQueues() >>> stack.push(1) >>> stack.push(2) >>> stack.push(3) >>> stack.peek() 3 >>> stack.pop() 3 >>> stack.peek() 2 >>> stack.pop() 2 >>> stack.pop() 1 >>> stack.peek() is None True >>> stack.pop() Traceback (most recent call last):     ... IndexError: pop from an empty deque",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_using_two_queues.py","","push","","self.temp_queue.append, self.temp_queue.append, self.main_queue.popleft"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_using_two_queues.py","","pop","","self.main_queue.popleft"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_using_two_queues.py","","peek","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","Stack","",">>> stack = Stack() >>> stack.is_empty() True >>> stack.print_stack() stack elements are: >>> for i in range(4): ...     stack.push(i) ... >>> stack.is_empty() False >>> stack.print_stack() stack elements are: 3->2->1->0-> >>> stack.top() 3 >>> len(stack) 4 >>> stack.pop() 3 >>> stack.print_stack() stack elements are: 2->1->0->",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","push","add a Node to the stack","Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","pop","pop the top element off the stack",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","top","return the top element of the stack",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","__len__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","is_empty","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_doubly_linked_list.py","","print_stack","","print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","LinkedStack","","Linked List Stack implementing push (to top), pop (from top) and is_empty  >>> stack = LinkedStack() >>> stack.is_empty() True >>> stack.push(5) >>> stack.push(9) >>> stack.push('python') >>> stack.is_empty() False >>> stack.pop() 'python' >>> stack.push('algorithms') >>> stack.pop() 'algorithms' >>> stack.pop() 9 >>> stack.pop() 5 >>> stack.is_empty() True >>> stack.pop() Traceback (most recent call last):     ... IndexError: pop from empty stack",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","__str__",">>> stack = LinkedStack() >>> stack.push(""c"") >>> stack.push(""b"") >>> stack.push(""a"") >>> str(stack) 'a->b->c'",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","__len__",">>> stack = LinkedStack() >>> len(stack) == 0 True >>> stack.push(""c"") >>> stack.push(""b"") >>> stack.push(""a"") >>> len(stack) == 3 True","len, tuple, iter"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","is_empty",">>> stack = LinkedStack() >>> stack.is_empty() True >>> stack.push(1) >>> stack.is_empty() False",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","push",">>> stack = LinkedStack() >>> stack.push(""Python"") >>> stack.push(""Java"") >>> stack.push(""C"") >>> str(stack) 'C->Java->Python'","Node, self.is_empty"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","pop",">>> stack = LinkedStack() >>> stack.pop() Traceback (most recent call last):     ... IndexError: pop from empty stack >>> stack.push(""c"") >>> stack.push(""b"") >>> stack.push(""a"") >>> stack.pop() == 'a' True >>> stack.pop() == 'b' True >>> stack.pop() == 'c' True","self.is_empty, isinstance, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","peek",">>> stack = LinkedStack() >>> stack.push(""Java"") >>> stack.push(""C"") >>> stack.push(""Python"") >>> stack.peek() 'Python'","self.is_empty, IndexError"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stack_with_singly_linked_list.py","","clear",">>> stack = LinkedStack() >>> stack.push(""Java"") >>> stack.push(""C"") >>> stack.push(""Python"") >>> str(stack) 'Python->C->Java' >>> stack.clear() >>> len(stack) == 0 True",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stock_span_problem.py","","calculate_span","Calculate the span values for a given list of stock prices. Args:     price: List of stock prices. Returns:     List of span values.  >>> calculate_span([10, 4, 5, 90, 120, 80]) [1, 1, 2, 4, 5, 1] >>> calculate_span([100, 50, 60, 70, 80, 90]) [1, 1, 2, 3, 4, 5] >>> calculate_span([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> calculate_span([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> calculate_span([10, 20, 30, 40, 50]) [1, 2, 3, 4, 5] >>> calculate_span([100, 80, 60, 70, 60, 75, 85]) [1, 1, 1, 2, 1, 4, 6]","len, st.append, range, st.append, st.pop, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\stacks\stock_span_problem.py","","print_array","","range, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree.py","SuffixTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree.py","","__init__","Initializes the suffix tree with the given text.  Args:     text (str): The text for which the suffix tree is to be built.","SuffixTreeNode, self.build_suffix_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree.py","","build_suffix_tree","Builds the suffix tree for the given text by adding all suffixes.","len, range, self._add_suffix"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree.py","","_add_suffix","Adds a suffix to the suffix tree.  Args:     suffix (str): The suffix to add.     index (int): The starting index of the suffix in the original text.","SuffixTreeNode, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree.py","","search","Searches for a pattern in the suffix tree.  Args:     pattern (str): The pattern to search for.  Returns:     bool: True if the pattern is found, False otherwise.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree_node.py","SuffixTreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\suffix_tree_node.py","","__init__","Initializes a suffix tree node.  Parameters:     children (dict[str, SuffixTreeNode] | None): The children of this node.     is_end_of_string (bool): Indicates if this node represents                              the end of a string.     start (int | None): The start index of the suffix in the text.     end (int | None): The end index of the suffix in the text.     suffix_link (SuffixTreeNode | None): Link to another suffix tree node.",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\example\example_usage.py","","main","Demonstrate the usage of the SuffixTree class.  - Initializes a SuffixTree with a predefined text. - Defines a list of patterns to search for within the suffix tree. - Searches for each pattern in the suffix tree.  Patterns tested:     - ""ana"" (found) --> True     - ""ban"" (found) --> True     - ""na"" (found) --> True     - ""xyz"" (not found) --> False     - ""mon"" (found) --> True","SuffixTree, suffix_tree.search, print"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","TestSuffixTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","","setUp","Set up the initial conditions for each test.","SuffixTree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","","test_search_existing_patterns","Test searching for patterns that exist in the suffix tree.","self.subTest, self.suffix_tree.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","","test_search_non_existing_patterns","Test searching for patterns that do not exist in the suffix tree.","self.subTest, self.suffix_tree.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","","test_search_empty_pattern","Test searching for an empty pattern.","self.suffix_tree.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","","test_search_full_text","Test searching for the full text.","self.suffix_tree.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\suffix_tree\tests\test_suffix_tree.py","","test_search_substrings","Test searching for substrings of the full text.","self.subTest, self.suffix_tree.search"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","RadixNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","test_trie","",".split, RadixNode, root.insert_many, all, root.delete, root.delete, root.find, root.find, root.find, root.find, root.find, root.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","pytests","","test_trie"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","main",">>> pytests()","RadixNode, .split, root.insert_many, print, print, root.print_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","match","Compute the common substring of the prefix of the node and a word  Args:     word (str): word to compare  Returns:     (str, str, str): common substring, remaining prefix, remaining word  >>> RadixNode(""myprefix"").match(""mystring"") ('my', 'prefix', 'string')","zip"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","insert_many","Insert many words in the tree  Args:     words (list[str]): list of words  >>> RadixNode(""myprefix"").insert_many([""mystring"", ""hello""])","self.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","insert","Insert a word into the tree  Args:     word (str): word to insert  >>> RadixNode(""myprefix"").insert(""mystring"")  >>> root = RadixNode() >>> root.insert_many(['myprefix', 'myprefixA', 'myprefixAA']) >>> root.print_tree() - myprefix   (leaf) -- A   (leaf) --- A   (leaf)","RadixNode, incoming_node.match, .insert, RadixNode, .insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","find","Returns if the word is on the tree  Args:     word (str): word to check  Returns:     bool: True if the word appears on the tree  >>> RadixNode(""myprefix"").find(""mystring"") False","self.nodes.get, incoming_node.match, incoming_node.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","delete","Deletes a word from the tree if it exists  Args:     word (str): word to be deleted  Returns:     bool: True if the word was found and deleted. False if word is not found  >>> RadixNode(""myprefix"").delete(""mystring"") False","self.nodes.get, incoming_node.match, incoming_node.delete, len, next, len, next, len, iter, iter, self.nodes.values, incoming_node.nodes.values"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\radix_tree.py","","print_tree","Print the tree  Args:     height (int, optional): Height of the printed node","self.nodes.values, print, value.print_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","TrieNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","print_words","Prints all the words in a Trie :param node: root node of Trie :param word: Word variable should be empty at start :return: None","node.nodes.items, print, print_words"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","test_trie","",".split, TrieNode, root.insert_many, all, root.find, root.find, root.find, root.delete, root.delete, root.find, root.find, root.find, root.find, root.find, root.find"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","print_results","","print, str"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","pytests","","test_trie"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","main",">>> pytests()","print_results, test_trie"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","insert_many","Inserts a list of words into the Trie :param words: list of string words :return: None","self.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","insert","Inserts a word into the Trie :param word: word to be inserted :return: None","TrieNode"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","find","Tries to find word in a Trie :param word: word to look for :return: Returns True if word is found, False otherwise",""
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","delete","Deletes a word in a Trie :param word: word to delete :return: None","_delete, curr.nodes.get, _delete, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\data_structures\trie\trie.py","","_delete","","curr.nodes.get, _delete, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\change_brightness.py","","change_brightness","Change the brightness of a PIL Image to a given level.","img.point, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\change_brightness.py","","brightness","Fundamental Transformation/Operation that'll be performed on every bit.",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\change_contrast.py","","change_contrast","Function to change contrast","img.point, int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\change_contrast.py","","contrast","Fundamental Transformation/Operation that'll be performed on every bit.","int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\convert_to_negative.py","","convert_to_negative","","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","IndexCalculation","","# Class Summary         This algorithm consists in calculating vegetation indices, these     indices can be used for precision agriculture for example (or remote     sensing). There are functions to define the data and to calculate the     implemented indices.  # Vegetation index     https://en.wikipedia.org/wiki/Vegetation_Index     A Vegetation Index (VI) is a spectral transformation of two or more bands     designed to enhance the contribution of vegetation properties and allow     reliable spatial and temporal inter-comparisons of terrestrial     photosynthetic activity and canopy structural variations  # Information about channels (Wavelength range for each)     * nir - near-infrared         https://www.malvernpanalytical.com/br/products/technology/near-infrared-spectroscopy         Wavelength Range 700 nm to 2500 nm     * Red Edge         https://en.wikipedia.org/wiki/Red_edge         Wavelength Range 680 nm to 730 nm     * red         https://en.wikipedia.org/wiki/Color         Wavelength Range 635 nm to 700 nm     * blue         https://en.wikipedia.org/wiki/Color         Wavelength Range 450 nm to 490 nm     * green         https://en.wikipedia.org/wiki/Color         Wavelength Range 520 nm to 560 nm   # Implemented index list         #""abbreviationOfIndexName"" -- list of channels used          #""ARVI2""            --  red, nir         #""CCCI""             --  red, redEdge, nir         #""CVI""              --  red, green, nir         #""GLI""              --  red, green, blue         #""NDVI""             --  red, nir         #""BNDVI""            --  blue, nir         #""redEdgeNDVI""      --  red, redEdge         #""GNDVI""            --  green, nir         #""GBNDVI""           --  green, blue, nir         #""GRNDVI""           --  red, green, nir         #""RBNDVI""           --  red, blue, nir         #""PNDVI""            --  red, green, blue, nir         #""ATSAVI""           --  red, nir         #""BWDRVI""           --  blue, nir         #""CIgreen""          --  green, nir         #""CIrededge""        --  redEdge, nir         #""CI""               --  red, blue         #""CTVI""             --  red, nir         #""GDVI""             --  green, nir         #""EVI""              --  red, blue, nir         #""GEMI""             --  red, nir         #""GOSAVI""           --  green, nir         #""GSAVI""            --  green, nir         #""Hue""              --  red, green, blue         #""IVI""              --  red, nir         #""IPVI""             --  red, nir         #""I""                --  red, green, blue         #""RVI""              --  red, nir         #""MRVI""             --  red, nir         #""MSAVI""            --  red, nir         #""NormG""            --  red, green, nir         #""NormNIR""          --  red, green, nir         #""NormR""            --  red, green, nir         #""NGRDI""            --  red, green         #""RI""               --  red, green         #""S""                --  red, green, blue         #""IF""               --  red, green, blue         #""DVI""              --  red, nir         #""TVI""              --  red, nir         #""NDRE""               --  redEdge, nir  #list of all index implemented     #allIndex = [""ARVI2"", ""CCCI"", ""CVI"", ""GLI"", ""NDVI"", ""BNDVI"", ""redEdgeNDVI"",                 ""GNDVI"", ""GBNDVI"", ""GRNDVI"", ""RBNDVI"", ""PNDVI"", ""ATSAVI"",                 ""BWDRVI"", ""CIgreen"", ""CIrededge"", ""CI"", ""CTVI"", ""GDVI"", ""EVI"",                 ""GEMI"", ""GOSAVI"", ""GSAVI"", ""Hue"", ""IVI"", ""IPVI"", ""I"", ""RVI"",                 ""MRVI"", ""MSAVI"", ""NormG"", ""NormNIR"", ""NormR"", ""NGRDI"", ""RI"",                 ""S"", ""IF"", ""DVI"", ""TVI"", ""NDRE""]  #list of index with not blue channel     #notBlueIndex = [""ARVI2"", ""CCCI"", ""CVI"", ""NDVI"", ""redEdgeNDVI"", ""GNDVI"",                      ""GRNDVI"", ""ATSAVI"", ""CIgreen"", ""CIrededge"", ""CTVI"", ""GDVI"",                      ""GEMI"", ""GOSAVI"", ""GSAVI"", ""IVI"", ""IPVI"", ""RVI"", ""MRVI"",                      ""MSAVI"", ""NormG"", ""NormNIR"", ""NormR"", ""NGRDI"", ""RI"", ""DVI"",                      ""TVI"", ""NDRE""]  #list of index just with RGB channels     #RGBIndex = [""GLI"", ""CI"", ""Hue"", ""I"", ""NGRDI"", ""RI"", ""S"", ""IF""]",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","__init__","","self.set_matricies"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","set_matricies","",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","calculation","performs the calculation of the index with the values instantiated in the class :str index: abbreviation of index name to perform","self.set_matricies, , print"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","arv12","Atmospherically Resistant Vegetation Index 2 https://www.indexdatabase.de/db/i-single.php?id=396 :return: index     -0.18+1.17*(self.nir-self.red)/(self.nir+self.red)",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ccci","Canopy Chlorophyll Content Index https://www.indexdatabase.de/db/i-single.php?id=224 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","cvi","Chlorophyll vegetation index https://www.indexdatabase.de/db/i-single.php?id=391 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gli","self.green leaf index https://www.indexdatabase.de/db/i-single.php?id=375 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ndvi","Normalized Difference self.nir/self.red Normalized Difference Vegetation Index, Calibrated NDVI - CDVI https://www.indexdatabase.de/db/i-single.php?id=58 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","bndvi","Normalized Difference self.nir/self.blue self.blue-normalized difference vegetation index https://www.indexdatabase.de/db/i-single.php?id=135 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","red_edge_ndvi","Normalized Difference self.rededge/self.red https://www.indexdatabase.de/db/i-single.php?id=235 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gndvi","Normalized Difference self.nir/self.green self.green NDVI https://www.indexdatabase.de/db/i-single.php?id=401 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gbndvi","self.green-self.blue NDVI https://www.indexdatabase.de/db/i-single.php?id=186 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","grndvi","self.green-self.red NDVI https://www.indexdatabase.de/db/i-single.php?id=185 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","rbndvi","self.red-self.blue NDVI https://www.indexdatabase.de/db/i-single.php?id=187 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","pndvi","Pan NDVI https://www.indexdatabase.de/db/i-single.php?id=188 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","atsavi","Adjusted transformed soil-adjusted VI https://www.indexdatabase.de/db/i-single.php?id=209 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","bwdrvi","self.blue-wide dynamic range vegetation index https://www.indexdatabase.de/db/i-single.php?id=136 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ci_green","Chlorophyll Index self.green https://www.indexdatabase.de/db/i-single.php?id=128 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ci_rededge","Chlorophyll Index self.redEdge https://www.indexdatabase.de/db/i-single.php?id=131 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ci","Coloration Index https://www.indexdatabase.de/db/i-single.php?id=11 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ctvi","Corrected Transformed Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=244 :return: index","self.ndvi, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gdvi","Difference self.nir/self.green self.green Difference Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=27 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","evi","Enhanced Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=16 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gemi","Global Environment Monitoring Index https://www.indexdatabase.de/db/i-single.php?id=25 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gosavi","self.green Optimized Soil Adjusted Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=29 mit Y = 0,16 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","gsavi","self.green Soil Adjusted Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=31 mit N = 0,5 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","hue","Hue https://www.indexdatabase.de/db/i-single.php?id=34 :return: index","np.arctan"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ivi","Ideal vegetation index https://www.indexdatabase.de/db/i-single.php?id=276 b=intercept of vegetation line a=soil line slope :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ipvi","Infraself.red percentage vegetation index https://www.indexdatabase.de/db/i-single.php?id=35 :return: index","self.ndvi"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","i","Intensity https://www.indexdatabase.de/db/i-single.php?id=36 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","rvi","Ratio-Vegetation-Index http://www.seos-project.eu/modules/remotesensing/remotesensing-c03-s01-p01.html :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","mrvi","Modified Normalized Difference Vegetation Index RVI https://www.indexdatabase.de/db/i-single.php?id=275 :return: index","self.rvi, self.rvi"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","m_savi","Modified Soil Adjusted Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=44 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","norm_g","Norm G https://www.indexdatabase.de/db/i-single.php?id=50 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","norm_nir","Norm self.nir https://www.indexdatabase.de/db/i-single.php?id=51 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","norm_r","Norm R https://www.indexdatabase.de/db/i-single.php?id=52 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ngrdi","Normalized Difference self.green/self.red Normalized self.green self.red difference index, Visible Atmospherically Resistant Indices self.green (VIself.green) https://www.indexdatabase.de/db/i-single.php?id=390 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ri","Normalized Difference self.red/self.green self.redness Index https://www.indexdatabase.de/db/i-single.php?id=74 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","s","Saturation https://www.indexdatabase.de/db/i-single.php?id=77 :return: index","np.max, np.min, np.max, np.max, np.max, np.min, np.min, np.min"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","_if","Shape Index https://www.indexdatabase.de/db/i-single.php?id=79 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","dvi","Simple Ratio self.nir/self.red Difference Vegetation Index, Vegetation Index Number (VIN) https://www.indexdatabase.de/db/i-single.php?id=12 :return: index",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","tvi","Transformed Vegetation Index https://www.indexdatabase.de/db/i-single.php?id=98 :return: index","self.ndvi"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\index_calculation.py","","ndre","",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\sepia.py","","make_sepia","Function create sepia tone. Source: https://en.wikipedia.org/wiki/Sepia_(color)","range, min, range, int, to_grayscale, normalize, normalize, normalize"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\sepia.py","","to_grayscale","Helper function to create pixel's greyscale representation Src: https://pl.wikipedia.org/wiki/YUV",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\sepia.py","","normalize","Helper function to normalize R/G/B value -> return 255 if value > 255","min"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_convert_to_negative","","cn.convert_to_negative, negative_img.any"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_change_contrast","","Image.open, .startswith, str, cc.change_contrast"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_gen_gaussian_kernel","","canny.gen_gaussian_kernel, resp.all"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_canny","","imread, canny_img.all, canny.canny, canny_array.any"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_gen_gaussian_kernel_filter","",".all, gg.gaussian_filter"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_convolve_filter","","array, .astype, res.any, conv.img_convolve"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_median_filter","",".any, med.median_filter"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_sobel_filter","","sob.sobel_filter, grad.any, theta.any"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_sepia","","sp.make_sepia, sepia.all"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_burkes","","bs.Burkes, burkes.process, burkes.output_img.any, imread"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_nearest_neighbour","","rs.NearestNeighbour, nn.process, nn.output.any, imread"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\test_digital_image_processing.py","","test_local_binary_pattern","","imread, lbp.get_neighbors_pixel, np.zeros, range, lbp_image.any, getenv, range, lbp.local_binary_value"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\dithering\burkes.py","Burkes","","Burke's algorithm is using for converting grayscale image to black and white version Source: Source: https://en.wikipedia.org/wiki/Dither  Note:     * Best results are given with threshold= ~1/2 * max greyscale value.     * This implementation get RGB image and converts it to greyscale in runtime.",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\dithering\burkes.py","","__init__","","int, self.get_greyscale, ValueError, np.ones, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\dithering\burkes.py","","get_greyscale",">>> Burkes.get_greyscale(3, 4, 5) 4.185 >>> Burkes.get_greyscale(0, 0, 0) 0.0 >>> Burkes.get_greyscale(255, 255, 255) 255.0",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\dithering\burkes.py","","process","","range, range, int, int, int, int, int, int, int, int, self.get_greyscale"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\edge_detection\canny.py","","gen_gaussian_kernel","","np.exp, np.square, np.square, np.square"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\edge_detection\canny.py","","suppress_non_maximum","Non-maximum suppression. If the edge strength of the current pixel is the largest compared to the other pixels in the mask with the same direction, the value will be preserved. Otherwise, the value will be suppressed.","np.zeros, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\edge_detection\canny.py","","detect_high_low_threshold","High-Low threshold detection. If an edge pixel's gradient value is higher than the high threshold value, it is marked as a strong edge pixel. If an edge pixel's gradient value is smaller than the high threshold value and larger than the low threshold value, it is marked as a weak edge pixel. If an edge pixel's value is smaller than the low threshold value, it will be suppressed.","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\edge_detection\canny.py","","track_edge","Edge tracking. Usually a weak edge pixel caused from true edges will be connected to a strong edge pixel while noise responses are unconnected. As long as there is one strong edge pixel that is involved in its 8-connected neighborhood, that weak edge point can be identified as one that should be preserved.","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\edge_detection\canny.py","","canny","","img_convolve, sobel_filter, suppress_non_maximum, detect_high_low_threshold, track_edge, gen_gaussian_kernel, np.rad2deg"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\bilateral_filter.py","","vec_gaussian","","math.sqrt, np.exp, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\bilateral_filter.py","","get_slice","",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\bilateral_filter.py","","get_gauss_kernel","","np.zeros, range, vec_gaussian, range, math.sqrt, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\bilateral_filter.py","","bilateral_filter","","np.zeros, get_gauss_kernel, range, range, get_slice, vec_gaussian, np.multiply, np.multiply, np.sum, np.sum"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\bilateral_filter.py","","parse_args","","float, float, int, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\convolve.py","","im2col","","zeros, range, range, ravel"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\convolve.py","","img_convolve","","pad, im2col, ravel, .reshape, dot"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\gabor_filter.py","","gabor_filter_kernel",":param ksize:   The kernelsize of the convolutional filter (ksize x ksize) :param sigma:   standard deviation of the gaussian bell curve :param theta:   The orientation of the normal to the parallel stripes                 of Gabor function. :param lambd:   Wavelength of the sinusoidal component. :param gamma:   The spatial aspect ratio and specifies the ellipticity                 of the support of Gabor function. :param psi:     The phase offset of the sinusoidal function.  >>> gabor_filter_kernel(3, 8, 0, 10, 0, 0).tolist() [[0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046]]","np.zeros, range, range, np.cos, np.sin, np.exp, np.cos"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\gaussian_filter.py","","gen_gaussian_kernel","","exp, square, square, square"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\gaussian_filter.py","","gaussian_filter","","zeros, enumerate, gen_gaussian_kernel, ravel, .astype, product, ravel, range, range, .reshape, dot"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\laplacian_filter.py","","my_laplacian",":param src: the source image, which should be a grayscale or color image. :param ksize: the size of the kernel used to compute the Laplacian filter,               which can be 1, 3, 5, or 7.  >>> my_laplacian(src=np.array([]), ksize=0) Traceback (most recent call last):     ... ValueError: ksize must be in (1, 3, 5, 7)","filter2D, np.array, np.array, np.array, np.array, ValueError, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\local_binary_pattern.py","","get_neighbors_pixel","Comparing local neighborhood pixel value with threshold value of centre pixel. Exception is required when neighborhood value of a center pixel value is null. i.e. values present at boundaries.  :param image: The image we're working with :param x_coordinate: x-coordinate of the  pixel :param y_coordinate: The y coordinate of the pixel :param center: center pixel value :return: The value of the pixel is being returned.","int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\local_binary_pattern.py","","local_binary_value","It takes an image, an x and y coordinate, and returns the decimal value of the local binary patternof the pixel at that coordinate  :param image: the image to be processed :param x_coordinate: x coordinate of the pixel :param y_coordinate: the y coordinate of the pixel :return: The decimal value of the binary value of the pixels around the center pixel.","sum, get_neighbors_pixel, get_neighbors_pixel, get_neighbors_pixel, get_neighbors_pixel, get_neighbors_pixel, get_neighbors_pixel, get_neighbors_pixel, get_neighbors_pixel, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\median_filter.py","","median_filter",":param gray_img: gray image :param mask: mask size :return: image with median filter","int, zeros_like, range, range, ravel, sort, int8, divide, multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\filters\sobel_filter.py","","sobel_filter","","np.array, np.array, np.abs, np.abs, np.sqrt, dst_xy.astype, np.arctan2, img_convolve, img_convolve, np.max, np.max, np.max, np.square, np.square"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\histogram_equalization\histogram_stretch.py","ConstantStretch","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\histogram_equalization\histogram_stretch.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\histogram_equalization\histogram_stretch.py","","stretch","","cv2.imread, copy.deepcopy, plt.hist, np.sum, range, range, cv2.imwrite, self.img.ravel, len, int, self.last_list.append, int, range, int, np.ma.count"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\histogram_equalization\histogram_stretch.py","","plot_histogram","","plt.hist, self.img.ravel"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\histogram_equalization\histogram_stretch.py","","show_image","","cv2.imshow, cv2.imshow, cv2.waitKey, cv2.destroyAllWindows"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\morphological_operations\dilation_operation.py","","rgb_to_gray","Return gray image from rgb image >>> rgb_to_gray(np.array([[[127, 255, 0]]])) array([[187.6453]]) >>> rgb_to_gray(np.array([[[0, 0, 0]]])) array([[0.]]) >>> rgb_to_gray(np.array([[[2, 4, 1]]])) array([[3.0598]]) >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]])) array([[159.0524,  90.0635, 117.6989]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\morphological_operations\dilation_operation.py","","gray_to_binary","Return binary image from gray image >>> gray_to_binary(np.array([[127, 255, 0]])) array([[False,  True, False]]) >>> gray_to_binary(np.array([[0]])) array([[False]]) >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]])) array([[False, False, False]]) >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]])) array([[False,  True, False],        [False,  True, False],        [False,  True, False]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\morphological_operations\dilation_operation.py","","dilation","Return dilated image >>> dilation(np.array([[True, False, True]]), np.array([[0, 1, 0]])) array([[False, False, False]]) >>> dilation(np.array([[False, False, True]]), np.array([[1, 0, 1]])) array([[False, False, False]])","np.zeros_like, np.zeros, range, range, .sum, int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\morphological_operations\erosion_operation.py","","rgb_to_gray","Return gray image from rgb image  >>> rgb_to_gray(np.array([[[127, 255, 0]]])) array([[187.6453]]) >>> rgb_to_gray(np.array([[[0, 0, 0]]])) array([[0.]]) >>> rgb_to_gray(np.array([[[2, 4, 1]]])) array([[3.0598]]) >>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]])) array([[159.0524,  90.0635, 117.6989]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\morphological_operations\erosion_operation.py","","gray_to_binary","Return binary image from gray image  >>> gray_to_binary(np.array([[127, 255, 0]])) array([[False,  True, False]]) >>> gray_to_binary(np.array([[0]])) array([[False]]) >>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]])) array([[False, False, False]]) >>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]])) array([[False,  True, False],        [False,  True, False],        [False,  True, False]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\morphological_operations\erosion_operation.py","","erosion","Return eroded image  >>> erosion(np.array([[True, True, False]]), np.array([[0, 1, 0]])) array([[False, False, False]]) >>> erosion(np.array([[True, False, False]]), np.array([[1, 1, 0]])) array([[False, False, False]])","np.zeros_like, np.zeros, range, range, .sum, int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\resize\resize.py","NearestNeighbour","","Simplest and fastest version of image resizing. Source: https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation",""
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\resize\resize.py","","__init__","","ValueError, np.ones"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\resize\resize.py","","process","","range, range, self.get_x, self.get_y"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\resize\resize.py","","get_x","Get parent X coordinate for destination X :param x: Destination X coordinate :return: Parent X coordinate based on `x ratio` >>> nn = NearestNeighbour(imread(""digital_image_processing/image_data/lena.jpg"", ...                              1), 100, 100) >>> nn.ratio_x = 0.5 >>> nn.get_x(4) 2","int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\resize\resize.py","","get_y","Get parent Y coordinate for destination Y :param y: Destination X coordinate :return: Parent X coordinate based on `y ratio` >>> nn = NearestNeighbour(imread(""digital_image_processing/image_data/lena.jpg"", ...                              1), 100, 100) >>> nn.ratio_y = 0.5 >>> nn.get_y(4) 2","int"
"C:/Users/Joseph Dania/Desktop/python_repo\digital_image_processing\rotation\rotation.py","","get_rotation","Get image rotation :param img: np.ndarray :param pt1: 3x2 list :param pt2: 3x2 list :param rows: columns image shape :param cols: rows image shape :return: np.ndarray","cv2.getAffineTransform, cv2.warpAffine"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\closest_pair_of_points.py","","euclidean_distance_sqr",">>> euclidean_distance_sqr([1,2],[2,4]) 5",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\closest_pair_of_points.py","","column_based_sort",">>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1) [(3, 0), (5, 1), (4, 2)]","sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\closest_pair_of_points.py","","dis_between_closest_pair","brute force approach to find distance between closest pair points  Parameters : points, points_count, min_dis (list(tuple(int, int)), int, int)  Returns : min_dis (float):  distance between closest pair of points  >>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5) 5","float, range, range, euclidean_distance_sqr, min"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\closest_pair_of_points.py","","dis_between_closest_in_strip","closest pair of points in strip  Parameters : points, points_count, min_dis (list(tuple(int, int)), int, int)  Returns : min_dis (float):  distance btw closest pair of points in the strip (< min_dis)  >>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5) 85","float, range, min, range, max, euclidean_distance_sqr, min"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\closest_pair_of_points.py","","closest_pair_of_points_sqr","divide and conquer approach  Parameters : points, points_count (list(tuple(int, int)), int)  Returns : (float):  distance btw closest pair of points  >>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2) 8","closest_pair_of_points_sqr, closest_pair_of_points_sqr, min, dis_between_closest_in_strip, min, dis_between_closest_pair, len, abs, cross_strip.append"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\closest_pair_of_points.py","","closest_pair_of_points",">>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)])) 28.792360097775937","column_based_sort, column_based_sort, closest_pair_of_points_sqr"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","Point","","Defines a 2-d point for use by all convex-hull algorithms.  Parameters ---------- x: an int or a float, the x-coordinate of the 2-d point y: an int or a float, the y-coordinate of the 2-d point  Examples -------- >>> Point(1, 2) (1.0, 2.0) >>> Point(""1"", ""2"") (1.0, 2.0) >>> Point(1, 2) > Point(0, 1) True >>> Point(1, 1) == Point(1, 1) True >>> Point(-0.5, 1) == Point(0.5, 1) False >>> Point(""pi"", ""e"") Traceback (most recent call last):     ... ValueError: could not convert string to float: 'pi'",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","_construct_points","constructs a list of points from an array-like object of numbers  Arguments ---------  list_of_tuples: array-like object of type numbers. Acceptable types so far are lists, tuples and sets.  Returns -------- points: a list where each item is of type Point. This contains only objects which can be converted into a Point.  Examples ------- >>> _construct_points([[1, 1], [2, -1], [0.3, 4]]) [(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)] >>> _construct_points([1, 2]) Ignoring deformed point 1. All points must have at least 2 coordinates. Ignoring deformed point 2. All points must have at least 2 coordinates. [] >>> _construct_points([]) [] >>> _construct_points(None) []","isinstance, points.append, points.append, Point, print"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","_validate_input","validates an input instance before a convex-hull algorithms uses it  Parameters --------- points: array-like, the 2d points to validate before using with a convex-hull algorithm. The elements of points must be either lists, tuples or Points.  Returns ------- points: array_like, an iterable of all well-defined Points constructed passed in.   Exception --------- ValueError: if points is empty or None, or if a wrong data structure like a scalar              is passed  TypeError: if an iterable but non-indexable object (eg. dictionary) is passed.             The exception to this a set which we'll convert to a list before using   Examples ------- >>> _validate_input([[1, 2]]) [(1.0, 2.0)] >>> _validate_input([(1, 2)]) [(1.0, 2.0)] >>> _validate_input([Point(2, 1), Point(-1, 2)]) [(2.0, 1.0), (-1.0, 2.0)] >>> _validate_input([]) Traceback (most recent call last):     ... ValueError: Expecting a list of points but got [] >>> _validate_input(1) Traceback (most recent call last):     ... ValueError: Expecting an iterable object but got an non-iterable type 1","_construct_points, hasattr, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","_det","Computes the sign perpendicular distance of a 2d point c from a line segment ab. The sign indicates the direction of c relative to ab. A Positive value means c is above ab (to the left), while a negative value means c is below ab (to the right). 0 means all three points are on a straight line.  As a side note, 0.5 * abs|det| is the area of triangle abc  Parameters ---------- a: point, the point on the left end of line segment ab b: point, the point on the right end of line segment ab c: point, the point for which the direction and location is desired.  Returns -------- det: float, abs(det) is the distance of c from ab. The sign indicates which side of line segment ab c is. det is computed as (a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)  Examples ---------- >>> _det(Point(1, 1), Point(1, 2), Point(1, 5)) 0.0 >>> _det(Point(0, 0), Point(10, 0), Point(0, 10)) 100.0 >>> _det(Point(0, 0), Point(10, 0), Point(0, -10)) -100.0",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","convex_hull_bf","Constructs the convex hull of a set of 2D points using a brute force algorithm. The algorithm basically considers all combinations of points (i, j) and uses the definition of convexity to determine whether (i, j) is part of the convex hull or not.  (i, j) is part of the convex hull if and only iff there are no points on both sides of the line segment connecting the ij, and there is no point k such that k is on either end of the ij.  Runtime: O(n^3) - definitely horrible  Parameters --------- points: array-like of object of Points, lists or tuples. The set of  2d points for which the convex-hull is needed  Returns ------ convex_set: list, the convex-hull of points sorted in non-decreasing order.  See Also -------- convex_hull_recursive,   Examples  ---------  >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])  [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]  >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])  [(0.0, 0.0), (10.0, 0.0)]  >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],  ...                 [-0.75, 1]])  [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]  >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),  ...                 (2, -1), (2, -4), (1, -3)])  [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]","sorted, len, set, range, sorted, _validate_input, range, range, convex_set.update, _det"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","convex_hull_recursive","Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy The algorithm exploits the geometric properties of the problem by repeatedly partitioning the set of points into smaller hulls, and finding the convex hull of these smaller hulls.  The union of the convex hull from smaller hulls is the solution to the convex hull of the larger problem.  Parameter --------- points: array-like of object of Points, lists or tuples. The set of  2d points for which the convex-hull is needed  Runtime: O(n log n)  Returns ------- convex_set: list, the convex-hull of points sorted in non-decreasing order.  Examples --------- >>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]]) [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)] >>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]]) [(0.0, 0.0), (10.0, 0.0)] >>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1], ...                        [-0.75, 1]]) [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)] >>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3), ...                        (2, -1), (2, -4), (1, -3)]) [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]","sorted, len, range, _construct_hull, _construct_hull, sorted, _validate_input, _det, upper_hull.append, lower_hull.append"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","_construct_hull","Parameters --------- points: list or None, the hull of points from which to choose the next convex-hull     point left: Point, the point to the left  of line segment joining left and right right: The point to the right of the line segment joining left and right convex_set: set, the current convex-hull. The state of convex-set gets updated by     this function  Note ---- For the line segment 'ab', 'a' is on the left and 'b' on the right. but the reverse is true for the line segment 'ba'.  Returns ------- Nothing, only updates the state of convex-set","float, _det, _construct_hull, convex_set.add, _construct_hull, candidate_points.append"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","convex_hull_melkman","Constructs the convex hull of a set of 2D points using the melkman algorithm. The algorithm works by iteratively inserting points of a simple polygonal chain (meaning that no line segments between two consecutive points cross each other). Sorting the points yields such a polygonal chain.  For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html  Runtime: O(n log n) - O(n) if points are already sorted in the input  Parameters --------- points: array-like of object of Points, lists or tuples. The set of 2d points for which the convex-hull is needed  Returns ------ convex_set: list, the convex-hull of points sorted in non-decreasing order.  See Also --------  Examples --------- >>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]]) [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)] >>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]]) [(0.0, 0.0), (10.0, 0.0)] >>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1], ...                 [-0.75, 1]]) [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)] >>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3), ...                 (2, -1), (2, -4), (1, -3)]) [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]","sorted, len, range, range, sorted, _validate_input, _det, convex_hull.insert, convex_hull.append, convex_hull.insert, _det, _det, convex_hull.append, _det, _det, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","main","","convex_hull_bf, convex_hull_recursive, convex_hull_melkman, print"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__init__","","float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__eq__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__ne__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__gt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__ge__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__le__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\convex_hull.py","","__hash__","","hash"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\heaps_algorithm.py","","heaps","Pure python implementation of the Heap's algorithm (recursive version), returning all permutations of a list. >>> heaps([]) [()] >>> heaps([0]) [(0,)] >>> heaps([-1, 1]) [(-1, 1), (1, -1)] >>> heaps([1, 2, 3]) [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)] >>> from itertools import permutations >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3])) True >>> all(sorted(heaps(x)) == sorted(permutations(x)) ...     for x in ([], [0], [-1, 1], [1, 2, 3])) True","generate, len, generate, range, len, tuple, res.append, generate, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\heaps_algorithm.py","","generate","","generate, range, res.append, generate, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\heaps_algorithm_iterative.py","","heaps","Pure python implementation of the iterative Heap's algorithm, returning all permutations of a list. >>> heaps([]) [()] >>> heaps([0]) [(0,)] >>> heaps([-1, 1]) [(-1, 1), (1, -1)] >>> heaps([1, 2, 3]) [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)] >>> from itertools import permutations >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3])) True >>> all(sorted(heaps(x)) == sorted(permutations(x)) ...     for x in ([], [0], [-1, 1], [1, 2, 3])) True","generate, len, res.append, len, tuple, tuple, res.append, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\heaps_algorithm_iterative.py","","generate","","res.append, tuple, res.append, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\inversions.py","","count_inversions_bf","Counts the number of inversions using a naive brute-force algorithm Parameters ---------- arr: arr: array-like, the list containing the items for which the number of inversions is desired. The elements of `arr` must be comparable. Returns ------- num_inversions: The total number of inversions in `arr` Examples ---------  >>> count_inversions_bf([1, 4, 2, 4, 1])  4  >>> count_inversions_bf([1, 1, 2, 4, 4])  0  >>> count_inversions_bf([])  0","len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\inversions.py","","count_inversions_recursive","Counts the number of inversions using a divide-and-conquer algorithm Parameters ----------- arr: array-like, the list containing the items for which the number of inversions is desired. The elements of `arr` must be comparable. Returns ------- C: a sorted copy of `arr`. num_inversions: int, the total number of inversions in 'arr' Examples -------- >>> count_inversions_recursive([1, 4, 2, 4, 1]) ([1, 1, 2, 4, 4], 4) >>> count_inversions_recursive([1, 1, 2, 4, 4]) ([1, 1, 2, 4, 4], 0) >>> count_inversions_recursive([]) ([], 0)","count_inversions_recursive, count_inversions_recursive, _count_cross_inversions, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\inversions.py","","_count_cross_inversions","Counts the inversions across two sorted arrays. And combine the two arrays into one sorted array For all 1<= i<=len(P) and for all 1 <= j <= len(Q), if P[i] > Q[j], then (i, j) is a cross inversion Parameters ---------- P: array-like, sorted in non-decreasing order Q: array-like, sorted in non-decreasing order Returns ------ R: array-like, a sorted array of the elements of `P` and `Q` num_inversion: int, the number of inversions across `P` and `Q` Examples -------- >>> _count_cross_inversions([1, 2, 3], [0, 2, 5]) ([0, 1, 2, 2, 3, 5], 4) >>> _count_cross_inversions([1, 2, 3], [3, 4, 5]) ([1, 2, 3, 3, 4, 5], 0)","len, r.extend, r.extend, len, len, r.append, r.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\inversions.py","","main","","count_inversions_bf, count_inversions_recursive, print, arr_1.sort, count_inversions_bf, count_inversions_recursive, print, count_inversions_bf, count_inversions_recursive, print"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\kth_order_statistic.py","","random_pivot","Choose a random pivot for the list. We can use a more sophisticated algorithm here, such as the median-of-medians algorithm.","choice"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\kth_order_statistic.py","","kth_number","Return the kth smallest number in lst. >>> kth_number([2, 1, 3, 4, 5], 3) 3 >>> kth_number([2, 1, 3, 4, 5], 1) 1 >>> kth_number([2, 1, 3, 4, 5], 5) 5 >>> kth_number([3, 2, 5, 6, 7, 8], 2) 3 >>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4) 43","random_pivot, len, len, kth_number, kth_number, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\max_difference_pair.py","","max_difference","We are given an array A[1..n] of integers, n >= 1. We want to find a pair of indices (i, j) such that 1 <= i <= j <= n and A[j] - A[i] is as large as possible.  Explanation: https://www.geeksforgeeks.org/maximum-difference-between-two-elements/  >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7]) (1, 9)","len, max_difference, max_difference, min, max, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\max_subarray.py","","max_subarray","Solves the maximum subarray problem using divide and conquer. :param arr:     the given array of numbers :param low:     the start index :param high:    the end index :return:        the start index of the maximum subarray, the end index of the                 maximum subarray, and the maximum subarray sum  >>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] >>> max_subarray(nums, 0, len(nums) - 1) (3, 6, 6) >>> nums = [2, 8, 9] >>> max_subarray(nums, 0, len(nums) - 1) (0, 2, 19) >>> nums = [0, 0] >>> max_subarray(nums, 0, len(nums) - 1) (0, 0, 0) >>> nums = [-1.0, 0.0, 1.0] >>> max_subarray(nums, 0, len(nums) - 1) (2, 2, 1.0) >>> nums = [-2, -3, -1, -4, -6] >>> max_subarray(nums, 0, len(nums) - 1) (2, 2, -1) >>> max_subarray([], 0, 0) (None, None, 0)","max_subarray, max_subarray, max_cross_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\max_subarray.py","","max_cross_sum","","range, range, float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\max_subarray.py","","time_max_subarray","","time.time, max_subarray, time.time, randint, range"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\max_subarray.py","","plot_runtimes","","print, zip, plt.plot, plt.xlabel, plt.ylabel, plt.show, time_max_subarray, print"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\mergesort.py","","merge","Helper function for mergesort.  >>> left_half = [-2] >>> right_half = [-1] >>> merge(left_half, right_half) [-2, -1]  >>> left_half = [1,2,3] >>> right_half = [4,5,6] >>> merge(left_half, right_half) [1, 2, 3, 4, 5, 6]  >>> left_half = [-2] >>> right_half = [-1] >>> merge(left_half, right_half) [-2, -1]  >>> left_half = [12, 15] >>> right_half = [13, 14] >>> merge(left_half, right_half) [12, 13, 14, 15]  >>> left_half = [] >>> right_half = [] >>> merge(left_half, right_half) []","len, len, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\mergesort.py","","merge_sort","Returns a list of sorted array elements using merge sort.  >>> from random import shuffle >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200] >>> shuffle(array) >>> merge_sort(array) [-200, -10, -2, 3, 11, 99, 100, 100000]  >>> shuffle(array) >>> merge_sort(array) [-200, -10, -2, 3, 11, 99, 100, 100000]  >>> array = [-200] >>> merge_sort(array) [-200]  >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200] >>> shuffle(array) >>> sorted(array) == merge_sort(array) True  >>> array = [-2] >>> merge_sort(array) [-2]  >>> array = [] >>> merge_sort(array) []  >>> array = [10000000, 1, -1111111111, 101111111112, 9000002] >>> sorted(array) == merge_sort(array) True","merge, len, merge_sort, merge_sort, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\peak.py","","peak","Return the peak value of `lst`. >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1]) 5 >>> peak([1, 10, 9, 8, 7, 6, 5, 4]) 10 >>> peak([1, 9, 8, 7]) 9 >>> peak([1, 2, 3, 4, 5, 6, 7, 0]) 7 >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) 4","len, peak, peak, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\power.py","","actual_power","Function using divide and conquer to calculate a^b. It only works for integer a,b.  :param a: The base of the power operation, an integer. :param b: The exponent of the power operation, a non-negative integer. :return: The result of a^b.  Examples: >>> actual_power(3, 2) 9 >>> actual_power(5, 3) 125 >>> actual_power(2, 5) 32 >>> actual_power(7, 0) 1","actual_power"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\power.py","","power",":param a: The base (integer). :param b: The exponent (integer). :return: The result of a^b, as a float for negative exponents.  >>> power(4,6) 4096 >>> power(2,3) 8 >>> power(-2,3) -8 >>> power(2,-3) 0.125 >>> power(-2,-3) -0.125","actual_power, actual_power"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","default_matrix_multiplication","Multiplication only for 2x2 matrices","Exception, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","matrix_addition","","range, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","matrix_subtraction","","range, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","split_matrix","Given an even length matrix, returns the top_left, top_right, bot_left, bot_right quadrant.  >>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]]) ([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]]) >>> split_matrix([ ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6], ...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6] ... ])  # doctest: +NORMALIZE_WHITESPACE ([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],   [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],   [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],   [8, 4, 1, 6]])","len, Exception, range, range, range, range, len, len, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","matrix_dimensions","","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","print_matrix","","print, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","actual_strassen","Recursive function to calculate the product of two matrices, using the Strassen Algorithm. It only supports square matrices of any size that is a power of 2.","split_matrix, split_matrix, actual_strassen, actual_strassen, actual_strassen, actual_strassen, actual_strassen, actual_strassen, actual_strassen, matrix_addition, matrix_addition, matrix_addition, matrix_subtraction, range, range, matrix_dimensions, default_matrix_multiplication, matrix_subtraction, matrix_addition, matrix_addition, matrix_subtraction, matrix_addition, matrix_addition, matrix_subtraction, matrix_addition, matrix_subtraction, matrix_addition, matrix_subtraction, matrix_subtraction, len, new_matrix.append, len, new_matrix.append, matrix_addition, matrix_addition"
"C:/Users/Joseph Dania/Desktop/python_repo\divide_and_conquer\strassen_matrix_multiplication.py","","strassen",">>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]]) [[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]] >>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]]) [[139, 163], [121, 134], [100, 121]]","matrix_dimensions, matrix_dimensions, max, int, range, actual_strassen, range, Exception, math.pow, matrix_dimensions, matrix_dimensions, math.ceil, range, new_matrix1.append, range, new_matrix2.append, range, final_matrix.pop, math.log2, .append, .append, .pop"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\abbreviation.py","","abbr",">>> abbr(""daBcd"", ""ABC"") True >>> abbr(""dBcd"", ""ABC"") False","len, len, range, range, range, range, .islower, .upper"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\all_construct.py","","all_construct","returns the list containing all the possible combinations a string(`target`) can be constructed from the given list of substrings(`word_bank`)  >>> all_construct(""hello"", [""he"", ""l"", ""o""]) [['he', 'l', 'l', 'o']] >>> all_construct(""purple"",[""purp"",""p"",""ur"",""le"",""purpl""]) [['purp', 'le'], ['p', 'ur', 'p', 'le']]","range, range, len, table.append, len, combination.reverse, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\bitmask.py","AssignmentUsingBitmask","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\bitmask.py","","__init__","","defaultdict, range, len, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\bitmask.py","","count_ways_until","","self.count_ways_until, self.count_ways_until"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\bitmask.py","","count_no_of_ways","","range, self.count_ways_until, len, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\catalan_numbers.py","","catalan_numbers","Return a list of the Catalan number sequence from 0 through `upper_limit`.  >>> catalan_numbers(5) [1, 1, 2, 5, 14, 42] >>> catalan_numbers(2) [1, 1, 2] >>> catalan_numbers(-1) Traceback (most recent call last): ValueError: Limit for the Catalan sequence must be  0","range, ValueError, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\climbing_stairs.py","","climb_stairs","LeetCdoe No.70: Climbing Stairs Distinct ways to climb a number_of_steps staircase where each time you can either climb 1 or 2 steps.  Args:     number_of_steps: number of steps on the staircase  Returns:     Distinct ways to climb a number_of_steps staircase  Raises:     AssertionError: number_of_steps not positive integer  >>> climb_stairs(3) 3 >>> climb_stairs(1) 1 >>> climb_stairs(-7)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... AssertionError: number_of_steps needs to be positive integer, your input -7","range, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\combination_sum_iv.py","","combination_sum_iv","Function checks the all possible combinations, and returns the count of possible combination in exponential Time Complexity.  >>> combination_sum_iv([1,2,5], 5) 9","count_of_possible_combinations, sum, count_of_possible_combinations"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\combination_sum_iv.py","","combination_sum_iv_dp_array","Function checks the all possible combinations, and returns the count of possible combination in O(N^2) Time Complexity as we are using Dynamic programming array here.  >>> combination_sum_iv_dp_array([1,2,5], 5) 9","count_of_possible_combinations_with_dp_array, sum, count_of_possible_combinations_with_dp_array"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\combination_sum_iv.py","","combination_sum_iv_bottom_up","Function checks the all possible combinations with using bottom up approach, and returns the count of possible combination in O(N^2) Time Complexity as we are using Dynamic programming array here.  >>> combination_sum_iv_bottom_up(3, [1,2,5], 5) 9","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\combination_sum_iv.py","","count_of_possible_combinations","","sum, count_of_possible_combinations"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\combination_sum_iv.py","","count_of_possible_combinations_with_dp_array","","sum, count_of_possible_combinations_with_dp_array"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\edit_distance.py","EditDistance","","Use : solver              = EditDistance() editDistanceResult  = solver.solve(firstString, secondString)",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\edit_distance.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\edit_distance.py","","__min_dist_top_down_dp","","self.__min_dist_top_down_dp, self.__min_dist_top_down_dp, self.__min_dist_top_down_dp, self.__min_dist_top_down_dp, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\edit_distance.py","","min_dist_top_down",">>> EditDistance().min_dist_top_down(""intention"", ""execution"") 5 >>> EditDistance().min_dist_top_down(""intention"", """") 9 >>> EditDistance().min_dist_top_down("""", """") 0","self.__min_dist_top_down_dp, range, len, len, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\edit_distance.py","","min_dist_bottom_up",">>> EditDistance().min_dist_bottom_up(""intention"", ""execution"") 5 >>> EditDistance().min_dist_bottom_up(""intention"", """") 9 >>> EditDistance().min_dist_bottom_up("""", """") 0","len, len, range, range, range, range, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\factorial.py","","factorial",">>> factorial(7) 5040 >>> factorial(-1) Traceback (most recent call last):   ... ValueError: Number should not be negative. >>> [factorial(i) for i in range(10)] [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]","ValueError, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fast_fibonacci.py","","fibonacci","return F(n) >>> [fibonacci(i) for i in range(13)] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]","ValueError, _fib"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fast_fibonacci.py","","_fib","","_fib"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fibonacci.py","Fibonacci","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fibonacci.py","","main","","print, Fibonacci, input, print, int, fibonacci.get, print"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fibonacci.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fibonacci.py","","get","Get the Fibonacci number of `index`. If the number does not exist, calculate all missing numbers leading up to the number of `index`.  >>> Fibonacci().get(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> Fibonacci().get(5) [0, 1, 1, 2, 3]","range, self.sequence.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\fizz_buzz.py","","fizz_buzz","| Plays FizzBuzz. | Prints Fizz if number is a multiple of ``3``. | Prints Buzz if its a multiple of ``5``. | Prints FizzBuzz if its a multiple of both ``3`` and ``5`` or ``15``. | Else Prints The Number Itself.  >>> fizz_buzz(1,7) '1 2 Fizz 4 Buzz Fizz 7 ' >>> fizz_buzz(1,0) Traceback (most recent call last):   ... ValueError: Iterations must be done more than 0 times to play FizzBuzz >>> fizz_buzz(-5,5) Traceback (most recent call last):     ... ValueError: starting number must be                          and integer and be more than 0 >>> fizz_buzz(10,-5) Traceback (most recent call last):     ... ValueError: Iterations must be done more than 0 times to play FizzBuzz >>> fizz_buzz(1.5,5) Traceback (most recent call last):     ... ValueError: starting number must be                          and integer and be more than 0 >>> fizz_buzz(1,5.5) Traceback (most recent call last):     ... ValueError: iterations must be defined as integers","isinstance, ValueError, ValueError, ValueError, isinstance, str"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\floyd_warshall.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\floyd_warshall.py","","__init__","","range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\floyd_warshall.py","","add_edge","Adds a directed edge from node u to node v with weight w.  >>> g = Graph(3) >>> g.add_edge(0, 1, 5) >>> g.dp[0][1] 5",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\floyd_warshall.py","","floyd_warshall","Computes the shortest paths between all pairs of nodes using the Floyd-Warshall algorithm.  >>> g = Graph(3) >>> g.add_edge(0, 1, 1) >>> g.add_edge(1, 2, 2) >>> g.floyd_warshall() >>> g.show_min(0, 2) 3 >>> g.show_min(2, 0) inf","range, range, range, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\floyd_warshall.py","","show_min","Returns the minimum distance from node u to node v.  >>> g = Graph(3) >>> g.add_edge(0, 1, 3) >>> g.add_edge(1, 2, 4) >>> g.floyd_warshall() >>> g.show_min(0, 2) 7 >>> g.show_min(1, 0) inf",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\integer_partition.py","","partition",">>> partition(5) 7 >>> partition(7) 15 >>> partition(100) 190569292 >>> partition(1_000) 24061467864032622473692149727991 >>> partition(-7) Traceback (most recent call last):     ... IndexError: list index out of range >>> partition(0) Traceback (most recent call last):     ... IndexError: list assignment index out of range >>> partition(7.8) Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer","range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\iterating_through_submasks.py","","list_of_submasks","Args:     mask : number which shows mask ( always integer > 0, zero does not have any         submasks )  Returns:     all_submasks : the list of submasks of mask (mask s is called submask of mask     m if only bits that were included in original mask are set  Raises:     AssertionError: mask not positive integer  >>> list_of_submasks(15) [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1] >>> list_of_submasks(13) [13, 12, 9, 8, 5, 4, 1] >>> list_of_submasks(-7)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... AssertionError: mask needs to be positive integer, your input -7 >>> list_of_submasks(0)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... AssertionError: mask needs to be positive integer, your input 0","isinstance, all_submasks.append"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\knapsack.py","","mf_knapsack","This code involves the concept of memory functions. Here we solve the subproblems which are needed unlike the below example F is a 2D array with ``-1`` s filled up","mf_knapsack, max, mf_knapsack, mf_knapsack"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\knapsack.py","","knapsack","","range, range, range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\knapsack.py","","knapsack_with_example_solution","Solves the integer weights knapsack problem returns one of the several possible optimal subsets.  Parameters ----------  * `w`: int, the total maximum weight for the given knapsack problem. * `wt`: list, the vector of weights for all items where ``wt[i]`` is the weight    of the ``i``-th item. * `val`: list, the vector of values for all items where ``val[i]`` is the value   of the ``i``-th item  Returns -------  * `optimal_val`: float, the optimal value for the given knapsack problem * `example_optional_set`: set, the indices of one of the optimal subsets   which gave rise to the optimal value.  Examples --------  >>> knapsack_with_example_solution(10, [1, 3, 5, 2], [10, 20, 100, 22]) (142, {2, 3, 4}) >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4, 4]) (8, {3, 4}) >>> knapsack_with_example_solution(6, [4, 3, 2, 3], [3, 2, 4]) Traceback (most recent call last):     ... ValueError: The number of weights must be the same as the number of values. But got 4 weights and 3 values","len, range, knapsack, set, _construct_solution, ValueError, len, ValueError, isinstance, isinstance, isinstance, TypeError, len, type"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\knapsack.py","","_construct_solution","Recursively reconstructs one of the optimal subsets given a filled DP table and the vector of weights  Parameters ----------  * `dp`: list of list, the table of a solved integer weight dynamic programming   problem * `wt`: list or tuple, the vector of weights of the items * `i`: int, the index of the item under consideration * `j`: int, the current possible maximum weight * `optimal_set`: set, the optimal subset so far. This gets modified by the function.  Returns -------  ``None``","_construct_solution, optimal_set.add, _construct_solution"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\k_means_clustering_tensorflow.py","","tf_k_means_cluster","K-Means Clustering using TensorFlow. 'vectors' should be a n*k 2-D NumPy array, where n is the number of vectors of dimensionality k. 'noofclusters' should be an integer.","int, len, list, shuffle, tf.Graph, len, range, graph.as_default, tf.Session, tf.placeholder, tf.placeholder, tf.placeholder, tf.reduce_mean, tf.placeholder, tf.placeholder, tf.sqrt, tf.placeholder, tf.argmin, tf.initialize_all_variables, sess.run, range, sess.run, sess.run, len, tf.Variable, cent_assigns.append, tf.Variable, cluster_assigns.append, tf.reduce_sum, range, range, range, tf.assign, range, tf.assign, tf.pow, len, sess.run, sess.run, sess.run, sess.run, len, tf.sub, sess.run, range, len, sess.run, array, sess.run"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\largest_divisible_subset.py","","largest_divisible_subset","Algorithm to find the biggest subset in the given array such that for any 2 elements x and y in the subset, either x divides y or y divides x. >>> largest_divisible_subset([1, 16, 7, 8, 4]) [16, 8, 4, 1] >>> largest_divisible_subset([1, 2, 3]) [2, 1] >>> largest_divisible_subset([-1, -2, -3]) [-3] >>> largest_divisible_subset([1, 2, 4, 8]) [8, 4, 2, 1] >>> largest_divisible_subset((1, 2, 4, 8)) [8, 4, 2, 1] >>> largest_divisible_subset([1, 1, 1]) [1, 1, 1] >>> largest_divisible_subset([0, 0, 0]) [0, 0, 0] >>> largest_divisible_subset([-1, -1, -1]) [-1, -1, -1] >>> largest_divisible_subset([]) []","sorted, len, list, enumerate, enumerate, range, range, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_common_subsequence.py","","longest_common_subsequence","Finds the longest common subsequence between two strings. Also returns the The subsequence found  Parameters ----------  x: str, one of the strings y: str, the other string  Returns ------- L[m][n]: int, the length of the longest subsequence. Also equal to len(seq) Seq: str, the subsequence found  >>> longest_common_subsequence(""programming"", ""gaming"") (6, 'gaming') >>> longest_common_subsequence(""physics"", ""smartphone"") (2, 'ph') >>> longest_common_subsequence(""computer"", ""food"") (1, 'o') >>> longest_common_subsequence("""", ""abc"")  # One string is empty (0, '') >>> longest_common_subsequence(""abc"", """")  # Other string is empty (0, '') >>> longest_common_subsequence("""", """")  # Both strings are empty (0, '') >>> longest_common_subsequence(""abc"", ""def"")  # No common subsequence (0, '') >>> longest_common_subsequence(""abc"", ""abc"")  # Identical strings (3, 'abc') >>> longest_common_subsequence(""a"", ""a"")  # Single character match (1, 'a') >>> longest_common_subsequence(""a"", ""b"")  # Single character no match (0, '') >>> longest_common_subsequence(""abcdef"", ""ace"")  # Interleaved subsequence (3, 'ace') >>> longest_common_subsequence(""ABCD"", ""ACBD"")  # No repeated characters (3, 'ABD')","len, len, range, range, range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_common_substring.py","","longest_common_substring","Finds the longest common substring between two strings.  >>> longest_common_substring("""", """") '' >>> longest_common_substring(""a"","""") '' >>> longest_common_substring("""", ""a"") '' >>> longest_common_substring(""a"", ""a"") 'a' >>> longest_common_substring(""abcdef"", ""bcd"") 'bcd' >>> longest_common_substring(""abcdef"", ""xabded"") 'ab' >>> longest_common_substring(""GeeksforGeeks"", ""GeeksQuiz"") 'Geeks' >>> longest_common_substring(""abcdxyz"", ""xyzabcd"") 'abcd' >>> longest_common_substring(""zxabcdezy"", ""yzabcdezx"") 'abcdez' >>> longest_common_substring(""OldSite:GeeksforGeeks.org"", ""NewSite:GeeksQuiz.com"") 'Site:Geeks' >>> longest_common_substring(1, 1) Traceback (most recent call last):     ... ValueError: longest_common_substring() takes two strings for inputs","len, len, range, ValueError, range, isinstance, isinstance, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_increasing_subsequence.py","","longest_subsequence","Some examples  >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 41, 60, 80] >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) [1, 2, 3, 9] >>> longest_subsequence([28, 26, 12, 23, 35, 39]) [12, 23, 35, 39] >>> longest_subsequence([9, 8, 7, 6, 5, 7]) [5, 7] >>> longest_subsequence([1, 1, 1]) [1, 1, 1] >>> longest_subsequence([]) []","len, len, len, longest_subsequence, longest_subsequence, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_increasing_subsequence_iterative.py","","longest_subsequence","Some examples  >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9]) [1, 2, 3, 9] >>> longest_subsequence([9, 8, 7, 6, 5, 7]) [7, 7] >>> longest_subsequence([28, 26, 12, 23, 35, 39]) [12, 23, 35, 39] >>> longest_subsequence([1, 1, 1]) [1, 1, 1] >>> longest_subsequence([]) []","len, range, range, range, longest_increasing_subsequence.append, range, len, len, copy.copy, .append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_increasing_subsequence_o_nlogn.py","","ceil_index","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_increasing_subsequence_o_nlogn.py","","longest_increasing_subsequence_length",">>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6]) 6 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, ...                                     3, 11, 7, 15]) 6 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1","range, len, len, len, ceil_index"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\longest_palindromic_subsequence.py","","longest_palindromic_subsequence","This function returns the longest palindromic subsequence in a string >>> longest_palindromic_subsequence(""bbbab"") 4 >>> longest_palindromic_subsequence(""bbabcbcab"") 7","len, len, range, range, range, range, range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_multiplication.py","","matrix_chain_multiply","Find the minimum number of multiplcations required to multiply the chain of matrices  Args:     `arr`: The input array of integers.  Returns:     Minimum number of multiplications needed to multiply the chain  Examples:  >>> matrix_chain_multiply([1, 2, 3, 4, 3]) 30 >>> matrix_chain_multiply([10]) 0 >>> matrix_chain_multiply([10, 20]) 0 >>> matrix_chain_multiply([19, 2, 19]) 722 >>> matrix_chain_multiply(list(range(1, 100))) 323398 >>> # matrix_chain_multiply(list(range(1, 251))) # 2626798","len, range, len, range, range, range, range, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_multiplication.py","","matrix_chain_order","Source: https://en.wikipedia.org/wiki/Matrix_chain_multiplication  The dynamic programming solution is faster than cached the recursive solution and can handle larger inputs.  >>> matrix_chain_order([1, 2, 3, 4, 3]) 30 >>> matrix_chain_order([10]) 0 >>> matrix_chain_order([10, 20]) 0 >>> matrix_chain_order([19, 2, 19]) 722 >>> matrix_chain_order(list(range(1, 100))) 323398 >>> # matrix_chain_order(list(range(1, 251)))  # Max before RecursionError is raised # 2626798","a, min, len, a, range, a"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_multiplication.py","","elapsed_time","","perf_counter_ns, print, perf_counter_ns"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_multiplication.py","","a","","min, a, range, a"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_order.py","","matrix_chain_order",">>> matrix_chain_order([10, 30, 5]) ([[0, 0, 0], [0, 0, 1500], [0, 0, 0]], [[0, 0, 0], [0, 0, 1], [0, 0, 0]])","len, range, range, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_order.py","","print_optimal_solution","Print order of matrix with Ai as Matrix.","print, print, print_optimal_solution, print_optimal_solution, print, str"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\matrix_chain_order.py","","main","Size of matrix created from array [30, 35, 15, 5, 10, 20, 25] will be: 30*35 35*15 15*5 5*10 10*20 20*25","len, matrix_chain_order, print, print_optimal_solution, str"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\max_non_adjacent_sum.py","","maximum_non_adjacent_sum","Find the maximum non-adjacent sum of the integers in the nums input list  >>> maximum_non_adjacent_sum([1, 2, 3]) 4 >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6]) 18 >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6]) 0 >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6]) 500","max, max"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\max_product_subarray.py","","max_product_subarray","Returns the maximum product that can be obtained by multiplying a contiguous subarray of the given integer list `numbers`.  Example:  >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray((-2, 0, -1)) 0 >>> max_product_subarray([2, 3, -2, 4, -1]) 48 >>> max_product_subarray([-1]) -1 >>> max_product_subarray([0]) 0 >>> max_product_subarray([]) 0 >>> max_product_subarray("""") 0 >>> max_product_subarray(None) 0 >>> max_product_subarray([2, 3, -2, 4.5, -1]) Traceback (most recent call last):     ... ValueError: numbers must be an iterable of integers >>> max_product_subarray(""ABC"") Traceback (most recent call last):     ... ValueError: numbers must be an iterable of integers","range, ValueError, len, max, min, max, isinstance, all, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\max_subarray_sum.py","","max_subarray_sum","Solves the maximum subarray sum problem using Kadane's algorithm. :param arr: the given array of numbers :param allow_empty_subarrays: if True, then the algorithm considers empty subarrays  >>> max_subarray_sum([2, 8, 9]) 19 >>> max_subarray_sum([0, 0]) 0 >>> max_subarray_sum([-1.0, 0.0, 1.0]) 1.0 >>> max_subarray_sum([1, 2, 3, 4, -2]) 10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([2, 3, -9, 8, -2]) 8 >>> max_subarray_sum([-2, -3, -1, -4, -6]) -1 >>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True) 0 >>> max_subarray_sum([]) 0","float, max, max"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_coin_change.py","","dp_count",">>> dp_count([1, 2, 3], 4) 4 >>> dp_count([1, 2, 3], 7) 8 >>> dp_count([2, 5, 3, 6], 10) 5 >>> dp_count([10], 99) 0 >>> dp_count([4, 5, 6], 0) 1 >>> dp_count([1, 2, 3], -5) 0","range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_cost_path.py","","minimum_cost_path","Find the minimum cost traced by all possible paths from top left to bottom right in a given matrix  >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]]) 6  >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]]) 7","range, range, range, len, len, len, range, len, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_partition.py","","find_min",">>> find_min([1, 2, 3, 4, 5]) 1 >>> find_min([5, 5, 5, 5, 5]) 5 >>> find_min([5, 5, 5, 5]) 0 >>> find_min([3]) 3 >>> find_min([]) 0 >>> find_min([1, 2, 3, 4]) 0 >>> find_min([0, 0, 0, 0]) 0 >>> find_min([-1, -5, 5, 1]) 0 >>> find_min([-1, -5, 5, 1]) 0 >>> find_min([9, 9, 9, 9, 9]) 9 >>> find_min([1, 5, 10, 3]) 1 >>> find_min([-1, 0, 1]) 0 >>> find_min(range(10, 0, -1)) 1 >>> find_min([-1]) Traceback (most recent call last):     -- IndexError: list assignment index out of range >>> find_min([0, 0, 0, 1, 2, -4]) Traceback (most recent call last):     ... IndexError: list assignment index out of range >>> find_min([-1, -5, -10, -3]) Traceback (most recent call last):     ... IndexError: list assignment index out of range","len, sum, range, range, range, range, range, int, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_size_subarray_sum.py","","minimum_subarray_sum","Return the length of the shortest contiguous subarray in a list of numbers whose sum is at least target.  Reference: https://stackoverflow.com/questions/8269916  >>> minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3]) 2 >>> minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3]) 4 >>> minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1]) 0 >>> minimum_subarray_sum(10, [1, 2, 3, 4, 5, 6, 7]) 2 >>> minimum_subarray_sum(5, [1, 1, 1, 1, 1, 5]) 1 >>> minimum_subarray_sum(0, []) 0 >>> minimum_subarray_sum(0, [1, 2, 3]) 1 >>> minimum_subarray_sum(10, [10, 20, 30]) 1 >>> minimum_subarray_sum(7, [1, 1, 1, 1, 1, 1, 10]) 1 >>> minimum_subarray_sum(6, []) 0 >>> minimum_subarray_sum(2, [1, 2, 3]) 1 >>> minimum_subarray_sum(-6, []) 0 >>> minimum_subarray_sum(-6, [3, 4, 5]) 1 >>> minimum_subarray_sum(8, None) 0 >>> minimum_subarray_sum(2, ""ABC"") Traceback (most recent call last):     ... ValueError: numbers must be an iterable of integers","ValueError, len, isinstance, all, min, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_squares_to_represent_a_number.py","","minimum_squares_to_represent_a_number","Count the number of minimum squares to represent a number  >>> minimum_squares_to_represent_a_number(25) 1 >>> minimum_squares_to_represent_a_number(37) 2 >>> minimum_squares_to_represent_a_number(21) 3 >>> minimum_squares_to_represent_a_number(58) 2 >>> minimum_squares_to_represent_a_number(-1) Traceback (most recent call last):     ... ValueError: the value of input must not be a negative number >>> minimum_squares_to_represent_a_number(0) 1 >>> minimum_squares_to_represent_a_number(12.34) Traceback (most recent call last):     ... ValueError: the value of input must be a natural number","range, int, ValueError, ValueError, int, range, math.sqrt, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_steps_to_one.py","","min_steps_to_one","Minimum steps to 1 implemented using tabulation. >>> min_steps_to_one(10) 3 >>> min_steps_to_one(15) 4 >>> min_steps_to_one(6) 2  :param number: :return int:","range, ValueError, min, min, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_tickets_cost.py","","mincost_tickets",">>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15]) 11  >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15]) 17  >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150]) 24  >>> mincost_tickets([2], [2, 90, 150]) 2  >>> mincost_tickets([], [2, 90, 150]) 0  >>> mincost_tickets('hello', [2, 90, 150]) Traceback (most recent call last):  ... ValueError: The parameter days should be a list of integers  >>> mincost_tickets([], 'world') Traceback (most recent call last):  ... ValueError: The parameter costs should be a list of three integers  >>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150]) Traceback (most recent call last):  ... ValueError: The parameter days should be a list of integers  >>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150]) Traceback (most recent call last):  ... ValueError: The parameter costs should be a list of three integers  >>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150]) Traceback (most recent call last):  ... ValueError: All days elements should be greater than 0  >>> mincost_tickets([2, 367], [2, 90, 150]) Traceback (most recent call last):  ... ValueError: All days elements should be less than 366  >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], []) Traceback (most recent call last):  ... ValueError: The parameter costs should be a list of three integers  >>> mincost_tickets([], []) Traceback (most recent call last):  ... ValueError: The parameter costs should be a list of three integers  >>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4]) Traceback (most recent call last):  ... ValueError: The parameter costs should be a list of three integers","set, dynamic_programming, ValueError, ValueError, len, min, ValueError, max, ValueError, min, isinstance, all, len, all, dynamic_programming, dynamic_programming, dynamic_programming, dynamic_programming, isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\minimum_tickets_cost.py","","dynamic_programming","","min, dynamic_programming, dynamic_programming, dynamic_programming, dynamic_programming"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\min_distance_up_bottom.py","","min_distance_up_bottom",">>> min_distance_up_bottom(""intention"", ""execution"") 5 >>> min_distance_up_bottom(""intention"", """") 9 >>> min_distance_up_bottom("""", """") 0 >>> min_distance_up_bottom(""zooicoarchaeologist"", ""zoologist"") 10","len, len, min_distance, int, min, min_distance, min_distance, min_distance"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\min_distance_up_bottom.py","","min_distance","","int, min, min_distance, min_distance, min_distance"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\optimal_binary_search_tree.py","Node","","Binary Search Tree Node",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\optimal_binary_search_tree.py","","print_binary_search_tree","Recursive function to print a BST from a root table.  >>> key = [3, 8, 9, 10, 17, 21] >>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3],                 [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]] >>> print_binary_search_tree(root, key, 0, 5, -1, False) 8 is the root of the binary search tree. 3 is the left child of key 8. 10 is the right child of key 8. 9 is the left child of key 10. 21 is the right child of key 10. 17 is the left child of key 21.","print_binary_search_tree, print_binary_search_tree, print, print, print, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\optimal_binary_search_tree.py","","find_optimal_binary_search_tree","This function calculates and prints the optimal binary search tree. The dynamic programming algorithm below runs in O(n^2) time. Implemented from CLRS (Introduction to Algorithms) book. https://en.wikipedia.org/wiki/Introduction_to_Algorithms  >>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50),                                          Node(42, 3), Node(25, 40), Node(37, 30)]) Binary search tree nodes: Node(key=10, freq=34) Node(key=12, freq=8) Node(key=20, freq=50) Node(key=25, freq=40) Node(key=37, freq=30) Node(key=42, freq=3) <BLANKLINE> The cost of optimal BST for given tree nodes is 324. 20 is the root of the binary search tree. 10 is the left child of key 20. 12 is the right child of key 10. 25 is the right child of key 20. 37 is the right child of key 25. 42 is the right child of key 37.","nodes.sort, len, range, print, print, print_binary_search_tree, range, print, range, range, range, range, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\optimal_binary_search_tree.py","","main","","find_optimal_binary_search_tree, Node, randint, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\optimal_binary_search_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\optimal_binary_search_tree.py","","__str__",">>> str(Node(1, 2)) 'Node(key=1, freq=2)'",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\palindrome_partitioning.py","","find_minimum_partitions","Returns the minimum cuts needed for a palindrome partitioning of string  >>> find_minimum_partitions(""aab"") 1 >>> find_minimum_partitions(""aaa"") 0 >>> find_minimum_partitions(""ababbbabbababa"") 3","len, enumerate, range, range, range, min"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\range_sum_query.py","","prefix_sum",">>> prefix_sum([1, 4, 6, 2, 61, 12], [(2, 5), (1, 5), (3, 4)]) [81, 85, 63] >>> prefix_sum([4, 2, 1, 6, 3], [(3, 4), (1, 3), (0, 2)]) [9, 9, 7]","range, len, len, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\regex_match.py","","recursive_match","Recursive matching algorithm.  | Time complexity: O(2^(\|text\| + \|pattern\|)) | Space complexity: Recursion depth is O(\|text\| + \|pattern\|).  :param text: Text to match. :param pattern: Pattern to match. :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.  >>> recursive_match('abc', 'a.c') True >>> recursive_match('abc', 'af*.c') True >>> recursive_match('abc', 'a.c*') True >>> recursive_match('abc', 'a.c*d') False >>> recursive_match('aa', '.*') True","recursive_match, recursive_match, recursive_match, recursive_match"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\regex_match.py","","dp_match","Dynamic programming matching algorithm.  | Time complexity: O(\|text\| * \|pattern\|) | Space complexity: O(\|text\| * \|pattern\|)  :param text: Text to match. :param pattern: Pattern to match. :return: ``True`` if `text` matches `pattern`, ``False`` otherwise.  >>> dp_match('abc', 'a.c') True >>> dp_match('abc', 'af*.c') True >>> dp_match('abc', 'a.c*') True >>> dp_match('abc', 'a.c*d') False >>> dp_match('aa', '.*') True","len, len, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\rod_cutting.py","","naive_cut_rod_recursive","Solves the rod-cutting problem via naively without using the benefit of dynamic programming. The results is the same sub-problems are solved several times leading to an exponential runtime  Runtime: O(2^n)  Arguments ---------  * `n`: int, the length of the rod * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the   price for a rod of length ``i``  Returns -------  The maximum revenue obtainable for a rod of length `n` given the list of prices for each piece.  Examples --------  >>> naive_cut_rod_recursive(4, [1, 5, 8, 9]) 10 >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30]) 30","_enforce_args, float, range, max, naive_cut_rod_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\rod_cutting.py","","top_down_cut_rod","Constructs a top-down dynamic programming solution for the rod-cutting problem via memoization. This function serves as a wrapper for ``_top_down_cut_rod_recursive``  Runtime: O(n^2)  Arguments ---------  * `n`: int, the length of the rod * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the   price for a rod of length ``i``  .. note::   For convenience and because Python's lists using ``0``-indexing, ``length(max_rev)   = n + 1``, to accommodate for the revenue obtainable from a rod of length ``0``.  Returns -------  The maximum revenue obtainable for a rod of length `n` given the list of prices for each piece.  Examples --------  >>> top_down_cut_rod(4, [1, 5, 8, 9]) 10 >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30]) 30","_enforce_args, _top_down_cut_rod_recursive, float, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\rod_cutting.py","","_top_down_cut_rod_recursive","Constructs a top-down dynamic programming solution for the rod-cutting problem via memoization.  Runtime: O(n^2)  Arguments ---------  * `n`: int, the length of the rod * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the   price for a rod of length ``i`` * `max_rev`: list, the computed maximum revenue for a piece of rod.   ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``  Returns -------  The maximum revenue obtainable for a rod of length `n` given the list of prices for each piece.","float, range, max, _top_down_cut_rod_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\rod_cutting.py","","bottom_up_cut_rod","Constructs a bottom-up dynamic programming solution for the rod-cutting problem  Runtime: O(n^2)  Arguments ---------  * `n`: int, the maximum length of the rod. * `prices`: list, the prices for each piece of rod. ``p[i-i]`` is the   price for a rod of length ``i``  Returns -------  The maximum revenue obtainable from cutting a rod of length `n` given the prices for each piece of rod p.  Examples --------  >>> bottom_up_cut_rod(4, [1, 5, 8, 9]) 10 >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30]) 30","_enforce_args, range, float, range, range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\rod_cutting.py","","_enforce_args","Basic checks on the arguments to the rod-cutting algorithms  * `n`: int, the length of the rod * `prices`: list, the price list for each piece of rod.  Throws ``ValueError``:     if `n` is negative or there are fewer items in the price list than the length of     the rod","ValueError, len, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\rod_cutting.py","","main","","len, top_down_cut_rod, bottom_up_cut_rod, naive_cut_rod_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\smith_waterman.py","","score_function","Calculate the score for a character pair based on whether they match or mismatch. Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the characters is a gap. >>> score_function('A', 'A') 1 >>> score_function('A', 'C') -1 >>> score_function('-', 'A') -2 >>> score_function('A', '-') -2 >>> score_function('-', '-') -2",""
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\smith_waterman.py","","smith_waterman","Perform the Smith-Waterman local sequence alignment algorithm. Returns a 2D list representing the score matrix. Each value in the matrix corresponds to the score of the best local alignment ending at that point. >>> smith_waterman('ACAC', 'CA') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]] >>> smith_waterman('acac', 'ca') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]] >>> smith_waterman('ACAC', 'ca') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]] >>> smith_waterman('acac', 'CA') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]] >>> smith_waterman('ACAC', '') [[0], [0], [0], [0], [0]] >>> smith_waterman('', 'CA') [[0, 0, 0]] >>> smith_waterman('ACAC', 'CA') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]  >>> smith_waterman('acac', 'ca') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]  >>> smith_waterman('ACAC', 'ca') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]  >>> smith_waterman('acac', 'CA') [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]  >>> smith_waterman('ACAC', '') [[0], [0], [0], [0], [0]]  >>> smith_waterman('', 'CA') [[0, 0, 0]]  >>> smith_waterman('AGT', 'AGT') [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]  >>> smith_waterman('AGT', 'GTA') [[0, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 2, 0]]  >>> smith_waterman('AGT', 'GTC') [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0]]  >>> smith_waterman('AGT', 'G') [[0, 0], [0, 0], [0, 1], [0, 0]]  >>> smith_waterman('G', 'AGT') [[0, 0, 0, 0], [0, 0, 1, 0]]  >>> smith_waterman('AGT', 'AGTCT') [[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 1, 1]]  >>> smith_waterman('AGTCT', 'AGT') [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 1]]  >>> smith_waterman('AGTCT', 'GTC') [[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 1, 1]]","query.upper, subject.upper, len, len, range, range, range, max, score_function"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\smith_waterman.py","","traceback","Perform traceback to find the optimal local alignment. Starts from the highest scoring cell in the matrix and traces back recursively until a 0 score is found. Returns the alignment strings. >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'CA') 'CA\nCA' >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'ca') 'CA\nCA' >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'ca') 'CA\nCA' >>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'CA') 'CA\nCA' >>> traceback([[0, 0, 0]], 'ACAC', '') ''","query.upper, subject.upper, float, enumerate, score_function, enumerate, score_function"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\subset_generation.py","","subset_combinations","Compute n-element combinations from a given list using dynamic programming.  Args:     * `elements`: The list of elements from which combinations will be generated.     * `n`: The number of elements in each combination.  Returns:     A list of tuples, each representing a combination of `n` elements.  >>> subset_combinations(elements=[10, 20, 30, 40], n=2) [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)] >>> subset_combinations(elements=[1, 2, 3], n=1) [(1,), (2,), (3,)] >>> subset_combinations(elements=[1, 2, 3], n=3) [(1, 2, 3)] >>> subset_combinations(elements=[42], n=1) [(42,)] >>> subset_combinations(elements=[6, 7, 8, 9], n=4) [(6, 7, 8, 9)] >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0) [()] >>> subset_combinations(elements=[1, 2, 3, 4], n=2) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> subset_combinations(elements=[1, 'apple', 3.14], n=2) [(1, 'apple'), (1, 3.14), ('apple', 3.14)] >>> subset_combinations(elements=['single'], n=0) [()] >>> subset_combinations(elements=[], n=9) [] >>> from itertools import combinations >>> all(subset_combinations(items, n) == list(combinations(items, n)) ...     for items, n in ( ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1), ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2), ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9))) True","len, .append, range, range, sorted, range, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\sum_of_subset.py","","is_sum_subset",">>> is_sum_subset([2, 4, 6, 8], 5) False >>> is_sum_subset([2, 4, 6, 8], 14) True","len, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\trapped_water.py","","trapped_rainwater","The trapped_rainwater function calculates the total amount of rainwater that can be trapped given an array of bar heights. It uses a dynamic programming approach, determining the maximum height of bars on both sides for each bar, and then computing the trapped water above each bar. The function returns the total trapped water.  >>> trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1)) 6 >>> trapped_rainwater((7, 1, 5, 3, 6, 4)) 9 >>> trapped_rainwater((7, 1, 5, 3, 6, -1)) Traceback (most recent call last):     ... ValueError: No height can be negative","any, len, enumerate, range, sum, ValueError, max, max, min, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\tribonacci.py","","tribonacci","Given a number, return first n Tribonacci Numbers. >>> tribonacci(5) [0, 0, 1, 1, 2] >>> tribonacci(8) [0, 0, 1, 1, 2, 4, 7, 13]","range"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","viterbi","Viterbi Algorithm, to find the most likely path of states from the start and the expected output.  https://en.wikipedia.org/wiki/Viterbi_algorithm  Wikipedia example  >>> observations = [""normal"", ""cold"", ""dizzy""] >>> states = [""Healthy"", ""Fever""] >>> start_p = {""Healthy"": 0.6, ""Fever"": 0.4} >>> trans_p = { ...     ""Healthy"": {""Healthy"": 0.7, ""Fever"": 0.3}, ...     ""Fever"": {""Healthy"": 0.4, ""Fever"": 0.6}, ... } >>> emit_p = { ...     ""Healthy"": {""normal"": 0.5, ""cold"": 0.4, ""dizzy"": 0.1}, ...     ""Fever"": {""normal"": 0.1, ""cold"": 0.3, ""dizzy"": 0.6}, ... } >>> viterbi(observations, states, start_p, trans_p, emit_p) ['Healthy', 'Healthy', 'Fever'] >>> viterbi((), states, start_p, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: There's an empty parameter >>> viterbi(observations, (), start_p, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: There's an empty parameter >>> viterbi(observations, states, {}, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: There's an empty parameter >>> viterbi(observations, states, start_p, {}, emit_p) Traceback (most recent call last):     ... ValueError: There's an empty parameter >>> viterbi(observations, states, start_p, trans_p, {}) Traceback (most recent call last):     ... ValueError: There's an empty parameter >>> viterbi(""invalid"", states, start_p, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: observations_space must be a list >>> viterbi([""valid"", 123], states, start_p, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: observations_space must be a list of strings >>> viterbi(observations, ""invalid"", start_p, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: states_space must be a list >>> viterbi(observations, [""valid"", 123], start_p, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: states_space must be a list of strings >>> viterbi(observations, states, ""invalid"", trans_p, emit_p) Traceback (most recent call last):     ... ValueError: initial_probabilities must be a dict >>> viterbi(observations, states, {2:2}, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: initial_probabilities all keys must be strings >>> viterbi(observations, states, {""a"":2}, trans_p, emit_p) Traceback (most recent call last):     ... ValueError: initial_probabilities all values must be float >>> viterbi(observations, states, start_p, ""invalid"", emit_p) Traceback (most recent call last):     ... ValueError: transition_probabilities must be a dict >>> viterbi(observations, states, start_p, {""a"":2}, emit_p) Traceback (most recent call last):     ... ValueError: transition_probabilities all values must be dict >>> viterbi(observations, states, start_p, {2:{2:2}}, emit_p) Traceback (most recent call last):     ... ValueError: transition_probabilities all keys must be strings >>> viterbi(observations, states, start_p, {""a"":{2:2}}, emit_p) Traceback (most recent call last):     ... ValueError: transition_probabilities all keys must be strings >>> viterbi(observations, states, start_p, {""a"":{""b"":2}}, emit_p) Traceback (most recent call last):     ... ValueError: transition_probabilities nested dictionary all values must be float >>> viterbi(observations, states, start_p, trans_p, ""invalid"") Traceback (most recent call last):     ... ValueError: emission_probabilities must be a dict >>> viterbi(observations, states, start_p, trans_p, None) Traceback (most recent call last):     ... ValueError: There's an empty parameter","_validation, range, range, result.reverse, len, result.append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validation",">>> observations = [""normal"", ""cold"", ""dizzy""] >>> states = [""Healthy"", ""Fever""] >>> start_p = {""Healthy"": 0.6, ""Fever"": 0.4} >>> trans_p = { ...     ""Healthy"": {""Healthy"": 0.7, ""Fever"": 0.3}, ...     ""Fever"": {""Healthy"": 0.4, ""Fever"": 0.6}, ... } >>> emit_p = { ...     ""Healthy"": {""normal"": 0.5, ""cold"": 0.4, ""dizzy"": 0.1}, ...     ""Fever"": {""normal"": 0.1, ""cold"": 0.3, ""dizzy"": 0.6}, ... } >>> _validation(observations, states, start_p, trans_p, emit_p) >>> _validation([], states, start_p, trans_p, emit_p) Traceback (most recent call last):         ... ValueError: There's an empty parameter","_validate_not_empty, _validate_lists, _validate_dicts"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validate_not_empty",">>> _validate_not_empty([""a""], [""b""], {""c"":0.5}, ... {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}}) >>> _validate_not_empty([""a""], [""b""], {""c"":0.5}, {}, {""f"": {""g"": 0.7}}) Traceback (most recent call last):         ... ValueError: There's an empty parameter >>> _validate_not_empty([""a""], [""b""], None, {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}}) Traceback (most recent call last):         ... ValueError: There's an empty parameter","all, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validate_lists",">>> _validate_lists([""a""], [""b""]) >>> _validate_lists(1234, [""b""]) Traceback (most recent call last):         ... ValueError: observations_space must be a list >>> _validate_lists([""a""], [3]) Traceback (most recent call last):         ... ValueError: states_space must be a list of strings","_validate_list, _validate_list"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validate_list",">>> _validate_list([""a""], ""mock_name"") >>> _validate_list(""a"", ""mock_name"") Traceback (most recent call last):         ... ValueError: mock_name must be a list >>> _validate_list([0.5], ""mock_name"") Traceback (most recent call last):         ... ValueError: mock_name must be a list of strings","isinstance, ValueError, isinstance, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validate_dicts",">>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}}) >>> _validate_dicts(""invalid"", {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}}) Traceback (most recent call last):         ... ValueError: initial_probabilities must be a dict >>> _validate_dicts({""c"":0.5}, {2: {""e"": 0.6}}, {""f"": {""g"": 0.7}}) Traceback (most recent call last):         ... ValueError: transition_probabilities all keys must be strings >>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {2: 0.7}}) Traceback (most recent call last):         ... ValueError: emission_probabilities all keys must be strings >>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {""g"": ""h""}}) Traceback (most recent call last):         ... ValueError: emission_probabilities nested dictionary all values must be float","_validate_dict, _validate_nested_dict, _validate_nested_dict"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validate_nested_dict",">>> _validate_nested_dict({""a"":{""b"": 0.5}}, ""mock_name"") >>> _validate_nested_dict(""invalid"", ""mock_name"") Traceback (most recent call last):         ... ValueError: mock_name must be a dict >>> _validate_nested_dict({""a"": 8}, ""mock_name"") Traceback (most recent call last):         ... ValueError: mock_name all values must be dict >>> _validate_nested_dict({""a"":{2: 0.5}}, ""mock_name"") Traceback (most recent call last):         ... ValueError: mock_name all keys must be strings >>> _validate_nested_dict({""a"":{""b"": 4}}, ""mock_name"") Traceback (most recent call last):         ... ValueError: mock_name nested dictionary all values must be float","_validate_dict, _object.values, _validate_dict"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\viterbi.py","","_validate_dict",">>> _validate_dict({""b"": 0.5}, ""mock_name"", float) >>> _validate_dict(""invalid"", ""mock_name"", float) Traceback (most recent call last):         ... ValueError: mock_name must be a dict >>> _validate_dict({""a"": 8}, ""mock_name"", dict) Traceback (most recent call last):         ... ValueError: mock_name all values must be dict >>> _validate_dict({2: 0.5}, ""mock_name"",float, True) Traceback (most recent call last):         ... ValueError: mock_name all keys must be strings >>> _validate_dict({""b"": 4}, ""mock_name"", float,True) Traceback (most recent call last):         ... ValueError: mock_name nested dictionary all values must be float","isinstance, ValueError, all, ValueError, all, ValueError, isinstance, isinstance, _object.values"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\wildcard_matching.py","","is_match",">>> is_match("""", """") True >>> is_match(""aa"", ""a"") False >>> is_match(""abc"", ""abc"") True >>> is_match(""abc"", ""*c"") True >>> is_match(""abc"", ""a*"") True >>> is_match(""abc"", ""*a*"") True >>> is_match(""abc"", ""?b?"") True >>> is_match(""abc"", ""*?"") True >>> is_match(""abc"", ""a*d"") False >>> is_match(""abc"", ""a*c?"") False >>> is_match('baaabab','*****ba*****ba') False >>> is_match('baaabab','*****ba*****ab') True >>> is_match('aa','*') True","enumerate, enumerate, enumerate, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\word_break.py","","word_break","Return True if numbers have opposite signs False otherwise.  >>> word_break(""applepenapple"", [""apple"",""pen""]) True >>> word_break(""catsandog"", [""cats"",""dog"",""sand"",""and"",""cat""]) False >>> word_break(""cars"", [""car"",""ca"",""rs""]) True >>> word_break('abc', []) False >>> word_break(123, ['a']) Traceback (most recent call last):     ... ValueError: the string should be not empty string >>> word_break('', ['a']) Traceback (most recent call last):     ... ValueError: the string should be not empty string >>> word_break('abc', [123]) Traceback (most recent call last):     ... ValueError: the words should be a list of non-empty strings >>> word_break('abc', ['']) Traceback (most recent call last):     ... ValueError: the words should be a list of non-empty strings","len, is_breakable, ValueError, ValueError, range, isinstance, len, isinstance, all, trie_node.get, trie_node.get, is_breakable, isinstance, len"
"C:/Users/Joseph Dania/Desktop/python_repo\dynamic_programming\word_break.py","","is_breakable",">>> string = 'a' >>> is_breakable(1) True","range, trie_node.get, trie_node.get, is_breakable"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\apparent_power.py","","apparent_power","Calculate the apparent power in a single-phase AC circuit.  Reference: https://en.wikipedia.org/wiki/AC_power#Apparent_power  >>> apparent_power(100, 5, 0, 0) (500+0j) >>> apparent_power(100, 5, 90, 0) (3.061616997868383e-14+500j) >>> apparent_power(100, 5, -45, -60) (-129.40952255126027-482.9629131445341j) >>> apparent_power(200, 10, -30, -90) (-999.9999999999998-1732.0508075688776j)","math.radians, math.radians, cmath.rect, cmath.rect"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\builtin_voltage.py","","builtin_voltage","This function can calculate the Builtin Voltage of a pn junction diode. This is calculated from the given three values. Examples - >>> builtin_voltage(donor_conc=1e17, acceptor_conc=1e17, intrinsic_conc=1e10) 0.833370010652644 >>> builtin_voltage(donor_conc=0, acceptor_conc=1600, intrinsic_conc=200) Traceback (most recent call last):   ... ValueError: Donor concentration should be positive >>> builtin_voltage(donor_conc=1000, acceptor_conc=0, intrinsic_conc=1200) Traceback (most recent call last):   ... ValueError: Acceptor concentration should be positive >>> builtin_voltage(donor_conc=1000, acceptor_conc=1000, intrinsic_conc=0) Traceback (most recent call last):   ... ValueError: Intrinsic concentration should be positive >>> builtin_voltage(donor_conc=1000, acceptor_conc=3000, intrinsic_conc=2000) Traceback (most recent call last):   ... ValueError: Donor concentration should be greater than intrinsic concentration >>> builtin_voltage(donor_conc=3000, acceptor_conc=1000, intrinsic_conc=2000) Traceback (most recent call last):   ... ValueError: Acceptor concentration should be greater than intrinsic concentration","ValueError, ValueError, ValueError, ValueError, ValueError, log"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\capacitor_equivalence.py","","capacitor_parallel","Ceq = C1 + C2 + ... + Cn Calculate the equivalent resistance for any number of capacitors in parallel. >>> capacitor_parallel([5.71389, 12, 3]) 20.71389 >>> capacitor_parallel([5.71389, 12, -3]) Traceback (most recent call last):     ... ValueError: Capacitor at index 2 has a negative value!","enumerate, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\capacitor_equivalence.py","","capacitor_series","Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn) >>> capacitor_series([5.71389, 12, 3]) 1.6901062252507735 >>> capacitor_series([5.71389, 12, -3]) Traceback (most recent call last):     ... ValueError: Capacitor at index 2 has a negative or zero value! >>> capacitor_series([5.71389, 12, 0.000]) Traceback (most recent call last):     ... ValueError: Capacitor at index 2 has a negative or zero value!","enumerate, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\carrier_concentration.py","","carrier_concentration","This function can calculate any one of the three - 1. Electron Concentration 2, Hole Concentration 3. Intrinsic Concentration given the other two. Examples - >>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0) ('intrinsic_conc', 50.0) >>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200) ('electron_conc', 25.0) >>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200) ('hole_conc', 1440.0) >>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200) Traceback (most recent call last):     ... ValueError: You cannot supply more or less than 2 values >>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200) Traceback (most recent call last):     ... ValueError: Electron concentration cannot be negative in a semiconductor >>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200) Traceback (most recent call last):     ... ValueError: Hole concentration cannot be negative in a semiconductor >>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200) Traceback (most recent call last):     ... ValueError: Intrinsic concentration cannot be negative in a semiconductor",".count, ValueError, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\charging_capacitor.py","","charging_capacitor","Find capacitor voltage at any nth second after initiating its charging.  Examples -------- >>> charging_capacitor(source_voltage=.2,resistance=.9,capacitance=8.4,time_sec=.5) 0.013  >>> charging_capacitor(source_voltage=2.2,resistance=3.5,capacitance=2.4,time_sec=9) 1.446  >>> charging_capacitor(source_voltage=15,resistance=200,capacitance=20,time_sec=2) 0.007  >>> charging_capacitor(20, 2000, 30*pow(10,-5), 4) 19.975  >>> charging_capacitor(source_voltage=0,resistance=10.0,capacitance=.30,time_sec=3) Traceback (most recent call last):     ... ValueError: Source voltage must be positive.  >>> charging_capacitor(source_voltage=20,resistance=-2000,capacitance=30,time_sec=4) Traceback (most recent call last):     ... ValueError: Resistance must be positive.  >>> charging_capacitor(source_voltage=30,resistance=1500,capacitance=0,time_sec=4) Traceback (most recent call last):     ... ValueError: Capacitance must be positive.","round, ValueError, ValueError, ValueError, exp"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\charging_inductor.py","","charging_inductor","Find inductor current at any nth second after initiating its charging.  Examples -------- >>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2) 2.817  >>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2) 1.543  >>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2) 0.016  >>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12) Traceback (most recent call last):     ... ValueError: Source voltage must be positive.  >>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5) Traceback (most recent call last):     ... ValueError: Resistance must be positive.  >>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5) Traceback (most recent call last):     ... ValueError: Inductance must be positive.  >>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5) Traceback (most recent call last):     ... ValueError: Source voltage must be positive.  >>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5) Traceback (most recent call last):     ... ValueError: Resistance must be positive.  >>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5) Traceback (most recent call last):     ... ValueError: Inductance must be positive.","round, ValueError, ValueError, ValueError, exp"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\circular_convolution.py","CircularConvolution","","This class stores the first and second signal and performs the circular convolution",""
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\circular_convolution.py","","__init__","First signal and second signal are stored as 1-D array",""
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\circular_convolution.py","","circular_convolution","This function performs the circular convolution of the first and second signal using matrix method  Usage: >>> convolution = CircularConvolution() >>> convolution.circular_convolution() [10.0, 10.0, 6.0, 14.0]  >>> convolution.first_signal = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6] >>> convolution.second_signal = [0.1, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5] >>> convolution.circular_convolution() [5.2, 6.0, 6.48, 6.64, 6.48, 6.0, 5.2, 4.08]  >>> convolution.first_signal = [-1, 1, 2, -2] >>> convolution.second_signal = [0.5, 1, -1, 2, 0.75] >>> convolution.circular_convolution() [6.25, -3.0, 1.5, -2.0, -2.75]  >>> convolution.first_signal = [1, -1, 2, 3, -1] >>> convolution.second_signal = [1, 2, 3] >>> convolution.circular_convolution() [8.0, -2.0, 3.0, 4.0, 11.0]","len, len, max, range, np.matmul, deque, rotated_signal.rotate, enumerate, np.transpose, np.transpose, float, range, round"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\coulombs_law.py","","couloumbs_law","Apply Coulomb's Law on any three given values. These can be force, charge1, charge2, or distance, and then in a Python dict return name/value pair of the zero value.  Coulomb's Law states that the magnitude of the electrostatic force of attraction or repulsion between two point charges is directly proportional to the product of the magnitudes of charges and inversely proportional to the square of the distance between them.  Reference ---------- Coulomb (1785) ""Premier mmoire sur l'lectricit et le magntisme,"" Histoire de l'Acadmie Royale des Sciences, pp. 569-577.  Parameters ---------- force : float with units in Newtons  charge1 : float with units in Coulombs  charge2 : float with units in Coulombs  distance : float with units in meters  Returns ------- result : dict name/value pair of the zero value  >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=2000) {'force': 33705.0}  >>> couloumbs_law(force=10, charge1=3, charge2=5, distance=0) {'distance': 116112.01488218177}  >>> couloumbs_law(force=10, charge1=0, charge2=5, distance=2000) {'charge1': 0.0008900756564307966}  >>> couloumbs_law(force=0, charge1=0, charge2=5, distance=2000) Traceback (most recent call last):   ... ValueError: One and only one argument must be 0  >>> couloumbs_law(force=0, charge1=3, charge2=5, distance=-2000) Traceback (most recent call last):   ... ValueError: Distance cannot be negative","abs, ValueError, .count, ValueError, ValueError, abs, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\electrical_impedance.py","","electrical_impedance","Apply Electrical Impedance formula, on any two given electrical values, which can be resistance, reactance, and impedance, and then in a Python dict return name/value pair of the zero value.  >>> electrical_impedance(3,4,0) {'impedance': 5.0} >>> electrical_impedance(0,4,5) {'resistance': 3.0} >>> electrical_impedance(3,0,5) {'reactance': 4.0} >>> electrical_impedance(3,4,5) Traceback (most recent call last):   ... ValueError: One and only one argument must be 0",".count, ValueError, sqrt, sqrt, ValueError, pow, pow, sqrt, pow, pow, pow, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\electric_conductivity.py","","electric_conductivity","This function can calculate any one of the three - 1. Conductivity 2. Electron Concentration 3. Electron Mobility This is calculated from the other two provided values Examples - >>> electric_conductivity(conductivity=25, electron_conc=100, mobility=0) ('mobility', 1.5604519068722301e+18) >>> electric_conductivity(conductivity=0, electron_conc=1600, mobility=200) ('conductivity', 5.12672e-14) >>> electric_conductivity(conductivity=1000, electron_conc=0, mobility=1200) ('electron_conc', 5.201506356240767e+18) >>> electric_conductivity(conductivity=-10, electron_conc=100, mobility=0) Traceback (most recent call last):     ... ValueError: Conductivity cannot be negative >>> electric_conductivity(conductivity=50, electron_conc=-10, mobility=0) Traceback (most recent call last):     ... ValueError: Electron concentration cannot be negative >>> electric_conductivity(conductivity=50, electron_conc=0, mobility=-10) Traceback (most recent call last):     ... ValueError: mobility cannot be negative >>> electric_conductivity(conductivity=50, electron_conc=0, mobility=0) Traceback (most recent call last):     ... ValueError: You cannot supply more or less than 2 values >>> electric_conductivity(conductivity=50, electron_conc=200, mobility=300) Traceback (most recent call last):     ... ValueError: You cannot supply more or less than 2 values",".count, ValueError, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\electric_power.py","Result","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\electric_power.py","","electric_power","This function can calculate any one of the three (voltage, current, power), fundamental value of electrical system. examples are below: >>> electric_power(voltage=0, current=2, power=5) Result(name='voltage', value=2.5) >>> electric_power(voltage=2, current=2, power=0) Result(name='power', value=4.0) >>> electric_power(voltage=-2, current=3, power=0) Result(name='power', value=6.0) >>> electric_power(voltage=2, current=4, power=2) Traceback (most recent call last):     ... ValueError: Exactly one argument must be 0 >>> electric_power(voltage=0, current=0, power=2) Traceback (most recent call last):     ... ValueError: Exactly one argument must be 0 >>> electric_power(voltage=0, current=2, power=-4) Traceback (most recent call last):     ... ValueError: Power cannot be negative in any electrical/electronics system >>> electric_power(voltage=2.2, current=2.2, power=0) Result(name='power', value=4.84) >>> electric_power(current=0, power=6, voltage=2) Result(name='current', value=3.0)",".count, ValueError, ValueError, Result, Result, Result, float, round, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\ic_555_timer.py","","astable_frequency","Usage examples: >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=7) 1523.8095238095239 >>> astable_frequency(resistance_1=356, resistance_2=234, capacitance=976) 1.7905459175553078 >>> astable_frequency(resistance_1=2, resistance_2=-1, capacitance=2) Traceback (most recent call last):     ... ValueError: All values must be positive >>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=0) Traceback (most recent call last):     ... ValueError: All values must be positive","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\ic_555_timer.py","","astable_duty_cycle","Usage examples: >>> astable_duty_cycle(resistance_1=45, resistance_2=45) 66.66666666666666 >>> astable_duty_cycle(resistance_1=356, resistance_2=234) 71.60194174757282 >>> astable_duty_cycle(resistance_1=2, resistance_2=-1) Traceback (most recent call last):     ... ValueError: All values must be positive >>> astable_duty_cycle(resistance_1=0, resistance_2=0) Traceback (most recent call last):     ... ValueError: All values must be positive","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\ind_reactance.py","","ind_reactance","Calculate inductive reactance, frequency or inductance from two given electrical properties then return name/value pair of the zero value in a Python dict.  Parameters ---------- inductance : float with units in Henries  frequency : float with units in Hertz  reactance : float with units in Ohms  >>> ind_reactance(-35e-6, 1e3, 0) Traceback (most recent call last):     ... ValueError: Inductance cannot be negative  >>> ind_reactance(35e-6, -1e3, 0) Traceback (most recent call last):     ... ValueError: Frequency cannot be negative  >>> ind_reactance(35e-6, 0, -1) Traceback (most recent call last):     ... ValueError: Inductive reactance cannot be negative  >>> ind_reactance(0, 10e3, 50) {'inductance': 0.0007957747154594767}  >>> ind_reactance(35e-3, 0, 50) {'frequency': 227.36420441699332}  >>> ind_reactance(35e-6, 1e3, 0) {'reactance': 0.2199114857512855}",".count, ValueError, ValueError, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\ohms_law.py","","ohms_law","Apply Ohm's Law, on any two given electrical values, which can be voltage, current, and resistance, and then in a Python dict return name/value pair of the zero value.  >>> ohms_law(voltage=10, resistance=5, current=0) {'current': 2.0} >>> ohms_law(voltage=0, current=0, resistance=10) Traceback (most recent call last):   ... ValueError: One and only one argument must be 0 >>> ohms_law(voltage=0, current=1, resistance=-2) Traceback (most recent call last):   ... ValueError: Resistance cannot be negative >>> ohms_law(resistance=0, voltage=-10, current=1) {'resistance': -10.0} >>> ohms_law(voltage=0, current=-1.5, resistance=2) {'voltage': -3.0}",".count, ValueError, ValueError, float, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\real_and_reactive_power.py","","real_power","Calculate real power from apparent power and power factor.  Examples: >>> real_power(100, 0.9) 90.0 >>> real_power(0, 0.8) 0.0 >>> real_power(100, -0.9) -90.0","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\real_and_reactive_power.py","","reactive_power","Calculate reactive power from apparent power and power factor.  Examples: >>> reactive_power(100, 0.9) 43.58898943540673 >>> reactive_power(0, 0.8) 0.0 >>> reactive_power(100, -0.9) 43.58898943540673","ValueError, math.sqrt, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","get_significant_digits","Function returns the digit associated with the color. Function takes a list containing colors as input and returns digits as string  >>> get_significant_digits(['Black','Blue']) '06'  >>> get_significant_digits(['Aqua','Blue']) Traceback (most recent call last):   ... ValueError: Aqua is not a valid color for significant figure bands","str, ValueError, str"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","get_multiplier","Function returns the multiplier value associated with the color. Function takes color as input and returns multiplier value  >>> get_multiplier('Gold') 0.1  >>> get_multiplier('Ivory') Traceback (most recent call last):   ... ValueError: Ivory is not a valid color for multiplier band","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","get_tolerance","Function returns the tolerance value associated with the color. Function takes color as input and returns tolerance value.  >>> get_tolerance('Green') 0.5  >>> get_tolerance('Indigo') Traceback (most recent call last):   ... ValueError: Indigo is not a valid color for tolerance band","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","get_temperature_coeffecient","Function returns the temperature coeffecient value associated with the color. Function takes color as input and returns temperature coeffecient value.  >>> get_temperature_coeffecient('Yellow') 25  >>> get_temperature_coeffecient('Cyan') Traceback (most recent call last):   ... ValueError: Cyan is not a valid color for temperature coeffecient band","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","get_band_type_count","Function returns the number of bands of a given type in a resistor with n bands Function takes total_number_of_bands and type_of_band as input and returns number of bands belonging to that type in the given resistor  >>> get_band_type_count(3,'significant') 2  >>> get_band_type_count(2,'significant') Traceback (most recent call last):   ... ValueError: 2 is not a valid number of bands  >>> get_band_type_count(3,'sign') Traceback (most recent call last):   ... ValueError: sign is not valid for a 3 band resistor  >>> get_band_type_count(3,'tolerance') Traceback (most recent call last):   ... ValueError: tolerance is not valid for a 3 band resistor  >>> get_band_type_count(5,'temp_coeffecient') Traceback (most recent call last):   ... ValueError: temp_coeffecient is not valid for a 5 band resistor","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","check_validity","Function checks if the input provided is valid or not. Function takes number_of_bands and colors as input and returns True if it is valid  >>> check_validity(3, [""Black"",""Blue"",""Orange""]) True  >>> check_validity(4, [""Black"",""Blue"",""Orange""]) Traceback (most recent call last):   ... ValueError: Expecting 4 colors, provided 3 colors  >>> check_validity(3, [""Cyan"",""Red"",""Yellow""]) Traceback (most recent call last):   ... ValueError: Cyan is not a valid color","ValueError, len, ValueError, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_color_code.py","","calculate_resistance","Function calculates the total resistance of the resistor using the color codes. Function takes number_of_bands, color_code_list as input and returns resistance  >>> calculate_resistance(3, [""Black"",""Blue"",""Orange""]) {'resistance': '6000 20% '}  >>> calculate_resistance(4, [""Orange"",""Green"",""Blue"",""Gold""]) {'resistance': '35000000 5% '}  >>> calculate_resistance(5, [""Violet"",""Brown"",""Grey"",""Silver"",""Green""]) {'resistance': '7.18 0.5% '}  >>> calculate_resistance(6, [""Red"",""Green"",""Blue"",""Yellow"",""Orange"",""Grey""]) {'resistance': '2560000 0.05% 1 ppm/K'}  >>> calculate_resistance(0, [""Violet"",""Brown"",""Grey"",""Silver"",""Green""]) Traceback (most recent call last):   ... ValueError: Invalid number of bands. Resistor bands must be 3 to 6  >>> calculate_resistance(4, [""Violet"",""Brown"",""Grey"",""Silver"",""Green""]) Traceback (most recent call last):   ... ValueError: Expecting 4 colors, provided 5 colors  >>> calculate_resistance(4, [""Violet"",""Silver"",""Brown"",""Grey""]) Traceback (most recent call last):   ... ValueError: Silver is not a valid color for significant figure bands  >>> calculate_resistance(4, [""Violet"",""Blue"",""Lime"",""Grey""]) Traceback (most recent call last):   ... ValueError: Lime is not a valid color","check_validity, get_band_type_count, int, get_multiplier, ValueError, get_significant_digits, get_tolerance, get_temperature_coeffecient, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_equivalence.py","","resistor_parallel","Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)  >>> resistor_parallel([3.21389, 2, 3]) 0.8737571620498019 >>> resistor_parallel([3.21389, 2, -3]) Traceback (most recent call last):     ... ValueError: Resistor at index 2 has a negative or zero value! >>> resistor_parallel([3.21389, 2, 0.000]) Traceback (most recent call last):     ... ValueError: Resistor at index 2 has a negative or zero value!","enumerate, ValueError, float"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resistor_equivalence.py","","resistor_series","Req = R1 + R2 + ... + Rn  Calculate the equivalent resistance for any number of resistors in parallel.  >>> resistor_series([3.21389, 2, 3]) 8.21389 >>> resistor_series([3.21389, 2, -3]) Traceback (most recent call last):     ... ValueError: Resistor at index 2 has a negative value!","enumerate, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\resonant_frequency.py","","resonant_frequency","This function can calculate the resonant frequency of LC circuit, for the given value of inductance and capacitnace.  Examples are given below: >>> resonant_frequency(inductance=10, capacitance=5) ('Resonant frequency', 0.022507907903927652) >>> resonant_frequency(inductance=0, capacitance=5) Traceback (most recent call last):   ... ValueError: Inductance cannot be 0 or negative >>> resonant_frequency(inductance=10, capacitance=0) Traceback (most recent call last):   ... ValueError: Capacitance cannot be 0 or negative","ValueError, ValueError, float, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\electronics\wheatstone_bridge.py","","wheatstone_solver","This function can calculate the unknown resistance in an wheatstone network, given that the three other resistances in the network are known. The formula to calculate the same is:  --------------- |Rx=(R2/R1)*R3| ---------------  Usage examples: >>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5) 10.0 >>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976) 641.5280898876405 >>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2) Traceback (most recent call last):     ... ValueError: All resistance values must be positive >>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2) Traceback (most recent call last):     ... ValueError: All resistance values must be positive","ValueError, float"
"C:/Users/Joseph Dania/Desktop/python_repo\file_transfer\receive_file.py","","main","","socket.socket, socket.gethostname, sock.connect, sock.send, print, sock.close, print, open, print, print, sock.recv, out_file.write"
"C:/Users/Joseph Dania/Desktop/python_repo\file_transfer\send_file.py","","send_file","","socket.socket, socket.gethostname, sock.bind, sock.listen, print, sock.shutdown, sock.close, sock.accept, print, conn.recv, print, print, conn.close, open, in_file.read, conn.send, print, in_file.read"
"C:/Users/Joseph Dania/Desktop/python_repo\file_transfer\tests\test_send_file.py","","test_send_file_running_as_expected","","patch, patch, Mock, iter, send_file, sock.assert_called_once, sock.return_value.bind.assert_called_once, sock.return_value.listen.assert_called_once, sock.return_value.accept.assert_called_once, conn.recv.assert_called_once, file.return_value.__enter__.assert_called_once, file.return_value.__enter__.return_value.read.assert_called, conn.send.assert_called_once, conn.close.assert_called_once, sock.return_value.shutdown.assert_called_once, sock.return_value.close.assert_called_once, Mock, next"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\equated_monthly_installments.py","","equated_monthly_installments","Formula for amortization amount per month: A = p * r * (1 + r)^n / ((1 + r)^n - 1) where p is the principal, r is the rate of interest per month and n is the number of payments  >>> equated_monthly_installments(25000, 0.12, 3) 830.3577453212793 >>> equated_monthly_installments(25000, 0.12, 10) 358.67737100646826 >>> equated_monthly_installments(0, 0.12, 3) Traceback (most recent call last):     ... Exception: Principal borrowed must be > 0 >>> equated_monthly_installments(25000, -1, 3) Traceback (most recent call last):     ... Exception: Rate of interest must be >= 0 >>> equated_monthly_installments(25000, 0.12, 0) Traceback (most recent call last):     ... Exception: Years to repay must be an integer > 0","Exception, Exception, Exception, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\exponential_moving_average.py","","exponential_moving_average","Yields exponential moving averages of the given stock prices. >>> tuple(exponential_moving_average(iter([2, 5, 3, 8.2, 6, 9, 10]), 3)) (2, 3.5, 3.25, 5.725, 5.8625, 7.43125, 8.715625)  :param stock_prices: A stream of stock prices :param window_size: The number of stock prices that will trigger a new calculation                     of the exponential average (window_size > 0) :return: Yields a sequence of exponential moving averages  Formula:  st = alpha * xt + (1 - alpha) * st_prev  Where, st : Exponential moving average at timestamp t xt : stock price in from the stock prices at timestamp t st_prev : Exponential moving average at timestamp t-1 alpha : 2/(1 + window_size) - smoothing factor  Exponential moving average (EMA) is a rule of thumb technique for smoothing time series data using an exponential window function.","enumerate, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\interest.py","","simple_interest",">>> simple_interest(18000.0, 0.06, 3) 3240.0 >>> simple_interest(0.5, 0.06, 3) 0.09 >>> simple_interest(18000.0, 0.01, 10) 1800.0 >>> simple_interest(18000.0, 0.0, 3) 0.0 >>> simple_interest(5500.0, 0.01, 100) 5500.0 >>> simple_interest(10000.0, -0.06, 3) Traceback (most recent call last):     ... ValueError: daily_interest_rate must be >= 0 >>> simple_interest(-10000.0, 0.06, 3) Traceback (most recent call last):     ... ValueError: principal must be > 0 >>> simple_interest(5500.0, 0.01, -5) Traceback (most recent call last):     ... ValueError: days_between_payments must be > 0","ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\interest.py","","compound_interest",">>> compound_interest(10000.0, 0.05, 3) 1576.2500000000014 >>> compound_interest(10000.0, 0.05, 1) 500.00000000000045 >>> compound_interest(0.5, 0.05, 3) 0.07881250000000006 >>> compound_interest(10000.0, 0.06, -4) Traceback (most recent call last):     ... ValueError: number_of_compounding_periods must be > 0 >>> compound_interest(10000.0, -3.5, 3.0) Traceback (most recent call last):     ... ValueError: nominal_annual_interest_rate_percentage must be >= 0 >>> compound_interest(-5500.0, 0.01, 5) Traceback (most recent call last):     ... ValueError: principal must be > 0","ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\interest.py","","apr_interest",">>> apr_interest(10000.0, 0.05, 3) 1618.223072263547 >>> apr_interest(10000.0, 0.05, 1) 512.6749646744732 >>> apr_interest(0.5, 0.05, 3) 0.08091115361317736 >>> apr_interest(10000.0, 0.06, -4) Traceback (most recent call last):     ... ValueError: number_of_years must be > 0 >>> apr_interest(10000.0, -3.5, 3.0) Traceback (most recent call last):     ... ValueError: nominal_annual_percentage_rate must be >= 0 >>> apr_interest(-5500.0, 0.01, 5) Traceback (most recent call last):     ... ValueError: principal must be > 0","compound_interest, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\present_value.py","","present_value",">>> present_value(0.13, [10, 20.70, -293, 297]) 4.69 >>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39]) -42739.63 >>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39]) 175519.15 >>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39]) Traceback (most recent call last):     ... ValueError: Discount rate cannot be negative >>> present_value(0.03, []) Traceback (most recent call last):     ... ValueError: Cash flows list cannot be empty","sum, round, ValueError, ValueError, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\price_plus_tax.py","","price_plus_tax",">>> price_plus_tax(100, 0.25) 125.0 >>> price_plus_tax(125.50, 0.05) 131.775",""
"C:/Users/Joseph Dania/Desktop/python_repo\financial\simple_moving_average.py","","simple_moving_average","Calculate the simple moving average (SMA) for some given time series data.  :param data: A list of numerical data points. :param window_size: An integer representing the size of the SMA window. :return: A list of SMA values with the same length as the input data.  Examples: >>> sma = simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 3) >>> [round(value, 2) if value is not None else None for value in sma] [None, None, 12.33, 13.33, 14.0, 14.33, 16.0, 17.0, 18.0, 19.0] >>> simple_moving_average([10, 12, 15], 5) [None, None, None] >>> simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 0) Traceback (most recent call last): ... ValueError: Window size must be a positive integer","range, ValueError, len, sma.append, sma.append, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\straight_line_depreciation.py","","straight_line_depreciation","Calculate the depreciation expenses over the given period :param useful_years: Number of years the asset will be used :param purchase_value: Purchase expenditure for the asset :param residual_value: Residual value of the asset at the end of its useful life :return: A list of annual depreciation expenses over the asset's useful life >>> straight_line_depreciation(10, 1100.0, 100.0) [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0] >>> straight_line_depreciation(6, 1250.0, 50.0) [200.0, 200.0, 200.0, 200.0, 200.0, 200.0] >>> straight_line_depreciation(4, 1001.0) [250.25, 250.25, 250.25, 250.25] >>> straight_line_depreciation(11, 380.0, 50.0) [30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0, 30.0] >>> straight_line_depreciation(1, 4985, 100) [4885.0]","range, isinstance, TypeError, ValueError, isinstance, TypeError, isinstance, TypeError, ValueError, ValueError, list_of_depreciation_expenses.append, list_of_depreciation_expenses.append"
"C:/Users/Joseph Dania/Desktop/python_repo\financial\time_and_half_pay.py","","pay","hours_worked = The total hours worked pay_rate = Amount of money per hour hours = Number of hours that must be worked before you receive time and a half  >>> pay(41, 1) 41.5 >>> pay(65, 19) 1472.5 >>> pay(10, 1) 10.0","isinstance, isinstance, isinstance, max"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\julia_sets.py","","eval_exponential","Evaluate $e^z + c$. >>> float(eval_exponential(0, 0)) 1.0 >>> bool(abs(eval_exponential(1, np.pi*1.j)) < 1e-15) True >>> bool(abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15) True","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\julia_sets.py","","eval_quadratic_polynomial",">>> eval_quadratic_polynomial(0, 2) 4 >>> eval_quadratic_polynomial(-1, 1) 0 >>> round(eval_quadratic_polynomial(1.j, 0).imag) 1 >>> round(eval_quadratic_polynomial(1.j, 0).real) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\julia_sets.py","","prepare_grid","Create a grid of complex values of size nb_pixels*nb_pixels with real and  imaginary parts ranging from -window_size to window_size (inclusive). Returns a numpy array.  >>> prepare_grid(1,3) array([[-1.-1.j, -1.+0.j, -1.+1.j],        [ 0.-1.j,  0.+0.j,  0.+1.j],        [ 1.-1.j,  1.+0.j,  1.+1.j]])","np.linspace, x.reshape, np.linspace, y.reshape"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\julia_sets.py","","iterate_function","Iterate the function ""eval_function"" exactly nb_iterations times. The first argument of the function is a parameter which is contained in function_params. The variable z_0 is an array that contains the initial values to iterate from. This function returns the final iterates.  >>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape (3,) >>> complex(np.round(iterate_function(eval_quadratic_polynomial, ... 0, ... 3, ... np.array([0,1,2]))[0])) 0j >>> complex(np.round(iterate_function(eval_quadratic_polynomial, ... 0, ... 3, ... np.array([0,1,2]))[1])) (1+0j) >>> complex(np.round(iterate_function(eval_quadratic_polynomial, ... 0, ... 3, ... np.array([0,1,2]))[2])) (256+0j)","z_0.astype, range, eval_function, np.nan_to_num, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\julia_sets.py","","show_results","Plots of whether the absolute value of z_final is greater than the value of escape_radius. Adds the function_label and function_params to the title.  >>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))",".transpose, plt.matshow, plt.title, plt.show, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\julia_sets.py","","ignore_overflow_warnings","Ignore some overflow and invalid value warnings.  >>> ignore_overflow_warnings()","warnings.filterwarnings, warnings.filterwarnings, warnings.filterwarnings, warnings.filterwarnings"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\koch_snowflake.py","","iterate","Go through the number of iterations determined by the argument ""steps"". Be careful with high values (above 5) since the time to calculate increases exponentially. >>> iterate([np.array([0, 0]), np.array([1, 0])], 1) [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]","range, iteration_step"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\koch_snowflake.py","","iteration_step","Loops through each pair of adjacent vectors. Each line between two adjacent vectors is divided into 4 segments by adding 3 additional vectors in-between the original two vectors. The vector in the middle is constructed through a 60 degree rotation so it is bent outwards. >>> iteration_step([np.array([0, 0]), np.array([1, 0])]) [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]","enumerate, new_vectors.append, new_vectors.append, new_vectors.append, new_vectors.append, new_vectors.append, rotate"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\koch_snowflake.py","","rotate","Standard rotation of a 2D vector with a rotation matrix (see https://en.wikipedia.org/wiki/Rotation_matrix ) >>> rotate(np.array([1, 0]), 60) array([0.5      , 0.8660254]) >>> rotate(np.array([1, 0]), 90) array([6.123234e-17, 1.000000e+00])","np.radians, np.array, np.dot, np.cos, np.sin"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\koch_snowflake.py","","plot","Utility function to plot the vectors using matplotlib.pyplot No doctest was implemented since this function does not have a return value","plt.gca, axes.set_aspect, zip, plt.plot, plt.show"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\mandelbrot.py","","get_distance","Return the relative distance (= step/max_step) after which the complex number constituted by this x-y-pair diverges. Members of the Mandelbrot set do not diverge so their distance is 1.  >>> get_distance(0, 0, 50) 1.0 >>> get_distance(0.5, 0.5, 50) 0.061224489795918366 >>> get_distance(2, 0, 50) 0.0","range"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\mandelbrot.py","","get_black_and_white_rgb","Black&white color-coding that ignores the relative distance. The Mandelbrot set is black, everything else is white.  >>> get_black_and_white_rgb(0) (255, 255, 255) >>> get_black_and_white_rgb(0.5) (255, 255, 255) >>> get_black_and_white_rgb(1) (0, 0, 0)",""
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\mandelbrot.py","","get_color_coded_rgb","Color-coding taking the relative distance into account. The Mandelbrot set is black.  >>> get_color_coded_rgb(0) (255, 0, 0) >>> get_color_coded_rgb(0.5) (0, 255, 255) >>> get_color_coded_rgb(1) (0, 0, 0)","tuple, round, colorsys.hsv_to_rgb"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\mandelbrot.py","","get_image","Function to generate the image of the Mandelbrot set. Two types of coordinates are used: image-coordinates that refer to the pixels and figure-coordinates that refer to the complex numbers inside and outside the Mandelbrot set. The figure-coordinates in the arguments of this function determine which section of the Mandelbrot set is viewed. The main area of the Mandelbrot set is roughly between ""-1.5 < x < 0.5"" and ""-1 < y < 1"" in the figure-coordinates.  Commenting out tests that slow down pytest... # 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image # >>> get_image().load()[0,0] (255, 0, 0) # >>> get_image(use_distance_color_coding = False).load()[0,0] (255, 255, 255)","Image.new, img.load, range, range, get_distance, get_color_coded_rgb, get_black_and_white_rgb"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\sierpinski_triangle.py","","get_mid","Find the midpoint of two points  >>> get_mid((0, 0), (2, 2)) (1.0, 1.0) >>> get_mid((-3, -3), (3, 3)) (0.0, 0.0) >>> get_mid((1, 0), (3, 2)) (2.0, 1.0) >>> get_mid((0, 0), (1, 1)) (0.5, 0.5) >>> get_mid((0, 0), (0, 0)) (0.0, 0.0)",""
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\sierpinski_triangle.py","","triangle","Recursively draw the Sierpinski triangle given the vertices of the triangle and the recursion depth","my_pen.up, my_pen.goto, my_pen.down, my_pen.goto, my_pen.goto, my_pen.goto, triangle, triangle, triangle, get_mid, get_mid, get_mid, get_mid, get_mid, get_mid"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\vicsek.py","","draw_cross","Draw a cross at the specified position and with the specified length.","turtle.up, turtle.goto, turtle.down, turtle.seth, turtle.begin_fill, range, turtle.end_fill, turtle.fd, turtle.right, turtle.fd, turtle.left, turtle.fd, turtle.left"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\vicsek.py","","draw_fractal_recursive","Recursively draw the Vicsek fractal at the specified position, with the specified length and depth.","draw_fractal_recursive, draw_fractal_recursive, draw_fractal_recursive, draw_fractal_recursive, draw_fractal_recursive, draw_cross"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\vicsek.py","","set_color","","turtle.color"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\vicsek.py","","draw_vicsek_fractal","Draw the Vicsek fractal at the specified position, with the specified length and depth.","turtle.speed, turtle.hideturtle, set_color, draw_fractal_recursive, .update, turtle.Screen"
"C:/Users/Joseph Dania/Desktop/python_repo\fractals\vicsek.py","","main","","draw_vicsek_fractal, turtle.done"
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","FuzzySet","","A class for representing and manipulating triangular fuzzy sets. Attributes:     name: The name or label of the fuzzy set.     left_boundary: The left boundary of the fuzzy set.     peak: The peak (central) value of the fuzzy set.     right_boundary: The right boundary of the fuzzy set. Methods:     membership(x): Calculate the membership value of an input 'x' in the fuzzy set.     union(other): Calculate the union of this fuzzy set with another fuzzy set.     intersection(other): Calculate the intersection of this fuzzy set with another.     complement(): Calculate the complement (negation) of this fuzzy set.     plot(): Plot the membership function of the fuzzy set.  >>> sheru = FuzzySet(""Sheru"", 0.4, 1, 0.6) >>> sheru FuzzySet(name='Sheru', left_boundary=0.4, peak=1, right_boundary=0.6) >>> str(sheru) 'Sheru: [0.4, 1, 0.6]'  >>> siya = FuzzySet(""Siya"", 0.5, 1, 0.7) >>> siya FuzzySet(name='Siya', left_boundary=0.5, peak=1, right_boundary=0.7)  # Complement Operation >>> sheru.complement() FuzzySet(name='Sheru', left_boundary=0.4, peak=0.6, right_boundary=0) >>> siya.complement()  # doctest: +NORMALIZE_WHITESPACE FuzzySet(name='Siya', left_boundary=0.30000000000000004, peak=0.5,  right_boundary=0)  # Intersection Operation >>> siya.intersection(sheru) FuzzySet(name='Siya  Sheru', left_boundary=0.5, peak=0.6, right_boundary=1.0)  # Membership Operation >>> sheru.membership(0.5) 0.16666666666666663 >>> sheru.membership(0.6) 0.0  # Union Operations >>> siya.union(sheru) FuzzySet(name='Siya U Sheru', left_boundary=0.4, peak=0.7, right_boundary=1.0)",""
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","","__str__",">>> FuzzySet(""fuzzy_set"", 0.1, 0.2, 0.3) FuzzySet(name='fuzzy_set', left_boundary=0.1, peak=0.2, right_boundary=0.3)",""
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","","complement","Calculate the complement (negation) of this fuzzy set. Returns:     FuzzySet: A new fuzzy set representing the complement.  >>> FuzzySet(""fuzzy_set"", 0.1, 0.2, 0.3).complement() FuzzySet(name='fuzzy_set', left_boundary=0.7, peak=0.9, right_boundary=0.8)","FuzzySet"
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","","intersection","Calculate the intersection of this fuzzy set with another fuzzy set. Args:     other: Another fuzzy set to intersect with. Returns:     A new fuzzy set representing the intersection.  >>> FuzzySet(""a"", 0.1, 0.2, 0.3).intersection(FuzzySet(""b"", 0.4, 0.5, 0.6)) FuzzySet(name='a  b', left_boundary=0.4, peak=0.3, right_boundary=0.35)","FuzzySet, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","","membership","Calculate the membership value of an input 'x' in the fuzzy set. Returns:     The membership value of 'x' in the fuzzy set.  >>> a = FuzzySet(""a"", 0.1, 0.2, 0.3) >>> a.membership(0.09) 0.0 >>> a.membership(0.1) 0.0 >>> a.membership(0.11) 0.09999999999999995 >>> a.membership(0.4) 0.0 >>> FuzzySet(""A"", 0, 0.5, 1).membership(0.1) 0.2 >>> FuzzySet(""B"", 0.2, 0.7, 1).membership(0.6) 0.8","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","","union","Calculate the union of this fuzzy set with another fuzzy set. Args:     other (FuzzySet): Another fuzzy set to union with. Returns:     FuzzySet: A new fuzzy set representing the union.  >>> FuzzySet(""a"", 0.1, 0.2, 0.3).union(FuzzySet(""b"", 0.4, 0.5, 0.6)) FuzzySet(name='a U b', left_boundary=0.1, peak=0.6, right_boundary=0.35)","FuzzySet, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\fuzzy_logic\fuzzy_operations.py","","plot","Plot the membership function of the fuzzy set.","np.linspace, plt.plot, self.membership"
"C:/Users/Joseph Dania/Desktop/python_repo\genetic_algorithm\basic_string.py","","evaluate","Evaluate how similar the item is with the target by just counting each char in the right position >>> evaluate(""Helxo Worlx"", ""Hello World"") ('Helxo Worlx', 9.0)","len, float, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\genetic_algorithm\basic_string.py","","crossover","Slice and combine two strings at a random point. >>> random.seed(42) >>> crossover(""123456"", ""abcdef"") ('12345f', 'abcde6')","random.randint, len"
"C:/Users/Joseph Dania/Desktop/python_repo\genetic_algorithm\basic_string.py","","mutate","Mutate a random gene of a child with another one from the list. >>> random.seed(123) >>> mutate(""123456"", list(""ABCDEF"")) '12345A'","list, .join, random.uniform, random.choice, random.randint, len"
"C:/Users/Joseph Dania/Desktop/python_repo\genetic_algorithm\basic_string.py","","select","Select the second parent and generate new population  >>> random.seed(42) >>> parent_1 = (""123456"", 8.0) >>> population_score = [(""abcdef"", 4.0), (""ghijkl"", 5.0), (""mnopqr"", 7.0)] >>> genes = list(""ABCDEF"") >>> child_n = int(min(parent_1[1] + 1, 10)) >>> population = [] >>> for _ in range(child_n): ...     parent_2 = population_score[random.randrange(len(population_score))][0] ...     child_1, child_2 = crossover(parent_1[0], parent_2) ...     population.extend((mutate(child_1, genes), mutate(child_2, genes))) >>> len(population) == (int(parent_1[1]) + 1) * 2 True","range, int, crossover, pop.append, pop.append, mutate, mutate, random.randint"
"C:/Users/Joseph Dania/Desktop/python_repo\genetic_algorithm\basic_string.py","","basic","Verify that the target contains no genes besides the ones inside genes variable.  >>> from string import ascii_lowercase >>> basic(""doctest"", ascii_lowercase, debug=False)[2] 'doctest' >>> genes = list(ascii_lowercase) >>> genes.remove(""e"") >>> basic(""test"", genes) Traceback (most recent call last):     ... ValueError: ['e'] is not in genes list, evolution cannot converge >>> genes.remove(""s"") >>> basic(""test"", genes) Traceback (most recent call last):     ... ValueError: ['e', 's'] is not in genes list, evolution cannot converge >>> genes.remove(""t"") >>> basic(""test"", genes) Traceback (most recent call last):     ... ValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge","sorted, range, ValueError, ValueError, population.append, len, sorted, population.clear, population.extend, range, .join, evaluate, print, population.extend, int, select, len, random.choice, len, range, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\geodesy\haversine_distance.py","","haversine_distance","Calculate great circle distance between two points in a sphere, given longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula  We know that the globe is ""sort of"" spherical, so a path between two points isn't exactly a straight line. We need to account for the Earth's curvature when calculating distance from point A to B. This effect is negligible for small distances but adds up as distance increases. The Haversine method treats the earth as a sphere which allows us to ""project"" the two points A and B onto the surface of that sphere and approximate the spherical distance between them. Since the Earth is not a perfect sphere, other methods which model the Earth's ellipsoidal nature are more accurate but a quick and modifiable computation like Haversine can be handy for shorter range distances.  Args:     * `lat1`, `lon1`: latitude and longitude of coordinate 1     * `lat2`, `lon2`: latitude and longitude of coordinate 2 Returns:     geographical distance between two points in metres  >>> from collections import namedtuple >>> point_2d = namedtuple(""point_2d"", ""lat lon"") >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227) >>> YOSEMITE = point_2d(37.864742, -119.537521) >>> f""{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters"" '254,352 meters'","atan, atan, radians, radians, sin, sin, sqrt, asin, tan, tan, radians, radians, cos, cos"
"C:/Users/Joseph Dania/Desktop/python_repo\geodesy\lamberts_ellipsoidal_distance.py","","lamberts_ellipsoidal_distance","Calculate the shortest distance along the surface of an ellipsoid between two points on the surface of earth given longitudes and latitudes https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines  NOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,     sigma  Representing the earth as an ellipsoid allows us to approximate distances between points on the surface much better than a sphere. Ellipsoidal formulas treat the Earth as an oblate ellipsoid which means accounting for the flattening that happens at the North and South poles. Lambert's formulae provide accuracy on the order of 10 meteres over thousands of kilometeres. Other methods can provide millimeter-level accuracy but this is a simpler method to calculate long range distances without increasing computational intensity.  Args:     lat1, lon1: latitude and longitude of coordinate 1     lat2, lon2: latitude and longitude of coordinate 2 Returns:     geographical distance between two points in metres  >>> from collections import namedtuple >>> point_2d = namedtuple(""point_2d"", ""lat lon"") >>> SAN_FRANCISCO = point_2d(37.774856, -122.424227) >>> YOSEMITE = point_2d(37.864742, -119.537521) >>> NEW_YORK = point_2d(40.713019, -74.012647) >>> VENICE = point_2d(45.443012, 12.313071) >>> f""{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters"" '254,351 meters' >>> f""{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters"" '4,138,992 meters' >>> f""{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters"" '9,737,326 meters'","atan, atan, haversine_distance, cos, sin, tan, tan, sin, cos, sin, cos, sin, sin, radians, radians"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Angle","","An Angle in degrees (unit of measurement)  >>> Angle() Angle(degrees=90) >>> Angle(45.5) Angle(degrees=45.5) >>> Angle(-1) Traceback (most recent call last):     ... TypeError: degrees must be a numeric value between 0 and 360. >>> Angle(361) Traceback (most recent call last):     ... TypeError: degrees must be a numeric value between 0 and 360.",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Side","","A side of a two dimensional Shape such as Polygon, etc. adjacent_sides: a list of sides which are adjacent to the current side angle: the angle in degrees between each adjacent side length: the length of the current side in meters  >>> Side(5) Side(length=5, angle=Angle(degrees=90), next_side=None) >>> Side(5, Angle(45.6)) Side(length=5, angle=Angle(degrees=45.6), next_side=None) >>> Side(5, Angle(45.6), Side(1, Angle(2)))  # doctest: +ELLIPSIS Side(length=5, angle=Angle(degrees=45.6), next_side=Side(length=1, angle=Angle(d... >>> Side(-1) Traceback (most recent call last):     ... TypeError: length must be a positive numeric value. >>> Side(5, None) Traceback (most recent call last):     ... TypeError: angle must be an Angle object. >>> Side(5, Angle(90), ""Invalid next_side"") Traceback (most recent call last):     ... TypeError: next_side must be a Side or None.",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Ellipse","","A geometric Ellipse on a 2D surface  >>> Ellipse(5, 10) Ellipse(major_radius=5, minor_radius=10) >>> Ellipse(5, 10) is Ellipse(5, 10) False >>> Ellipse(5, 10) == Ellipse(5, 10) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Circle","","A geometric Circle on a 2D surface  >>> Circle(5) Circle(radius=5) >>> Circle(5) is Circle(5) False >>> Circle(5) == Circle(5) True >>> Circle(5).area 78.53981633974483 >>> Circle(5).perimeter 31.41592653589793",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Polygon","","An abstract class which represents Polygon on a 2D surface.  >>> Polygon() Polygon(sides=[]) >>> polygon = Polygon() >>> polygon.add_side(Side(5)).get_side(0) Side(length=5, angle=Angle(degrees=90), next_side=None) >>> polygon.get_side(1) Traceback (most recent call last):     ... IndexError: list index out of range >>> polygon.set_side(0, Side(10)).get_side(0) Side(length=10, angle=Angle(degrees=90), next_side=None) >>> polygon.set_side(1, Side(10)) Traceback (most recent call last):     ... IndexError: list assignment index out of range",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Rectangle","","A geometric rectangle on a 2D surface.  >>> rectangle_one = Rectangle(5, 10) >>> rectangle_one.perimeter() 30 >>> rectangle_one.area() 50 >>> Rectangle(-5, 10) Traceback (most recent call last):     ... TypeError: length must be a positive numeric value.",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","Square","","a structure which represents a geometrical square on a 2D surface >>> square_one = Square(5) >>> square_one.perimeter() 20 >>> square_one.area() 25",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","__post_init__","","TypeError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","__post_init__","","TypeError, isinstance, TypeError, isinstance, TypeError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","area",">>> Ellipse(5, 10).area 157.07963267948966",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","perimeter",">>> Ellipse(5, 10).perimeter 47.12388980384689",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","diameter",">>> Circle(5).diameter 10",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","max_parts","Return the maximum number of parts that circle can be divided into if cut 'num_cuts' times.  >>> circle = Circle(5) >>> circle.max_parts(0) 1.0 >>> circle.max_parts(7) 29.0 >>> circle.max_parts(54) 1486.0 >>> circle.max_parts(22.5) 265.375 >>> circle.max_parts(-222) Traceback (most recent call last):     ... TypeError: num_cuts must be a positive numeric value. >>> circle.max_parts(""-222"") Traceback (most recent call last):     ... TypeError: num_cuts must be a positive numeric value.","TypeError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","add_side",">>> Polygon().add_side(Side(5)) Polygon(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None)])","self.sides.append"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","get_side",">>> Polygon().get_side(0) Traceback (most recent call last):     ... IndexError: list index out of range >>> Polygon().add_side(Side(5)).get_side(-1) Side(length=5, angle=Angle(degrees=90), next_side=None)",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","set_side",">>> Polygon().set_side(0, Side(5)) Traceback (most recent call last):     ... IndexError: list assignment index out of range >>> Polygon().add_side(Side(5)).set_side(0, Side(10)) Polygon(sides=[Side(length=10, angle=Angle(degrees=90), next_side=None)])",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","__init__","",".__init__, self.post_init, super"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","post_init",">>> Rectangle(5, 10)  # doctest: +NORMALIZE_WHITESPACE Rectangle(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None), Side(length=10, angle=Angle(degrees=90), next_side=None)])","Side, Side, .add_side, .add_side, super, super"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","perimeter","",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","area","",""
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","perimeter","",".perimeter, super"
"C:/Users/Joseph Dania/Desktop/python_repo\geometry\geometry.py","","area","",".area, super"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\bezier_curve.py","BezierCurve","","Bezier curve is a weighted sum of a set of control points. Generate Bezier curves from a given set of control points. This implementation works only for 2d coordinates in the xy plane.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\bezier_curve.py","","__init__","list_of_points: Control points in the xy plane on which to interpolate. These     points control the behavior (shape) of the Bezier curve.","len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\bezier_curve.py","","basis_function","The basis function determines the weight of each control point at time t.     t: time value between 0 and 1 inclusive at which to evaluate the basis of        the curve. returns the x, y values of basis function at time t  >>> curve = BezierCurve([(1,1), (1,2)]) >>> [float(x) for x in curve.basis_function(0)] [1.0, 0.0] >>> [float(x) for x in curve.basis_function(1)] [0.0, 1.0]","range, len, output_values.append, round, sum, comb"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\bezier_curve.py","","bezier_curve_function","The function to produce the values of the Bezier curve at time t.     t: the value of time t at which to evaluate the Bezier function Returns the x, y coordinates of the Bezier curve at time t.     The first point in the curve is when t = 0.     The last point in the curve is when t = 1.  >>> curve = BezierCurve([(1,1), (1,2)]) >>> tuple(float(x) for x in curve.bezier_curve_function(0)) (1.0, 1.0) >>> tuple(float(x) for x in curve.bezier_curve_function(1)) (1.0, 2.0)","self.basis_function, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\bezier_curve.py","","plot_curve","Plots the Bezier curve using matplotlib plotting capabilities.     step_size: defines the step(s) at which to evaluate the Bezier curve.     The smaller the step size, the finer the curve produced.","plt.plot, plt.scatter, plt.legend, plt.show, self.bezier_curve_function, to_plot_x.append, to_plot_y.append, str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\butterfly_pattern.py","","butterfly_pattern","Creates a butterfly pattern of size n and returns it as a string.  >>> print(butterfly_pattern(3)) *   * ** ** ***** ** ** *   * >>> print(butterfly_pattern(5)) *       * **     ** ***   *** **** **** ********* **** **** ***   *** **     ** *       *","range, result.append, range, .join, result.append, result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\digital_differential_analyzer_line.py","","digital_differential_analyzer_line","Draws a line between two points using the DDA algorithm.  Args: - p1: Coordinates of the starting point. - p2: Coordinates of the ending point. Returns: - List of coordinate points that form the line.  >>> digital_differential_analyzer_line((1, 1), (4, 4)) [(2, 2), (3, 3), (4, 4)]","max, range, abs, abs, float, float, coordinates.append, round, round"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\vector3_for_2d_rendering.py","","convert_to_2d","Converts 3d point to a 2d drawable point  >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0) (7.6923076923076925, 15.384615384615385)  >>> convert_to_2d(1, 2, 3, 10, 10) (7.6923076923076925, 15.384615384615385)  >>> convert_to_2d(""1"", 2, 3, 10, 10)  # '1' is str Traceback (most recent call last):     ... TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]","all, TypeError, isinstance, list, .values, .values, locals, locals"
"C:/Users/Joseph Dania/Desktop/python_repo\graphics\vector3_for_2d_rendering.py","","rotate","rotate a point around a certain axis with a certain angle angle can be any integer between 1, 360 and axis can be any one of 'x', 'y', 'z'  >>> rotate(1.0, 2.0, 3.0, 'y', 90.0) (3.130524675073759, 2.0, 0.4470070007889556)  >>> rotate(1, 2, 3, ""z"", 180) (0.999736015495891, -2.0001319704760485, 3)  >>> rotate('1', 2, 3, ""z"", 90.0)  # '1' is str Traceback (most recent call last):     ... TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]  >>> rotate(1, 2, 3, ""n"", 90)  # 'n' is not a valid axis Traceback (most recent call last):     ... ValueError: not a valid axis, choose one of 'x', 'y', 'z'  >>> rotate(1, 2, 3, ""x"", -90) (1, -2.5049096187183877, -2.5933429780983657)  >>> rotate(1, 2, 3, ""x"", 450)  # 450 wrap around to 90 (1, 3.5776792428178217, -0.44744970165427644)","locals, isinstance, TypeError, all, TypeError, isinstance, list, math.cos, math.sin, math.cos, math.sin, ValueError, input_variables.values, input_variables.values, math.cos, math.sin, math.cos, math.sin, math.cos, math.sin, math.cos, math.sin"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\ant_colony_optimization_algorithms.py","","main","Ant colony algorithm main function >>> main(cities=cities, ants_num=10, iterations_num=20, ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10) ([0, 1, 2, 3, 4, 5, 6, 7, 0], 37.909778143828696) >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5, ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10) ([0, 1, 0], 5.656854249492381) >>> main(cities={0: [0, 0], 1: [2, 2], 4: [4, 4]}, ants_num=5, iterations_num=5, ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10) Traceback (most recent call last):   ... IndexError: list index out of range >>> main(cities={}, ants_num=5, iterations_num=5, ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10) Traceback (most recent call last):   ... StopIteration >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=0, iterations_num=5, ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10) ([], inf) >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=0, ...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10) ([], inf) >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5, ...      pheromone_evaporation=1, alpha=1.0, beta=5.0, q=10) ([0, 1, 0], 5.656854249492381) >>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5, ...      pheromone_evaporation=0, alpha=1.0, beta=5.0, q=10) ([0, 1, 0], 5.656854249492381)","len, float, range, range, pheromone_update, copy.deepcopy, ant_route.append, ants_route.append, next, next, next, next, city_select, ant_route.append, iter, iter, iter, iter, next, cities.keys, cities.values, current_city.keys, current_city.keys, iter, current_city.keys"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\ant_colony_optimization_algorithms.py","","distance","Calculate the distance between two coordinate points >>> distance([0, 0], [3, 4] ) 5.0 >>> distance([0, 0], [-3, 4] ) 5.0 >>> distance([0, 0], [-3, -4] ) 5.0",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\ant_colony_optimization_algorithms.py","","pheromone_update","Update pheromones on the route and update the best route >>> >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]], ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7, ...                  ants_route=[[0, 1, 0]], q=10, best_path=[], ...                  best_distance=float(""inf"")) ([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381) >>> pheromone_update(pheromone=[], ...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7, ...                  ants_route=[[0, 1, 0]], q=10, best_path=[], ...                  best_distance=float(""inf"")) Traceback (most recent call last):   ... IndexError: list index out of range >>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]], ...                  cities={}, pheromone_evaporation=0.7, ...                  ants_route=[[0, 1, 0]], q=10, best_path=[], ...                  best_distance=float(""inf"")) Traceback (most recent call last):   ... KeyError: 0","range, len, range, range, range, len, distance, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\ant_colony_optimization_algorithms.py","","city_select","Choose the next city for ants >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]}, ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0) ({1: [2, 2]}, {}) >>> city_select(pheromone=[], current_city={0: [0,0]}, ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0) Traceback (most recent call last):   ... IndexError: list index out of range >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={}, ...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0) Traceback (most recent call last):   ... StopIteration >>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]}, ...             unvisited_cities={}, alpha=1.0, beta=5.0) Traceback (most recent call last):   ... IndexError: list index out of range","unvisited_cities.items, distance, probabilities.append, random.choices, next, next, list, iter, iter, unvisited_cities.keys, chosen_city.keys, current_city.values, next, iter, current_city.keys"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\articulation_points.py","","compute_ap","","len, range, range, len, dfs, print, dfs, min, min"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\articulation_points.py","","dfs","","dfs, min, min"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\a_star.py","","search","Search for a path on a grid avoiding obstacles. >>> grid = [[0, 1, 0, 0, 0, 0], ...         [0, 1, 0, 0, 0, 0], ...         [0, 1, 0, 0, 0, 0], ...         [0, 1, 0, 0, 1, 0], ...         [0, 0, 0, 0, 1, 0]] >>> init = [0, 0] >>> goal = [len(grid) - 1, len(grid[0]) - 1] >>> cost = 1 >>> heuristic = [[0] * len(grid[0]) for _ in range(len(grid))] >>> heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))] >>> for i in range(len(grid)): ...     for j in range(len(grid[0])): ...         heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1]) ...         if grid[i][j] == 1: ...             heuristic[i][j] = 99 >>> path, action = search(grid, init, goal, cost, heuristic) >>> path  # doctest: +NORMALIZE_WHITESPACE [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [3, 3], [2, 3], [2, 4], [2, 5], [3, 5], [4, 5]] >>> action  # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 3], [2, 0, 0, 0, 0, 2], [2, 3, 3, 3, 0, 2]]","invpath.append, range, invpath.append, len, path.append, range, range, len, ValueError, cell.sort, cell.reverse, cell.pop, range, len, range, len, range, len, len, len, cell.append, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","_input","",".split, .strip, input"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","initialize_unweighted_directed_graph","","range, range, .append, int, _input"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","initialize_unweighted_undirected_graph","","range, range, .append, .append, int, _input"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","initialize_weighted_undirected_graph","","range, range, .append, .append, int, _input"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","dfs",">>> dfs({1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []}, 1) 1 2 4 5 3","print, _s.pop, _s.append, vis.add, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","bfs",">>> bfs({1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []}, 1) 1 2 3 4 5 6 7 8","print, deque, q.popleft, vis.add, q.append, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","dijk","dijk({1: [(2, 7), (3, 9), (6, 14)],     2: [(1, 7), (3, 10), (4, 15)],     3: [(1, 9), (2, 10), (4, 11), (6, 2)],     4: [(2, 15), (3, 11), (5, 6)],     5: [(4, 6), (6, 9)],     6: [(1, 14), (3, 2), (5, 9)]}, 1) 7 9 11 20 20","dist.items, set, known.add, len, print, len, dist.get"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","topo","","q.popleft, print, topo, deque, len, q.append, len, q.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","adjm","Reading an Adjacency matrix  Parameters:     None  Returns:     tuple: A tuple containing a list of edges and number of edges  Example: >>> # Simulate user input for 3 nodes >>> input_data = ""4\n0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0\n"" >>> import sys,io >>> original_input = sys.stdin >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing >>> adjm() ([(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)], 4) >>> sys.stdin = original_input  # Restore original stdin","int, range, .strip, a.append, tuple, input, map, .split, .strip, input"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","floy","","list, range, print, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","prim","","set, dist.items, known.add, len, len, dist.get"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","edglist","Get the edges and number of edges from the user  Parameters:     None  Returns:     tuple: A tuple containing a list of edges and number of edges  Example: >>> # Simulate user input for 3 edges and 4 vertices: (1, 2), (2, 3), (3, 4) >>> input_data = ""4 3\n1 2\n2 3\n3 4\n"" >>> import sys,io >>> original_input = sys.stdin >>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing >>> edglist() ([(1, 2), (2, 3), (3, 4)], 4) >>> sys.stdin = original_input  # Restore original stdin","tuple, range, map, edges.append, .split, tuple, map, input, .split, input"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","krusk","Sort edges on the basis of distance","e.sort, print, e.pop, range, range, range, len, len, len, .update, s.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\basic_graphs.py","","find_isolated_nodes","Find the isolated node in the graph  Parameters: graph (dict): A dictionary representing a graph.  Returns: list: A list of isolated nodes.  Examples: >>> graph1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []} >>> find_isolated_nodes(graph1) [4]  >>> graph2 = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A'], 'D': []} >>> find_isolated_nodes(graph2) ['D']  >>> graph3 = {'X': [], 'Y': [], 'Z': []} >>> find_isolated_nodes(graph3) ['X', 'Y', 'Z']  >>> graph4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]} >>> find_isolated_nodes(graph4) []  >>> graph5 = {} >>> find_isolated_nodes(graph5) []","isolated.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bellman_ford.py","","print_distance","","print, enumerate, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bellman_ford.py","","check_negative_cycle","","range, float"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bellman_ford.py","","bellman_ford","Returns shortest paths from a vertex src to all other vertices. >>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)] >>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges] >>> bellman_ford(g, 4, 4, 0) [0.0, -2.0, 8.0, 5.0] >>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges + [(1, 3, 5)]] >>> bellman_ford(g, 4, 5, 0) Traceback (most recent call last):  ... Exception: Negative cycle found","range, check_negative_cycle, range, Exception, float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","Node","",">>> k = Node(0, 0, 4, 3, 0, None) >>> k.calculate_heuristic() 5.0 >>> n = Node(1, 4, 3, 4, 2, None) >>> n.calculate_heuristic() 2.0 >>> l = [k, n] >>> n == l[0] False >>> l.sort() >>> n == l[0] True",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","AStar","",">>> astar = AStar((0, 0), (len(grid) - 1, len(grid[0]) - 1)) >>> (astar.start.pos_y + delta[3][0], astar.start.pos_x + delta[3][1]) (0, 1) >>> [x.pos for x in astar.get_successors(astar.start)] [(1, 0), (0, 1)] >>> (astar.start.pos_y + delta[2][0], astar.start.pos_x + delta[2][1]) (1, 0) >>> astar.retrace_path(astar.start) [(0, 0)] >>> astar.search()  # doctest: +NORMALIZE_WHITESPACE [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3),  (4, 3), (4, 4), (5, 4), (5, 5), (6, 5), (6, 6)]",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","BidirectionalAStar","",">>> bd_astar = BidirectionalAStar((0, 0), (len(grid) - 1, len(grid[0]) - 1)) >>> bd_astar.fwd_astar.start.pos == bd_astar.bwd_astar.target.pos True >>> bd_astar.retrace_bidirectional_path(bd_astar.fwd_astar.start, ...                                     bd_astar.bwd_astar.start) [(0, 0)] >>> bd_astar.search()  # doctest: +NORMALIZE_WHITESPACE [(0, 0), (0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (2, 4),  (2, 5), (3, 5), (4, 5), (5, 5), (5, 6), (6, 6)]",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","__init__","","self.calculate_heuristic"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","calculate_heuristic","Heuristic for the A*","sqrt, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","__init__","","Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","search","","self.open_nodes.sort, self.open_nodes.pop, self.closed_nodes.append, self.get_successors, self.retrace_path, self.open_nodes.append, self.open_nodes.pop, self.open_nodes.index, self.open_nodes.append, self.open_nodes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","get_successors","Returns a list of successors (both in the grid and free spaces)","successors.append, Node, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","retrace_path","Retrace the path from parents to parents until start node","path.reverse, path.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","__init__","","AStar, AStar"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","search","","self.fwd_astar.open_nodes.sort, self.bwd_astar.open_nodes.sort, self.fwd_astar.open_nodes.pop, self.bwd_astar.open_nodes.pop, self.fwd_astar.closed_nodes.append, self.bwd_astar.closed_nodes.append, self.retrace_bidirectional_path, self.fwd_astar.get_successors, self.bwd_astar.get_successors, astar.open_nodes.append, astar.open_nodes.pop, astar.open_nodes.index, astar.open_nodes.append, astar.open_nodes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_a_star.py","","retrace_bidirectional_path","","self.fwd_astar.retrace_path, self.bwd_astar.retrace_path, bwd_path.pop, bwd_path.reverse"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","BreadthFirstSearch","","# Comment out slow pytests... # 9.15s call     graphs/bidirectional_breadth_first_search.py::     #                graphs.bidirectional_breadth_first_search.BreadthFirstSearch # >>> bfs = BreadthFirstSearch((0, 0), (len(grid) - 1, len(grid[0]) - 1)) # >>> (bfs.start.pos_y + delta[3][0], bfs.start.pos_x + delta[3][1]) (0, 1) # >>> [x.pos for x in bfs.get_successors(bfs.start)] [(1, 0), (0, 1)] # >>> (bfs.start.pos_y + delta[2][0], bfs.start.pos_x + delta[2][1]) (1, 0) # >>> bfs.retrace_path(bfs.start) [(0, 0)] # >>> bfs.search()  # doctest: +NORMALIZE_WHITESPACE [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 1),  (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (6, 5), (6, 6)]",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","BidirectionalBreadthFirstSearch","",">>> bd_bfs = BidirectionalBreadthFirstSearch((0, 0), (len(grid) - 1, ...                                                   len(grid[0]) - 1)) >>> bd_bfs.fwd_bfs.start.pos == bd_bfs.bwd_bfs.target.pos True >>> bd_bfs.retrace_bidirectional_path(bd_bfs.fwd_bfs.start, ...                                     bd_bfs.bwd_bfs.start) [(0, 0)] >>> bd_bfs.search()  # doctest: +NORMALIZE_WHITESPACE [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3),  (2, 4), (3, 4), (3, 5), (3, 6), (4, 6), (5, 6), (6, 6)]",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","__init__","","Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","search","","self.node_queue.pop, self.get_successors, self.retrace_path, self.node_queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","get_successors","Returns a list of successors (both in the grid and free spaces)","successors.append, Node, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","retrace_path","Retrace the path from parents to parents until start node","path.reverse, path.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","__init__","","BreadthFirstSearch, BreadthFirstSearch"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","search","","self.fwd_bfs.node_queue.pop, self.bwd_bfs.node_queue.pop, self.retrace_bidirectional_path, self.fwd_bfs.get_successors, self.bwd_bfs.get_successors, bfs.node_queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_breadth_first_search.py","","retrace_bidirectional_path","","self.fwd_bfs.retrace_path, self.bwd_bfs.retrace_path, bwd_path.pop, bwd_path.reverse"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_search.py","","expand_search","","queue.popleft, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_search.py","","construct_path","","path.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_search.py","","bidirectional_search","Perform bidirectional search on a graph to find the shortest path.  Args:     graph: A dictionary where keys are nodes and values are lists of adjacent nodes     start: The starting node     goal: The target node  Returns:     A list representing the path from start to goal, or None if no path exists  Examples:     >>> graph = {     ...     0: [1, 2],     ...     1: [0, 3, 4],     ...     2: [0, 5, 6],     ...     3: [1, 7],     ...     4: [1, 8],     ...     5: [2, 9],     ...     6: [2, 10],     ...     7: [3, 11],     ...     8: [4, 11],     ...     9: [5, 11],     ...     10: [6, 11],     ...     11: [7, 8, 9, 10],     ... }     >>> bidirectional_search(graph=graph, start=0, goal=11)     [0, 1, 3, 7, 11]     >>> bidirectional_search(graph=graph, start=5, goal=5)     [5]     >>> disconnected_graph = {     ...     0: [1, 2],     ...     1: [0],     ...     2: [0],     ...     3: [4],     ...     4: [3],     ... }     >>> bidirectional_search(graph=disconnected_graph, start=0, goal=3) is None     True","deque, deque, construct_path, forward_path.reverse, construct_path, expand_search, expand_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bidirectional_search.py","","main","Run example of bidirectional search algorithm.  Examples:     >>> main()  # doctest: +NORMALIZE_WHITESPACE     Path from 0 to 11: [0, 1, 3, 7, 11]     Path from 5 to 5: [5]     Path from 0 to 3: None","bidirectional_search, print, bidirectional_search, print, bidirectional_search, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bi_directional_dijkstra.py","","pass_and_relaxation","","cst_fwd.get, queue.put"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\bi_directional_dijkstra.py","","bidirectional_dij","Bi-directional Dijkstra's algorithm.  Returns:     shortest_path_distance (int): length of the shortest path.  Warnings:     If the destination is not reachable, function returns -1  >>> bidirectional_dij(""E"", ""F"", graph_fwd, graph_bwd) 3","set, set, PriorityQueue, PriorityQueue, queue_forward.put, queue_backward.put, queue_forward.get, visited_forward.add, queue_backward.get, visited_backward.add, pass_and_relaxation, pass_and_relaxation, queue_forward.empty, queue_backward.empty"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","test_vector",">>> g = Graph(8) >>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4), ...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)): ...        g.add_edge(*u_v_w) >>> g.boruvka() Added edge [0 - 3] Added weight: 5 <BLANKLINE> Added edge [0 - 1] Added weight: 10 <BLANKLINE> Added edge [2 - 3] Added weight: 4 <BLANKLINE> Added edge [4 - 7] Added weight: 5 <BLANKLINE> Added edge [4 - 5] Added weight: 10 <BLANKLINE> Added edge [6 - 7] Added weight: 4 <BLANKLINE> Added edge [3 - 4] Added weight: 8 <BLANKLINE> The total weight of the minimal spanning tree is: 46",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","__init__","Arguments:     num_of_nodes - the number of nodes in the graph Attributes:     m_num_of_nodes - the number of nodes in the graph.     m_edges - the list of edges.     m_component - the dictionary which stores the index of the component which     a node belongs to.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","add_edge","Adds an edge in the format [first, second, edge weight] to graph.","self.m_edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","find_component","Propagates a new component throughout a given component.","self.find_component"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","set_component","Finds the component index of a given node","self.find_component"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","union","Union finds the roots of components for two nodes, compares the components in terms of size, and attaches the smaller one to the larger one to form single component","self.set_component, self.find_component, self.set_component"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\boruvka.py","","boruvka","Performs Borvka's algorithm to find MST.","range, print, self.m_component.update, component_size.append, isinstance, self.union, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search.py","","print_graph","prints adjacency list representation of graaph >>> g = Graph() >>> g.print_graph() >>> g.add_edge(0, 1) >>> g.print_graph() 0  :  1","print, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search.py","","add_edge","adding the edge between two vertices >>> g = Graph() >>> g.print_graph() >>> g.add_edge(0, 1) >>> g.print_graph() 0  :  1",".append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search.py","","bfs",">>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> sorted(g.bfs(2)) [0, 1, 2, 3]","set, Queue, visited.add, queue.put, queue.empty, queue.get, queue.put, visited.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_2.py","","breadth_first_search","Implementation of breadth first search using queue.Queue.  >>> ''.join(breadth_first_search(G, 'A')) 'ABCDEF'","Queue, queue.put, queue.empty, queue.get, explored.add, result.append, queue.put"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_2.py","","breadth_first_search_with_deque","Implementation of breadth first search using collection.queue.  >>> ''.join(breadth_first_search_with_deque(G, 'A')) 'ABCDEF'","deque, queue.popleft, visited.add, result.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_2.py","","benchmark_function","","timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_shortest_path.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_shortest_path.py","","__init__","Graph is implemented as dictionary of adjacency lists. Also, Source vertex have to be defined upon initialization.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_shortest_path.py","","breath_first_search","This function is a helper for running breath first search on this graph. >>> g = Graph(graph, ""G"") >>> g.breath_first_search() >>> g.parent {'G': None, 'C': 'G', 'A': 'C', 'F': 'C', 'B': 'A', 'E': 'A', 'D': 'B'}","queue.pop, visited.add, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_shortest_path.py","","shortest_path","This shortest path function returns a string, describing the result: 1.) No path is found. The string is a human readable message to indicate this. 2.) The shortest path is found. The string is in the form     `v1(->v2->v3->...->vn)`, where v1 is the source vertex and vn is the target     vertex, if it exists separately.  >>> g = Graph(graph, ""G"") >>> g.breath_first_search()  Case 1 - No path is found. >>> g.shortest_path(""Foo"") Traceback (most recent call last):     ... ValueError: No path from vertex: G to vertex: Foo  Case 2 - The path is found. >>> g.shortest_path(""D"") 'G->C->A->B->D' >>> g.shortest_path(""G"") 'G'","self.parent.get, ValueError, self.shortest_path"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_shortest_path_2.py","","bfs_shortest_path","Find the shortest path between `start` and `goal` nodes. Args:     graph (dict): node/list of neighboring nodes key/value pairs.     start: start node.     goal: target node. Returns:     Shortest path between `start` and `goal` nodes as a string of nodes.     'Not found' string if no path found. Example:     >>> bfs_shortest_path(demo_graph, ""G"", ""D"")     ['G', 'C', 'A', 'B', 'D']     >>> bfs_shortest_path(demo_graph, ""G"", ""G"")     ['G']     >>> bfs_shortest_path(demo_graph, ""G"", ""Unknown"")     []","set, deque, queue.popleft, explored.add, list, new_path.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_shortest_path_2.py","","bfs_shortest_path_distance","Find the shortest path distance between `start` and `target` nodes. Args:     graph: node/list of neighboring nodes key/value pairs.     start: node to start search from.     target: node to search for. Returns:     Number of edges in the shortest path between `start` and `target` nodes.     -1 if no path exists. Example:     >>> bfs_shortest_path_distance(demo_graph, ""G"", ""D"")     4     >>> bfs_shortest_path_distance(demo_graph, ""A"", ""A"")     0     >>> bfs_shortest_path_distance(demo_graph, ""A"", ""Unknown"")     -1","deque, set, queue.popleft, min, visited.add, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","Edge","","Weighted directed graph edge.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","AdjacencyList","","Graph adjacency list.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","","__init__","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","","__getitem__","Get all the vertices adjacent to the given one.","iter"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","","size","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","","add_edge",">>> g = AdjacencyList(2) >>> g.add_edge(0, 1, 0) >>> g.add_edge(1, 0, 1) >>> list(g[0]) [Edge(destination_vertex=1, weight=0)] >>> list(g[1]) [Edge(destination_vertex=0, weight=1)] >>> g.add_edge(0, 1, 2) Traceback (most recent call last):     ... ValueError: Edge weight must be either 0 or 1. >>> g.add_edge(0, 2, 1) Traceback (most recent call last):     ... ValueError: Vertex indexes must be in [0; size).",".append, ValueError, ValueError, Edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\breadth_first_search_zero_one_shortest_path.py","","get_shortest_path","Return the shortest distance from start_vertex to finish_vertex in 0-1-graph.       1                  1         1  0--------->3        6--------7>------->8  |          ^        ^        ^         |1  |          |        |        |0        v 0|          |0      1|        9-------->10  |          |        |        ^    1  v          |        |        |0  1--------->2<-------4------->5       0         1        1 >>> g = AdjacencyList(11) >>> g.add_edge(0, 1, 0) >>> g.add_edge(0, 3, 1) >>> g.add_edge(1, 2, 0) >>> g.add_edge(2, 3, 0) >>> g.add_edge(4, 2, 1) >>> g.add_edge(4, 5, 1) >>> g.add_edge(4, 6, 1) >>> g.add_edge(5, 9, 0) >>> g.add_edge(6, 7, 1) >>> g.add_edge(7, 8, 1) >>> g.add_edge(8, 10, 1) >>> g.add_edge(9, 7, 0) >>> g.add_edge(9, 10, 1) >>> g.add_edge(1, 2, 2) Traceback (most recent call last):     ... ValueError: Edge weight must be either 0 or 1. >>> g.get_shortest_path(0, 3) 0 >>> g.get_shortest_path(0, 4) Traceback (most recent call last):     ... ValueError: No path from start_vertex to finish_vertex. >>> g.get_shortest_path(4, 10) 2 >>> g.get_shortest_path(4, 8) 2 >>> g.get_shortest_path(0, 1) 0 >>> g.get_shortest_path(1, 0) Traceback (most recent call last):     ... ValueError: No path from start_vertex to finish_vertex.","deque, queue.popleft, ValueError, isinstance, queue.appendleft, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\check_bipatrite.py","","is_bipartite_dfs","Check if a graph is bipartite using depth-first search (DFS).  Args:     `graph`: Adjacency list representing the graph.  Returns:     ``True`` if bipartite, ``False`` otherwise.  Checks if the graph can be divided into two sets of vertices, such that no two vertices within the same set are connected by an edge.  Examples:  >>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 4]}) True >>> is_bipartite_dfs({0: [1, 2], 1: [0, 3], 2: [0, 1]}) False >>> is_bipartite_dfs({}) True >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}) True >>> is_bipartite_dfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]}) False >>> is_bipartite_dfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]}) True >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]}) False >>> is_bipartite_dfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]}) False  >>> # FIXME: This test should fails with KeyError: 4. >>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]}) False >>> is_bipartite_dfs({0: [-1, 3], 1: [0, -2]}) False >>> is_bipartite_dfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]}) True >>> is_bipartite_dfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}) True  >>> # FIXME: This test should fails with >>> # TypeError: list indices must be integers or... >>> is_bipartite_dfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]}) True >>> is_bipartite_dfs({""a"": [1, 3], ""b"": [0, 2], ""c"": [1, 3], ""d"": [0, 2]}) True >>> is_bipartite_dfs({0: [""b"", ""d""], 1: [""a"", ""c""], 2: [""b"", ""d""], 3: [""a"", ""c""]}) True","defaultdict, depth_first_search, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\check_bipatrite.py","","is_bipartite_bfs","Check if a graph is bipartite using a breadth-first search (BFS).  Args:     `graph`: Adjacency list representing the graph.  Returns:     ``True`` if bipartite, ``False`` otherwise.  Check if the graph can be divided into two sets of vertices, such that no two vertices within the same set are connected by an edge.  Examples:  >>> is_bipartite_bfs({0: [1, 2], 1: [0, 3], 2: [0, 4]}) True >>> is_bipartite_bfs({0: [1, 2], 1: [0, 2], 2: [0, 1]}) False >>> is_bipartite_bfs({}) True >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}) True >>> is_bipartite_bfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]}) False >>> is_bipartite_bfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]}) True >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]}) False >>> is_bipartite_bfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]}) False  >>> # FIXME: This test should fails with KeyError: 4. >>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]}) False >>> is_bipartite_bfs({0: [-1, 3], 1: [0, -2]}) False >>> is_bipartite_bfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]}) True >>> is_bipartite_bfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}) True  >>> # FIXME: This test should fails with >>> # TypeError: list indices must be integers or... >>> is_bipartite_bfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]}) True >>> is_bipartite_bfs({""a"": [1, 3], ""b"": [0, 2], ""c"": [1, 3], ""d"": [0, 2]}) True >>> is_bipartite_bfs({0: [""b"", ""d""], 1: [""a"", ""c""], 2: [""b"", ""d""], 3: [""a"", ""c""]}) True","defaultdict, deque, queue.append, queue.popleft, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\check_bipatrite.py","","depth_first_search","Perform Depth-First Search (DFS) on the graph starting from a node.  Args:     node: The current node being visited.     color: The color assigned to the current node.  Returns:     True if the graph is bipartite starting from the current node,     False otherwise.","depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\check_cycle.py","","check_cycle","Returns True if graph is cyclic else False >>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}) False >>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]}) True","set, set, any, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\check_cycle.py","","depth_first_search","Recur for all neighbours. If any neighbour is visited and in rec_stk then graph is cyclic. >>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]} >>> vertex, visited, rec_stk = 0, set(), set() >>> depth_first_search(graph, vertex, visited, rec_stk) False","visited.add, rec_stk.add, rec_stk.remove, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\connected_components.py","","dfs","Use depth first search to find all vertices being in the same component as initial vertex >>> dfs(test_graph_1, 0, 5 * [False]) [0, 1, 3, 2] >>> dfs(test_graph_2, 0, 6 * [False]) [0, 1, 3, 2]","dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\connected_components.py","","connected_components","This function takes graph as a parameter and then returns the list of connected components >>> connected_components(test_graph_1) [[0, 1, 3, 2], [4, 5, 6]] >>> connected_components(test_graph_2) [[0, 1, 3, 2], [4], [5]]","len, range, dfs, components_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\deep_clone_graph.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\deep_clone_graph.py","","clone_graph","This function returns a clone of a connected undirected graph. >>> clone_graph(Node(1)) Node(value=1, neighbors=[]) >>> clone_graph(Node(1, [Node(2)])) Node(value=1, neighbors=[Node(value=2, neighbors=[])]) >>> clone_graph(None) is None True","originals_to_clones.items, stack.pop, Node, stack.extend, clone.neighbors.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\deep_clone_graph.py","","__post_init__",">>> Node(3).neighbors []",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\deep_clone_graph.py","","__hash__",">>> hash(Node(3)) != 0 True","id"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search.py","","depth_first_search","Depth First Search on Graph :param graph: directed graph in dictionary format :param start: starting vertex as a string :returns: the trace of the search >>> input_G = { ""A"": [""B"", ""C"", ""D""], ""B"": [""A"", ""D"", ""E""], ... ""C"": [""A"", ""F""], ""D"": [""B"", ""D""], ""E"": [""B"", ""F""], ... ""F"": [""C"", ""E"", ""G""], ""G"": [""F""] } >>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'}) >>> all(x in output_G for x in list(depth_first_search(input_G, ""A""))) True >>> all(x in output_G for x in list(depth_first_search(input_G, ""G""))) True","set, stack.pop, explored.add, reversed, stack.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search_2.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search_2.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search_2.py","","print_graph","Print the graph vertices.  Example: >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> g.print_graph() {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]} 0  ->  1 -> 2 1  ->  2 2  ->  0 -> 3 3  ->  3","print, print, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search_2.py","","add_edge","Add an edge between two vertices.  :param from_vertex: The source vertex. :param to_vertex: The destination vertex.  Example: >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.print_graph() {0: [1, 2]} 0  ->  1 -> 2",".append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search_2.py","","dfs","Perform depth-first search (DFS) traversal on the graph and print the visited vertices.  Example: >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> g.dfs() 0 1 2 3","range, len, len, self.dfs_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\depth_first_search_2.py","","dfs_recursive","Perform a recursive depth-first search (DFS) traversal on the graph.  :param start_vertex: The starting vertex for the traversal. :param visited: A list to track visited vertices.  Example: >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 3) >>> visited = [False] * len(g.vertex) >>> g.dfs_recursive(0, visited) 0 1 2 3","print, print, self.dfs_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra.py","","dijkstra","Return the cost of the shortest path between vertices start and end.  >>> dijkstra(G, ""E"", ""C"") 6 >>> dijkstra(G2, ""E"", ""F"") 3 >>> dijkstra(G3, ""E"", ""F"") 3","set, heapq.heappop, visited.add, heapq.heappush"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_2.py","","print_dist","","print, range, print, float, print, print, int"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_2.py","","min_dist","","float, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_2.py","","dijkstra","","range, print_dist, float, min_dist, range, range, range, float"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","PriorityQueue","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","__init__","Priority queue class constructor method.  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.cur_size 0 >>> priority_queue_test.array [] >>> priority_queue_test.pos {}",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","is_empty","Conditional boolean method to determine if the priority queue is empty or not.  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.is_empty() True >>> priority_queue_test.insert((2, 'A')) >>> priority_queue_test.is_empty() False",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","min_heapify","Sorts the queue array so that the minimum element is root.  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.cur_size = 3 >>> priority_queue_test.pos = {'A': 0, 'B': 1, 'C': 2}  >>> priority_queue_test.array = [(5, 'A'), (10, 'B'), (15, 'C')] >>> priority_queue_test.min_heapify(0) >>> priority_queue_test.array [(5, 'A'), (10, 'B'), (15, 'C')]  >>> priority_queue_test.array = [(10, 'A'), (5, 'B'), (15, 'C')] >>> priority_queue_test.min_heapify(0) >>> priority_queue_test.array [(5, 'B'), (10, 'A'), (15, 'C')]  >>> priority_queue_test.array = [(10, 'A'), (15, 'B'), (5, 'C')] >>> priority_queue_test.min_heapify(0) >>> priority_queue_test.array [(5, 'C'), (15, 'B'), (10, 'A')]  >>> priority_queue_test.array = [(10, 'A'), (5, 'B')] >>> priority_queue_test.cur_size = len(priority_queue_test.array) >>> priority_queue_test.pos = {'A': 0, 'B': 1} >>> priority_queue_test.min_heapify(0) >>> priority_queue_test.array [(5, 'B'), (10, 'A')]","self.left, self.right, self.swap, self.min_heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","insert","Inserts a node into the Priority Queue.  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.insert((10, 'A')) >>> priority_queue_test.array [(10, 'A')] >>> priority_queue_test.insert((15, 'B')) >>> priority_queue_test.array [(10, 'A'), (15, 'B')] >>> priority_queue_test.insert((5, 'C')) >>> priority_queue_test.array [(5, 'C'), (10, 'A'), (15, 'B')]","self.array.append, self.decrease_key"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","extract_min","Removes and returns the min element at top of priority queue.  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.array = [(10, 'A'), (15, 'B')] >>> priority_queue_test.cur_size = len(priority_queue_test.array) >>> priority_queue_test.pos = {'A': 0, 'B': 1} >>> priority_queue_test.insert((5, 'C')) >>> priority_queue_test.extract_min() 'C' >>> priority_queue_test.array[0] (10, 'A')","self.min_heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","left","Returns the index of left child  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.left(0) 1 >>> priority_queue_test.left(1) 3",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","right","Returns the index of right child  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.right(0) 2 >>> priority_queue_test.right(1) 4",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","par","Returns the index of parent  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.par(1) 0 >>> priority_queue_test.par(2) 1 >>> priority_queue_test.par(4) 2","math.floor"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","swap","Swaps array elements at indices i and j, update the pos{}  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.array = [(10, 'A'), (15, 'B')] >>> priority_queue_test.cur_size = len(priority_queue_test.array) >>> priority_queue_test.pos = {'A': 0, 'B': 1} >>> priority_queue_test.swap(0, 1) >>> priority_queue_test.array [(15, 'B'), (10, 'A')] >>> priority_queue_test.pos {'A': 1, 'B': 0}",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","decrease_key","Decrease the key value for a given tuple, assuming the new_d is at most old_d.  Examples: >>> priority_queue_test = PriorityQueue() >>> priority_queue_test.array = [(10, 'A'), (15, 'B')] >>> priority_queue_test.cur_size = len(priority_queue_test.array) >>> priority_queue_test.pos = {'A': 0, 'B': 1} >>> priority_queue_test.decrease_key((10, 'A'), 5) >>> priority_queue_test.array [(5, 'A'), (15, 'B')]","self.swap, self.par, self.par, self.par"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","__init__","Graph class constructor  Examples: >>> graph_test = Graph(1) >>> graph_test.num_nodes 1 >>> graph_test.dist [0] >>> graph_test.par [-1] >>> graph_test.adjList {}",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","add_edge","Add edge going from node u to v and v to u with weight w: u (w)-> v, v (w) -> u  Examples: >>> graph_test = Graph(1) >>> graph_test.add_edge(1, 2, 1) >>> graph_test.add_edge(2, 3, 2) >>> graph_test.adjList {1: [(2, 1)], 2: [(1, 1), (3, 2)], 3: [(2, 2)]}",".append, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","show_graph","Show the graph: u -> v(w)  Examples: >>> graph_test = Graph(1) >>> graph_test.add_edge(1, 2, 1) >>> graph_test.show_graph() 1 -> 2(1) 2 -> 1(1) >>> graph_test.add_edge(2, 3, 2) >>> graph_test.show_graph() 1 -> 2(1) 2 -> 1(1) -> 3(2) 3 -> 2(2)","print, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","dijkstra","Dijkstra algorithm  Examples: >>> graph_test = Graph(3) >>> graph_test.add_edge(0, 1, 2) >>> graph_test.add_edge(1, 2, 2) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 2 Node 2 has distance: 4 >>> graph_test.dist [0, 2, 4]  >>> graph_test = Graph(2) >>> graph_test.add_edge(0, 1, 2) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 2 >>> graph_test.dist [0, 2]  >>> graph_test = Graph(3) >>> graph_test.add_edge(0, 1, 2) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 2 Node 2 has distance: 0 >>> graph_test.dist [0, 2, 0]  >>> graph_test = Graph(3) >>> graph_test.add_edge(0, 1, 2) >>> graph_test.add_edge(1, 2, 2) >>> graph_test.add_edge(0, 2, 1) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 2 Node 2 has distance: 1 >>> graph_test.dist [0, 2, 1]  >>> graph_test = Graph(4) >>> graph_test.add_edge(0, 1, 4) >>> graph_test.add_edge(1, 2, 2) >>> graph_test.add_edge(2, 3, 1) >>> graph_test.add_edge(0, 2, 3) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 4 Node 2 has distance: 3 Node 3 has distance: 4 >>> graph_test.dist [0, 4, 3, 4]  >>> graph_test = Graph(4) >>> graph_test.add_edge(0, 1, 4) >>> graph_test.add_edge(1, 2, 2) >>> graph_test.add_edge(2, 3, 1) >>> graph_test.add_edge(0, 2, 7) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 4 Node 2 has distance: 6 Node 3 has distance: 7 >>> graph_test.dist [0, 4, 6, 7]","PriorityQueue, q.insert, self.show_distances, q.is_empty, q.extract_min, q.insert, q.decrease_key"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","show_distances","Show the distances from src to all other nodes in a graph  Examples: >>> graph_test = Graph(1) >>> graph_test.show_distances(0) Distance from node: 0 Node 0 has distance: 0","print, range, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_algorithm.py","","show_path","Shows the shortest path from src to dest. WARNING: Use it *after* calling dijkstra.  Examples: >>> graph_test = Graph(4) >>> graph_test.add_edge(0, 1, 1) >>> graph_test.add_edge(1, 2, 2) >>> graph_test.add_edge(2, 3, 3) >>> graph_test.dijkstra(0) Distance from node: 0 Node 0 has distance: 0 Node 1 has distance: 1 Node 2 has distance: 3 Node 3 has distance: 6 >>> graph_test.show_path(0, 3)  # doctest: +NORMALIZE_WHITESPACE ----Path to reach 3 from 0---- 0 -> 1 -> 2 -> 3 Total cost of path:  6","path.append, path.reverse, print, print, path.append, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_alternate.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_alternate.py","","__init__",">>> graph = Graph(2) >>> graph.vertices 2 >>> len(graph.graph) 2 >>> len(graph.graph[0]) 2","range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_alternate.py","","print_solution",">>> Graph(0).print_solution([])  # doctest: +NORMALIZE_WHITESPACE Vertex   Distance from Source","print, range, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_alternate.py","","minimum_distance","A utility function to find the vertex with minimum distance value, from the set of vertices not yet included in shortest path tree.  >>> Graph(3).minimum_distance([1, 2, 3], [False, False, True]) 0","range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_alternate.py","","dijkstra","Function that implements Dijkstra's single source shortest path algorithm for a graph represented using adjacency matrix representation.  >>> Graph(4).dijkstra(1)  # doctest: +NORMALIZE_WHITESPACE Vertex  Distance from Source 0                10000000 1                0 2                10000000 3                10000000","range, self.print_solution, self.minimum_distance, range, int"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dijkstra_binary_grid.py","","dijkstra","Implements Dijkstra's algorithm on a binary grid.  Args:     grid (np.ndarray): A 2D numpy array representing the grid.     1 represents a walkable node and 0 represents an obstacle.     source (Tuple[int, int]): A tuple representing the start node.     destination (Tuple[int, int]): A tuple representing the     destination node.     allow_diagonal (bool): A boolean determining whether     diagonal movements are allowed.  Returns:     Tuple[Union[float, int], List[Tuple[int, int]]]:     The shortest distance from the start node to the destination node     and the shortest path as a list of nodes.  >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), False) (4.0, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])  >>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), True) (2.0, [(0, 0), (1, 1), (2, 2)])  >>> dijkstra(np.array([[1, 1, 1], [0, 0, 1], [0, 1, 1]]), (0, 0), (2, 2), False) (4.0, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])","np.full, np.empty, set, heappop, visited.add, range, path.append, path.reverse, len, path.append, float, heappush"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dinic.py","Dinic","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dinic.py","","__init__","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dinic.py","","add_edge","",".append, .append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dinic.py","","depth_first_search","","range, len, self.depth_first_search, min"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\dinic.py","","max_flow","","range, self.depth_first_search, self.depth_first_search, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","DirectedGraph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","Graph","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","add_pair","","self.graph.get, self.graph.get, .count, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","all_nodes","","list"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","remove_pair","","self.graph.get, .remove"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","dfs","","stack.append, visited.append, next, iter, len, stack.pop, len, len, visited.count, visited.append, stack.append, visited.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","fill_graph_randomly","","range, range, floor, floor, floor, self.add_pair, random, random, random"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","bfs","","deque, d.append, visited.append, next, d.popleft, iter, len, visited.count, d.append, visited.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","in_degree","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","out_degree","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","topological_sort","","stack.append, visited.append, next, iter, len, sorted_nodes.append, len, stack.pop, len, visited.count, stack.append, visited.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","cycle_nodes","","next, stack.append, visited.append, set, iter, len, stack.pop, indirect_parents.append, len, list, len, visited.count, stack.append, visited.append, visited.count, indirect_parents.count, len, len, anticipating_nodes.add, anticipating_nodes.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","has_cycle","","next, stack.append, visited.append, set, iter, len, stack.pop, indirect_parents.append, len, len, visited.count, stack.append, visited.append, visited.count, indirect_parents.count, len, len, anticipating_nodes.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","dfs_time","","time, self.dfs, time"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","bfs_time","","time, self.bfs, time"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","add_pair","","self.graph.get, self.graph.get, .count, .append, .count, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","remove_pair","","self.graph.get, self.graph.get, .remove, .remove"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","dfs","","stack.append, visited.append, next, iter, len, stack.pop, len, len, visited.count, visited.append, stack.append, visited.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","fill_graph_randomly","","range, range, floor, floor, floor, self.add_pair, random, random, random"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","bfs","","deque, d.append, visited.append, next, d.popleft, iter, len, visited.count, d.append, visited.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","degree","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","cycle_nodes","","next, stack.append, visited.append, set, iter, len, stack.pop, indirect_parents.append, len, list, len, visited.count, stack.append, visited.append, visited.count, indirect_parents.count, len, len, anticipating_nodes.add, anticipating_nodes.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","has_cycle","","next, stack.append, visited.append, set, iter, len, stack.pop, indirect_parents.append, len, len, visited.count, stack.append, visited.append, visited.count, indirect_parents.count, len, len, anticipating_nodes.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","all_nodes","","list"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","dfs_time","","time, self.dfs, time"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\directed_and_undirected_weighted_graph.py","","bfs_time","","time, self.bfs, time"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","FlowNetwork","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","FlowNetworkAlgorithmExecutor","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","MaximumFlowAlgorithmExecutor","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","PushRelabelExecutor","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","__init__","","self._normalize_graph, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","_normalize_graph","","self.graph.insert, self.graph.append, len, len, len, len, sum, len, room.insert, len, room.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","find_maximum_flow","","self.maximum_flow_algorithm.execute, self.maximum_flow_algorithm.getMaximumFlow, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","set_maximum_flow_algorithm","","algorithm"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","execute","","self._algorithm"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","_algorithm","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","get_maximum_flow","","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","__init__","",".__init__, super, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","_algorithm","","enumerate, sum, len, self.process_vertex, range, vertices_list.insert, vertices_list.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","process_vertex","","range, self.relabel, self.push"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","push","","min"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\edmonds_karp_multiple_source_and_sink.py","","relabel","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\eulerian_path_and_circuit_for_undirected_graph.py","","dfs","","dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\eulerian_path_and_circuit_for_undirected_graph.py","","check_circuit_or_path","","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\eulerian_path_and_circuit_for_undirected_graph.py","","check_euler","","check_circuit_or_path, dfs, print, print, print, print, print, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\eulerian_path_and_circuit_for_undirected_graph.py","","main","","check_euler, check_euler, check_euler, check_euler, check_euler"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\even_tree.py","","dfs","DFS traversal","cuts.append, dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\even_tree.py","","even_tree","2 1 3 1 4 3 5 2 6 1 7 2 8 6 9 8 10 8 On removing edges (1,3) and (1,6), we can get the desired result 2.","dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\finding_bridges.py","","__get_demo_graph","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\finding_bridges.py","","compute_bridges","Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi >>> compute_bridges(__get_demo_graph(0)) [(3, 4), (2, 3), (2, 5)] >>> compute_bridges(__get_demo_graph(1)) [(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)] >>> compute_bridges(__get_demo_graph(2)) [(1, 6), (4, 6), (0, 4)] >>> compute_bridges(__get_demo_graph(3)) [] >>> compute_bridges({}) []","len, range, dfs, dfs, min, min, bridges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\finding_bridges.py","","dfs","","dfs, min, min, bridges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","get_distinct_edge","Return Distinct edges from edge array of multiple graphs >>> sorted(get_distinct_edge(edge_array)) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']","set, list, distinct_edge.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","get_bitcode","Return bitcode of distinct_edge","enumerate, .join, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","get_frequency_table","Returns Frequency Table","get_distinct_edge, get_bitcode, bit.count, sorted, frequency_table.items"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","get_nodes","Returns nodes format nodes={bitcode:edges that represent the bitcode} >>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'], ...            ['bd', 5, '11111'], ['bc', 5, '11111']]) {'11111': ['ab', 'ac', 'df', 'bd', 'bc']}","enumerate, .append, nodes.setdefault"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","get_cluster","Returns cluster format cluster:{WT(bitcode):nodes with same WT}","nodes.items, cluster.setdefault, key.count"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","get_support","Returns support >>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']}, ...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']}, ...              3: {'11001': ['ad'], '10101': ['dg']}, ...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'], ...                  '10001': ['ce']}, ...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}}) [100.0, 80.0, 60.0, 40.0, 20.0]","len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","print_all","","print, nodes.items, print, print, print, sorted, print, graph.items, print, print, cluster.items, print, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","create_edge","create edge between the nodes","max, cluster.keys, int, int, int, tuple, .append, tuple, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","construct_graph","","max, create_edge, cluster.keys, max, .append, max, cluster.keys"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","my_dfs","find different DFS walk from given node to Header node","paths.append, tuple, my_dfs, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","find_freq_subgraph_given_support","find edges of multiple frequent subgraphs","int, my_dfs, tuple, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","freq_subgraphs_edge_list","returns Edge list for frequent subgraphs","range, freq_sub_el.append, list, len, el.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\frequent_pattern_graph_miner.py","","preprocess","Preprocess the edge array >>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12', ...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3', ...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])","range, len, range, len, .split"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\gale_shapley_bigraph.py","","stable_matching","Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects prefer each other over their partner.  The function accepts the preferences of oegan donors and recipients (where both are assigned numbers from 0 to n-1) and returns a list where the index position corresponds to the donor and value at the index is the organ recipient.  To better understand the algorithm, see also: https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README). https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).  >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]] >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]] >>> stable_matching(donor_pref, recipient_pref) [1, 2, 3, 0]","len, list, len, len, range, unmatched_donors.remove, rec_preference.index, rec_preference.index, unmatched_donors.append, unmatched_donors.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graphs_floyd_warshall.py","","_print_dist","","print, range, range, print, float, print, print, int"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graphs_floyd_warshall.py","","floyd_warshall",":param graph: 2D array calculated from weight[edge[i, j]] :type graph: List[List[float]] :param v: number of vertices :type v: int :return: shortest distance between all vertex pairs distance[u][v] will contain the shortest distance from vertex u to v.  1. For all edges from v to n, distance[i][j] = weight(edge(i, j)). 3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +     distance[k][j]) for each possible pair i, j of vertices. 4. The above is repeated for each vertex k in the graph. 5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is     updated to the next vertex[i][k].","range, range, _print_dist, range, range, float, range, range, range, float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","GraphAdjacencyList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","TestGraphAdjacencyList","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__init__","Parameters:  - vertices: (list[T]) The list of vertex names the client wants to pass in. Default is empty. - edges: (list[list[T]]) The list of edges the client wants to pass in. Each edge is a 2-element list. Default is empty. - directed: (bool) Indicates if graph is directed or undirected. Default is True.","self.add_vertex, self.add_edge, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","add_vertex","Adds a vertex to the graph. If the given vertex already exists, a ValueError will be thrown.  >>> g = GraphAdjacencyList(vertices=[], edges=[], directed=False) >>> g.add_vertex(""A"") >>> g.adj_list {'A': []} >>> g.add_vertex(""A"") Traceback (most recent call last): ... ValueError: Incorrect input: A is already in the graph.","self.contains_vertex, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","add_edge","Creates an edge from source vertex to destination vertex. If any given vertex doesn't exist or the edge already exists, a ValueError will be thrown.","self.contains_edge, .append, ValueError, ValueError, .append, self.contains_vertex, self.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","remove_vertex","Removes the given vertex from the graph and deletes all incoming and outgoing edges from the given vertex as well. If the given vertex does not exist, a ValueError will be thrown.","self.adj_list.pop, self.contains_vertex, ValueError, self.adj_list.values, .remove, edge_list.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","remove_edge","Removes the edge between the two vertices. If any given vertex doesn't exist or the edge does not exist, a ValueError will be thrown.",".remove, ValueError, self.contains_edge, ValueError, .remove, self.contains_vertex, self.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","contains_vertex","Returns True if the graph contains the vertex, False otherwise.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","contains_edge","Returns True if the graph contains the edge from the source_vertex to the destination_vertex, False otherwise. If any given vertex doesn't exist, a ValueError will be thrown.","ValueError, self.contains_vertex, self.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","clear_graph","Clears all vertices and edges.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__repr__","","pformat"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__assert_graph_edge_exists_check","","undirected_graph.contains_edge, undirected_graph.contains_edge, directed_graph.contains_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__assert_graph_edge_does_not_exist_check","","undirected_graph.contains_edge, undirected_graph.contains_edge, directed_graph.contains_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__assert_graph_vertex_exists_check","","undirected_graph.contains_vertex, directed_graph.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__assert_graph_vertex_does_not_exist_check","","undirected_graph.contains_vertex, directed_graph.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__generate_random_edges","","random.sample, random.sample, len, random_edges.append, int, int, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","__generate_graphs","","random.sample, self.__generate_random_edges, GraphAdjacencyList, GraphAdjacencyList, ValueError, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_init_check","","self.__generate_graphs, self.__assert_graph_vertex_exists_check, self.__assert_graph_edge_exists_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_contains_vertex","","random.sample, GraphAdjacencyList, GraphAdjacencyList, range, range, undirected_graph.contains_vertex, directed_graph.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_add_vertices","","random.sample, GraphAdjacencyList, GraphAdjacencyList, range, undirected_graph.add_vertex, directed_graph.add_vertex, self.__assert_graph_vertex_exists_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_remove_vertices","","random.sample, GraphAdjacencyList, GraphAdjacencyList, range, self.__assert_graph_vertex_exists_check, undirected_graph.remove_vertex, directed_graph.remove_vertex, self.__assert_graph_vertex_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_add_and_remove_vertices_repeatedly","","random.sample, random.sample, GraphAdjacencyList, GraphAdjacencyList, enumerate, enumerate, range, range, undirected_graph.add_vertex, directed_graph.add_vertex, self.__assert_graph_vertex_exists_check, undirected_graph.remove_vertex, directed_graph.remove_vertex, self.__assert_graph_vertex_does_not_exist_check, undirected_graph.remove_vertex, directed_graph.remove_vertex, self.__assert_graph_vertex_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_contains_edge","","self.__generate_graphs, range, range, all_possible_edges.append, all_possible_edges.append, self.__assert_graph_edge_exists_check, self.__assert_graph_edge_exists_check, self.__assert_graph_edge_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_add_edge","","random.sample, self.__generate_random_edges, GraphAdjacencyList, GraphAdjacencyList, range, undirected_graph.add_edge, directed_graph.add_edge, self.__assert_graph_edge_exists_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_remove_edge","","self.__generate_graphs, self.__assert_graph_edge_exists_check, undirected_graph.remove_edge, directed_graph.remove_edge, self.__assert_graph_edge_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_add_and_remove_edges_repeatedly","","self.__generate_graphs, enumerate, len, len, self.__generate_random_edges, undirected_graph.add_edge, directed_graph.add_edge, self.__assert_graph_edge_exists_check, undirected_graph.remove_edge, directed_graph.remove_edge, self.__assert_graph_edge_does_not_exist_check, len, len, more_random_edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_add_vertex_exception_check","","self.__generate_graphs, pytest.raises, undirected_graph.add_vertex, pytest.raises, directed_graph.add_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_remove_vertex_exception_check","","self.__generate_graphs, range, pytest.raises, undirected_graph.remove_vertex, pytest.raises, directed_graph.remove_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_add_edge_exception_check","","self.__generate_graphs, pytest.raises, undirected_graph.add_edge, pytest.raises, directed_graph.add_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_remove_edge_exception_check","","self.__generate_graphs, len, len, self.__generate_random_edges, pytest.raises, undirected_graph.remove_edge, pytest.raises, directed_graph.remove_edge, len, len, more_random_edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_list.py","","test_contains_edge_exception_check","","self.__generate_graphs, pytest.raises, undirected_graph.contains_edge, pytest.raises, directed_graph.contains_edge, pytest.raises, undirected_graph.contains_edge, pytest.raises, directed_graph.contains_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","GraphAdjacencyMatrix","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","TestGraphMatrix","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__init__","Parameters: - vertices: (list[T]) The list of vertex names the client wants to pass in. Default is empty. - edges: (list[list[T]]) The list of edges the client wants to pass in. Each edge is a 2-element list. Default is empty. - directed: (bool) Indicates if graph is directed or undirected. Default is True.","self.add_vertex, self.add_edge, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","add_edge","Creates an edge from source vertex to destination vertex. If any given vertex doesn't exist or the edge already exists, a ValueError will be thrown.","self.contains_edge, ValueError, ValueError, self.contains_vertex, self.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","remove_edge","Removes the edge between the two vertices. If any given vertex doesn't exist or the edge does not exist, a ValueError will be thrown.","ValueError, self.contains_edge, ValueError, self.contains_vertex, self.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","add_vertex","Adds a vertex to the graph. If the given vertex already exists, a ValueError will be thrown.","self.contains_vertex, self.adj_matrix.append, ValueError, row.append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","remove_vertex","Removes the given vertex from the graph and deletes all incoming and outgoing edges from the given vertex as well. If the given vertex does not exist, a ValueError will be thrown.","self.adj_matrix.pop, self.vertex_to_index.pop, self.contains_vertex, ValueError, lst.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","contains_vertex","Returns True if the graph contains the vertex, False otherwise.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","contains_edge","Returns True if the graph contains the edge from the source_vertex to the destination_vertex, False otherwise. If any given vertex doesn't exist, a ValueError will be thrown.","ValueError, self.contains_vertex, self.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","clear_graph","Clears all vertices and edges.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__repr__","","pformat, pformat"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__assert_graph_edge_exists_check","","undirected_graph.contains_edge, undirected_graph.contains_edge, directed_graph.contains_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__assert_graph_edge_does_not_exist_check","","undirected_graph.contains_edge, undirected_graph.contains_edge, directed_graph.contains_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__assert_graph_vertex_exists_check","","undirected_graph.contains_vertex, directed_graph.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__assert_graph_vertex_does_not_exist_check","","undirected_graph.contains_vertex, directed_graph.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__generate_random_edges","","random.sample, random.sample, len, random_edges.append, int, int, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","__generate_graphs","","random.sample, self.__generate_random_edges, GraphAdjacencyMatrix, GraphAdjacencyMatrix, ValueError, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_init_check","","self.__generate_graphs, self.__assert_graph_vertex_exists_check, self.__assert_graph_edge_exists_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_contains_vertex","","random.sample, GraphAdjacencyMatrix, GraphAdjacencyMatrix, range, range, undirected_graph.contains_vertex, directed_graph.contains_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_add_vertices","","random.sample, GraphAdjacencyMatrix, GraphAdjacencyMatrix, range, undirected_graph.add_vertex, directed_graph.add_vertex, self.__assert_graph_vertex_exists_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_remove_vertices","","random.sample, GraphAdjacencyMatrix, GraphAdjacencyMatrix, range, self.__assert_graph_vertex_exists_check, undirected_graph.remove_vertex, directed_graph.remove_vertex, self.__assert_graph_vertex_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_add_and_remove_vertices_repeatedly","","random.sample, random.sample, GraphAdjacencyMatrix, GraphAdjacencyMatrix, enumerate, enumerate, range, range, undirected_graph.add_vertex, directed_graph.add_vertex, self.__assert_graph_vertex_exists_check, undirected_graph.remove_vertex, directed_graph.remove_vertex, self.__assert_graph_vertex_does_not_exist_check, undirected_graph.remove_vertex, directed_graph.remove_vertex, self.__assert_graph_vertex_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_contains_edge","","self.__generate_graphs, range, range, all_possible_edges.append, all_possible_edges.append, self.__assert_graph_edge_exists_check, self.__assert_graph_edge_exists_check, self.__assert_graph_edge_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_add_edge","","random.sample, self.__generate_random_edges, GraphAdjacencyMatrix, GraphAdjacencyMatrix, range, undirected_graph.add_edge, directed_graph.add_edge, self.__assert_graph_edge_exists_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_remove_edge","","self.__generate_graphs, self.__assert_graph_edge_exists_check, undirected_graph.remove_edge, directed_graph.remove_edge, self.__assert_graph_edge_does_not_exist_check"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_add_and_remove_edges_repeatedly","","self.__generate_graphs, enumerate, len, len, self.__generate_random_edges, undirected_graph.add_edge, directed_graph.add_edge, self.__assert_graph_edge_exists_check, undirected_graph.remove_edge, directed_graph.remove_edge, self.__assert_graph_edge_does_not_exist_check, len, len, more_random_edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_add_vertex_exception_check","","self.__generate_graphs, pytest.raises, undirected_graph.add_vertex, pytest.raises, directed_graph.add_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_remove_vertex_exception_check","","self.__generate_graphs, range, pytest.raises, undirected_graph.remove_vertex, pytest.raises, directed_graph.remove_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_add_edge_exception_check","","self.__generate_graphs, pytest.raises, undirected_graph.add_edge, pytest.raises, directed_graph.add_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_remove_edge_exception_check","","self.__generate_graphs, len, len, self.__generate_random_edges, pytest.raises, undirected_graph.remove_edge, pytest.raises, directed_graph.remove_edge, len, len, more_random_edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_adjacency_matrix.py","","test_contains_edge_exception_check","","self.__generate_graphs, pytest.raises, undirected_graph.contains_edge, pytest.raises, directed_graph.contains_edge, pytest.raises, undirected_graph.contains_edge, pytest.raises, directed_graph.contains_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_list.py","GraphAdjacencyList","","Adjacency List type Graph Data Structure that accounts for directed and undirected Graphs.  Initialize graph object indicating whether it's directed or undirected.  Directed graph example: >>> d_graph = GraphAdjacencyList() >>> print(d_graph) {} >>> d_graph.add_edge(0, 1) {0: [1], 1: []} >>> d_graph.add_edge(1, 2).add_edge(1, 4).add_edge(1, 5) {0: [1], 1: [2, 4, 5], 2: [], 4: [], 5: []} >>> d_graph.add_edge(2, 0).add_edge(2, 6).add_edge(2, 7) {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []} >>> d_graph {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []} >>> print(repr(d_graph)) {0: [1], 1: [2, 4, 5], 2: [0, 6, 7], 4: [], 5: [], 6: [], 7: []}  Undirected graph example: >>> u_graph = GraphAdjacencyList(directed=False) >>> u_graph.add_edge(0, 1) {0: [1], 1: [0]} >>> u_graph.add_edge(1, 2).add_edge(1, 4).add_edge(1, 5) {0: [1], 1: [0, 2, 4, 5], 2: [1], 4: [1], 5: [1]} >>> u_graph.add_edge(2, 0).add_edge(2, 6).add_edge(2, 7) {0: [1, 2], 1: [0, 2, 4, 5], 2: [1, 0, 6, 7], 4: [1], 5: [1], 6: [2], 7: [2]} >>> u_graph.add_edge(4, 5) {0: [1, 2],  1: [0, 2, 4, 5],  2: [1, 0, 6, 7],  4: [1, 5],  5: [1, 4],  6: [2],  7: [2]} >>> print(u_graph) {0: [1, 2],  1: [0, 2, 4, 5],  2: [1, 0, 6, 7],  4: [1, 5],  5: [1, 4],  6: [2],  7: [2]} >>> print(repr(u_graph)) {0: [1, 2],  1: [0, 2, 4, 5],  2: [1, 0, 6, 7],  4: [1, 5],  5: [1, 4],  6: [2],  7: [2]}  >>> char_graph = GraphAdjacencyList(directed=False)  >>> char_graph.add_edge('a', 'b')  {'a': ['b'], 'b': ['a']}  >>> char_graph.add_edge('b', 'c').add_edge('b', 'e').add_edge('b', 'f')  {'a': ['b'], 'b': ['a', 'c', 'e', 'f'], 'c': ['b'], 'e': ['b'], 'f': ['b']}  >>> char_graph  {'a': ['b'], 'b': ['a', 'c', 'e', 'f'], 'c': ['b'], 'e': ['b'], 'f': ['b']}",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_list.py","","__init__","Parameters: directed: (bool) Indicates if graph is directed or undirected. Default is True.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_list.py","","add_edge","Connects vertices together. Creates and Edge from source vertex to destination vertex. Vertices will be created if not found in graph",".append, .append, .append, .append, .append, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\graph_list.py","","__repr__","","pformat"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","Node","",">>> k = Node(0, 0, 4, 5, 0, None) >>> k.calculate_heuristic() 9 >>> n = Node(1, 4, 3, 4, 2, None) >>> n.calculate_heuristic() 2 >>> l = [k, n] >>> n == l[0] False >>> l.sort() >>> n == l[0] True",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","GreedyBestFirst","",">>> grid = TEST_GRIDS[2] >>> gbf = GreedyBestFirst(grid, (0, 0), (len(grid) - 1, len(grid[0]) - 1)) >>> [x.pos for x in gbf.get_successors(gbf.start)] [(1, 0), (0, 1)] >>> (gbf.start.pos_y + delta[3][0], gbf.start.pos_x + delta[3][1]) (0, 1) >>> (gbf.start.pos_y + delta[2][0], gbf.start.pos_x + delta[2][1]) (1, 0) >>> gbf.retrace_path(gbf.start) [(0, 0)] >>> gbf.search()  # doctest: +NORMALIZE_WHITESPACE [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3),  (4, 4)]",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","__init__","","self.calculate_heuristic"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","calculate_heuristic","The heuristic here is the Manhattan Distance Could elaborate to offer more than one choice","abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","__eq__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","__init__","","Node, Node"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","search","Search for the path, if a path is not found, only the starting position is returned","self.open_nodes.sort, self.open_nodes.pop, self.closed_nodes.append, self.get_successors, self.retrace_path, self.open_nodes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","get_successors","Returns a list of successors (both in the grid and free spaces)","Node, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_best_first.py","","retrace_path","Retrace the path from parents to parents until start node","path.reverse, path.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\greedy_min_vertex_cover.py","","greedy_min_vertex_cover","Greedy APX Algorithm for min Vertex Cover @input: graph (graph stored in an adjacency list where each vertex         is represented with an integer) @example: >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]} >>> greedy_min_vertex_cover(graph) {0, 1, 2, 4}","graph.items, set, heapq.heappush, chosen_vertices.add, heapq.heapify, heapq.heappop, .index, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\g_topological_sort.py","","print_stack","","stack.pop, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\g_topological_sort.py","","depth_first_search","","stack.append, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\g_topological_sort.py","","topological_sort","","range, len, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\kahns_algorithm_long.py","","longest_distance","","graph.values, range, print, len, len, len, queue.pop, max, queue.append, max, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\kahns_algorithm_topo.py","","topological_sort","Perform topological sorting of a Directed Acyclic Graph (DAG) using Kahn's Algorithm via Breadth-First Search (BFS).  Topological sorting is a linear ordering of vertices in a graph such that for every directed edge u  v, vertex u comes before vertex v in the ordering.  Parameters: graph: Adjacency list representing the directed graph where keys are        vertices, and values are lists of adjacent vertices.  Returns: The topologically sorted order of vertices if the graph is a DAG. Returns None if the graph contains a cycle.  Example: >>> graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []} >>> topological_sort(graph) [0, 1, 2, 3, 4, 5]  >>> graph_with_cycle = {0: [1], 1: [2], 2: [0]} >>> topological_sort(graph_with_cycle)","graph.values, range, len, len, queue.pop, topo_order.append, len, queue.append, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\karger.py","","partition_graph","Partitions a graph using Karger's Algorithm. Implemented from pseudocode found here: https://en.wikipedia.org/wiki/Karger%27s_algorithm. This function involves random choices, meaning it will not give consistent outputs.  Args:     graph: A dictionary containing adacency lists for the graph.         Nodes must be strings.  Returns:     The cutset of the cut found by Karger's Algorithm.  >>> graph = {'0':['1'], '1':['0']} >>> partition_graph(graph) {('0', '1')}","len, random.choice, random.choice, list, uv_neighbors.remove, uv_neighbors.remove, set, list, set, .append, .union, graph_copy.keys, .remove, .remove"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\lanczos_eigenvectors.py","","validate_adjacency_list","Validates the adjacency list format for the graph.  Args:     graph: A list of lists where each sublist contains the neighbors of a node.  Raises:     ValueError: If the graph is not a list of lists, or if any node has                 invalid neighbors (e.g., out-of-range or non-integer values).  >>> validate_adjacency_list([[1, 2], [0], [0, 1]]) >>> validate_adjacency_list([[]])  # No neighbors, valid case >>> validate_adjacency_list([[1], [2], [-1]])  # Invalid neighbor Traceback (most recent call last):     ... ValueError: Invalid neighbor -1 in node 2 adjacency list.","enumerate, isinstance, ValueError, isinstance, ValueError, ValueError, isinstance, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\lanczos_eigenvectors.py","","lanczos_iteration","Constructs the tridiagonal matrix and orthonormal basis vectors using the Lanczos method.  Args:     graph: The graph represented as a list of adjacency lists.     num_eigenvectors: The number of largest eigenvalues and eigenvectors                       to approximate.  Returns:     A tuple containing:         - tridiagonal_matrix: A (num_eigenvectors x num_eigenvectors) symmetric                               matrix.         - orthonormal_basis: A (num_nodes x num_eigenvectors) matrix of orthonormal                              basis vectors.  Raises:     ValueError: If num_eigenvectors is less than 1 or greater than the number of                 nodes.  >>> graph = [[1, 2], [0, 2], [0, 1]] >>> T, Q = lanczos_iteration(graph, 2) >>> T.shape == (2, 2) and Q.shape == (3, 2) True","len, np.zeros, np.zeros, np.random.default_rng, rng.random, np.sqrt, range, ValueError, np.dot, multiply_matrix_vector, np.dot, np.sqrt, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\lanczos_eigenvectors.py","","multiply_matrix_vector","Performs multiplication of a graph's adjacency list representation with a vector.  Args:     graph: The adjacency list of the graph.     vector: A 1D numpy array representing the vector to multiply.  Returns:     A numpy array representing the product of the adjacency list and the vector.  Raises:     ValueError: If the vector's length does not match the number of nodes in the                 graph.  >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([1, 1, 1])) array([2., 2., 2.]) >>> multiply_matrix_vector([[1, 2], [0, 2], [0, 1]], np.array([0, 1, 0])) array([1., 0., 1.])","len, np.zeros, enumerate, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\lanczos_eigenvectors.py","","find_lanczos_eigenvectors","Computes the largest eigenvalues and their corresponding eigenvectors using the Lanczos method.  Args:     graph: The graph as a list of adjacency lists.     num_eigenvectors: Number of largest eigenvalues and eigenvectors to compute.  Returns:     A tuple containing:         - eigenvalues: 1D array of the largest eigenvalues in descending order.         - eigenvectors: 2D array where each column is an eigenvector corresponding                         to an eigenvalue.  Raises:     ValueError: If the graph format is invalid or num_eigenvectors is out of bounds.  >>> eigenvalues, eigenvectors = find_lanczos_eigenvectors( ...     [[1, 2], [0, 2], [0, 1]], 2 ... ) >>> len(eigenvalues) == 2 and eigenvectors.shape[1] == 2 True","validate_adjacency_list, lanczos_iteration, np.linalg.eigh, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\lanczos_eigenvectors.py","","main","Main driver function for testing the implementation with doctests.","doctest.testmod"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","MarkovChainGraphUndirectedUnweighted","","Undirected Unweighted Graph for running Markov Chain Algorithm",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","","get_transitions","Running Markov Chain algorithm and calculating the number of times each node is visited  >>> transitions = [ ... ('a', 'a', 0.9), ... ('a', 'b', 0.075), ... ('a', 'c', 0.025), ... ('b', 'a', 0.15), ... ('b', 'b', 0.8), ... ('b', 'c', 0.05), ... ('c', 'a', 0.25), ... ('c', 'b', 0.25), ... ('c', 'c', 0.5) ... ]  >>> result = get_transitions('a', transitions, 5000)  >>> result['a'] > result['b'] > result['c'] True","MarkovChainGraphUndirectedUnweighted, Counter, range, graph.add_transition_probability, graph.get_nodes, graph.transition"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","","add_node","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","","add_transition_probability","","self.add_node, self.add_node"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","","get_nodes","","list"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\markov_chain.py","","transition","","random"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\matching_min_vertex_cover.py","","matching_min_vertex_cover","APX Algorithm for min Vertex Cover using Matching Approach @input: graph (graph stored in an adjacency list where each vertex         is represented as an integer) @example: >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]} >>> matching_min_vertex_cover(graph) {0, 1, 2, 4}","set, get_edges, edges.pop, chosen_vertices.add, chosen_vertices.add, edges.copy, edges.discard"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\matching_min_vertex_cover.py","","get_edges","Return a set of couples that represents all of the edges. @input: graph (graph stored in an adjacency list where each vertex is         represented as an integer) @example: >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]} >>> get_edges(graph) {(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}","set, graph.items, edges.add"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_path_sum.py","","min_path_sum","Find the path from top left to bottom right of array of numbers with the lowest possible sum and return the sum along this path. >>> min_path_sum([ ...     [1, 3, 1], ...     [1, 5, 1], ...     [4, 2, 1], ... ]) 7  >>> min_path_sum([ ...     [1, 0, 5, 6, 7], ...     [8, 9, 0, 4, 2], ...     [4, 4, 4, 5, 1], ...     [9, 6, 3, 1, 0], ...     [8, 4, 3, 2, 7], ... ]) 20  >>> min_path_sum(None) Traceback (most recent call last):     ... TypeError: The grid does not contain the appropriate information  >>> min_path_sum([[]]) Traceback (most recent call last):     ... TypeError: The grid does not contain the appropriate information","range, range, TypeError, len, len, fill_row"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_path_sum.py","","fill_row",">>> fill_row([2, 2, 2], [1, 2, 3]) [3, 4, 5]","range, len, min"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","Graph","","Data structure to store graphs (based on adjacency lists)",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","add_vertex","Adds a vertex to the graph",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","add_edge","Adds an edge to the graph","self.add_vertex, self.add_vertex"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","distinct_weight","For Boruvks's algorithm the weights should be distinct Converts the weights to be distinct","self.get_edges, range, edges.sort, range, edges.remove, len, list, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","__str__","Returns string representation of the graph","string.rstrip"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","get_edges","Returna all edges in the graph","output.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","get_vertices","Returns all vertices in the graph","self.adjacency.keys"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","build","Builds a graph from the given set of vertices and edges","Graph, g.add_vertex, g.add_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","UnionFind","","Disjoint set Union and Find for Boruvka's algorithm",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","boruvka_mst","Implementation of Boruvka's algorithm >>> g = Graph() >>> g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1],[2, 3, 1]]) >>> g.distinct_weight() >>> bg = Graph.boruvka_mst(g) >>> print(bg) 1 -> 0 == 1 2 -> 0 == 2 0 -> 1 == 1 0 -> 2 == 2 3 -> 2 == 3 2 -> 3 == 3","Graph.UnionFind, Graph.build, graph.get_vertices, graph.get_edges, cheap_edge.values, edges.remove, union_find.find, union_find.find, union_find.find, union_find.find, union_find.union, mst_edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","__len__","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","make_set","","self.find"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","find","","self.make_set, self.find"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_boruvka.py","","union","","self.find, self.find"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal.py","","kruskal",">>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)]) [(2, 3, 1), (0, 1, 3), (1, 2, 5)]  >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)]) [(2, 3, 1), (0, 2, 1), (0, 1, 3)]  >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2), ... (2, 1, 1)]) [(2, 3, 1), (0, 2, 1), (2, 1, 1)]","sorted, list, range, find_parent, find_parent, find_parent, minimum_spanning_tree.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal.py","","find_parent","","find_parent"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","DisjointSetTreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","DisjointSetTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","GraphUndirectedWeighted","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","make_set","","DisjointSetTreeNode"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","find_set","","self.find_set"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","link","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","union","","self.link, self.find_set, self.find_set"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","add_node","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","add_edge","","self.add_node, self.add_node"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_kruskal2.py","","kruskal","Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm  Example: >>> g1 = GraphUndirectedWeighted[int]() >>> g1.add_edge(1, 2, 1) >>> g1.add_edge(2, 3, 2) >>> g1.add_edge(3, 4, 1) >>> g1.add_edge(3, 5, 100) # Removed in MST >>> g1.add_edge(4, 5, 5) >>> assert 5 in g1.connections[3] >>> mst = g1.kruskal() >>> assert 5 not in mst.connections[3]  >>> g2 = GraphUndirectedWeighted[str]() >>> g2.add_edge('A', 'B', 1) >>> g2.add_edge('B', 'C', 2) >>> g2.add_edge('C', 'D', 1) >>> g2.add_edge('C', 'E', 100) # Removed in MST >>> g2.add_edge('D', 'E', 5) >>> assert 'E' in g2.connections[""C""] >>> mst = g2.kruskal() >>> assert 'E' not in mst.connections['C']","set, edges.sort, , , disjoint_set.make_set, disjoint_set.find_set, disjoint_set.find_set, len, graph.add_edge, disjoint_set.union, seen.add, edges.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","Heap","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","prisms_algorithm",">>> adjacency_list = {0: [[1, 1], [3, 3]], ...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]], ...                   2: [[1, 6], [4, 5], [5, 2]], ...                   3: [[0, 3], [1, 5], [4, 1]], ...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]], ...                   5: [[2, 2], [4, 4]]} >>> prisms_algorithm(adjacency_list) [(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]","Heap, range, heap.heapify, range, len, len, len, distance_tv.append, positions.append, heap.node_position.append, len, heap.delete_minimum, tree_edges.append, heap.bottom_to_top, heap.get_position, heap.get_position, heap.get_position"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","get_position","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","set_position","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","top_to_bottom","","self.get_position, self.set_position, self.set_position, self.top_to_bottom, self.get_position"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","bottom_to_top","","self.set_position, int, int, self.set_position, self.set_position"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","heapify","","range, self.top_to_bottom, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims.py","","delete_minimum","","self.top_to_bottom, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","get_parent_position","heap helper function get the position of the parent of the current node  >>> get_parent_position(1) 0 >>> get_parent_position(2) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","get_child_left_position","heap helper function get the position of the left child of the current node  >>> get_child_left_position(0) 1",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","get_child_right_position","heap helper function get the position of the right child of the current node  >>> get_child_right_position(0) 2",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","MinPriorityQueue","","Minimum Priority Queue Class  Functions: is_empty: function to check if the priority queue is empty push: function to add an element with given priority to the queue extract_min: function to remove and return the element with lowest weight (highest              priority) update_key: function to update the weight of the given key _bubble_up: helper function to place a node at the proper position (upward             movement) _bubble_down: helper function to place a node at the proper position (downward             movement) _swap_nodes: helper function to swap the nodes at the given positions  >>> queue = MinPriorityQueue()  >>> queue.push(1, 1000) >>> queue.push(2, 100) >>> queue.push(3, 4000) >>> queue.push(4, 3000)  >>> queue.extract_min() 2  >>> queue.update_key(4, 50)  >>> queue.extract_min() 4 >>> queue.extract_min() 1 >>> queue.extract_min() 3",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","GraphUndirectedWeighted","","Graph Undirected Weighted Class  Functions: add_node: function to add a node in the graph add_edge: function to add an edge between 2 nodes in the graph",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","prims_algo",">>> graph = GraphUndirectedWeighted()  >>> graph.add_edge(""a"", ""b"", 3) >>> graph.add_edge(""b"", ""c"", 10) >>> graph.add_edge(""c"", ""d"", 5) >>> graph.add_edge(""a"", ""c"", 15) >>> graph.add_edge(""b"", ""d"", 100)  >>> dist, parent = prims_algo(graph)  >>> abs(dist[""a""] - dist[""b""]) 3 >>> abs(dist[""d""] - dist[""b""]) 15 >>> abs(dist[""a""] - dist[""c""]) 13","dict.fromkeys, dict.fromkeys, MinPriorityQueue, dist.items, priority_queue.is_empty, priority_queue.extract_min, priority_queue.push, priority_queue.is_empty, priority_queue.extract_min, priority_queue.update_key, priority_queue.update_key"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","__len__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","__repr__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","is_empty","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","push","","self.heap.append, self._bubble_up"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","extract_min","","self.heap.pop, self._swap_nodes, self._bubble_down"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","update_key","","get_parent_position, self._bubble_down, self._bubble_up, self._bubble_down"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","_bubble_up","","get_parent_position, self._swap_nodes, self._bubble_up"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","_bubble_down","","get_child_left_position, get_child_right_position, self._swap_nodes, self._bubble_down, self._swap_nodes, self._bubble_down, self._swap_nodes, self._bubble_down"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","_swap_nodes","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","__repr__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","__len__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","add_node","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\minimum_spanning_tree_prims2.py","","add_edge","","self.add_node, self.add_node"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","PriorityQueue","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","consistent_heuristic","","np.array, np.array, np.linalg.norm"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","heuristic_2","","consistent_heuristic"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","heuristic_1","","abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","key","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","do_something","","np.char.chararray, range, range, range, print, print, print, print, print, print, print, sys.exit, range, range, range, print, print, print, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","valid","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","expand_state","","range, .remove_element, valid, visited.add, float, valid, .put, key, range, key, .put, key, key"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","make_common_ground","","range, range, range, range, range, range, some_list.append, range, range, range, some_list.append, some_list.append, some_list.append, some_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","multi_a_star","","set, range, print, print, range, print, print, print, print, print, float, open_list.append, .put, .minkey, float, range, range, print, PriorityQueue, key, .minkey, print, print, .minkey, .minkey, .top_show, visited.add, expand_state, close_list_inad.append, .minkey, .top_show, visited.add, expand_state, close_list_anchor.append, print, float, do_something, float, do_something, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","__init__","","set"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","minkey","","self.empty, float"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","empty","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","put","","heapq.heappush, self.set.add, heapq.heappop, temp.append, temp.append, heapq.heappop, heapq.heappush"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","remove_element","","self.set.remove, heapq.heappop, temp.append, heapq.heappop, heapq.heappush"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","top_show","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\multi_heuristic_astar.py","","get","","heapq.heappop, self.set.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","","page_rank","","range, len, print, enumerate, print, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","","main","","list, enumerate, print, page_rank, .split, Node, enumerate, print, input, .add_inbound, .add_outbound"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","","add_inbound","","self.inbound.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","","add_outbound","","self.outbound.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\page_rank.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","Vertex","","Class Vertex.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","connect","",".add_neighbor, .add_neighbor, .add_edge, .add_edge"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","prim","Prim's Algorithm.  Runtime:     O(mn) with `m` edges and `n` vertices  Return:     List with the edges of a Minimum Spanning Tree  Usage:     prim(graph, graph[0])","range, min, q.remove, len, a.append, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","prim_heap","Prim's Algorithm with min heap.  Runtime:     O((m + n)log n) with `m` edges and `n` vertices  Yield:     Edges of a Minimum Spanning Tree  Usage:     prim(graph, graph[0])","list, hq.heapify, range, hq.heappop, len, hq.heapify, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","test_vector","# Creates a list to store x vertices. >>> x = 5 >>> G = [Vertex(n) for n in range(x)]  >>> connect(G, 1, 2, 15) >>> connect(G, 1, 3, 12) >>> connect(G, 2, 4, 13) >>> connect(G, 2, 5, 5) >>> connect(G, 3, 2, 6) >>> connect(G, 3, 4, 6) >>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree: >>> G_heap = G[:] >>> MST = prim(G, G[0]) >>> MST_heap = prim_heap(G, G[0]) >>> for i in MST: ...     print(i) (2, 3) (3, 1) (4, 3) (5, 2) >>> for i in MST_heap: ...     print(i) (2, 3) (3, 1) (4, 3) (5, 2)",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","__init__","Arguments:     id - input an id to identify the vertex Attributes:     neighbors - a list of the vertices it is linked to     edges     - a dict to store the edges's weight","str"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","__lt__","Comparison rule to < operator.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","__repr__","Return the vertex id.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","add_neighbor","Add a pointer to a vertex at neighbor's list.","self.neighbors.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\prim.py","","add_edge","Destination vertex and weight.",""
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\random_graph_generator.py","","random_graph","Generate a random graph @input: vertices_number (number of vertices),         probability (probability that a generic edge (u,v) exists),         directed (if True: graph will be a directed graph,                   otherwise it will be an undirected graph) @examples: >>> random.seed(1) >>> random_graph(4, 0.5) {0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]} >>> random.seed(1) >>> random_graph(4, 0.5, True) {0: [1], 1: [2, 3], 2: [3], 3: []}","range, complete_graph, range, range, random.random, .append, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\random_graph_generator.py","","complete_graph","Generate a complete graph with vertices_number vertices. @input: vertices_number (number of vertices),         directed (False if the graph is undirected, True otherwise) @example: >>> complete_graph(3) {0: [1, 2], 1: [0, 2], 2: [0, 1]}","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\scc_kosaraju.py","","dfs","","stack.append, dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\scc_kosaraju.py","","dfs2","","component.append, dfs2"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\scc_kosaraju.py","","kosaraju","","range, dfs, dfs2, scc.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\strongly_connected_components.py","","topology_sort","Use depth first search to sort graph At this time graph is the same as input >>> topology_sort(test_graph_1, 0, 5 * [False]) [1, 2, 4, 3, 0] >>> topology_sort(test_graph_2, 0, 6 * [False]) [2, 1, 5, 4, 3, 0]","order.append, topology_sort"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\strongly_connected_components.py","","find_components","Use depth first search to find strongly connected vertices. Now graph is reversed >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False]) [0, 1, 2] >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False]) [0, 2, 1]","find_components"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\strongly_connected_components.py","","strongly_connected_components","This function takes graph as a parameter and then returns the list of strongly connected components >>> strongly_connected_components(test_graph_1) [[0, 1, 2], [3], [4]] >>> strongly_connected_components(test_graph_2) [[0, 2, 1], [3, 5, 4]]","graph.items, enumerate, range, len, len, len, range, .append, topology_sort, find_components, components_list.append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\tarjans_scc.py","","tarjan","Tarjan's algo for finding strongly connected components in a directed graph  Uses two main attributes of each node to track reachability, the index of that node within a component(index), and the lowest index reachable from that node(lowlink).  We then perform a dfs of the each component making sure to update these parameters for each node and saving the nodes we visit on the way.  If ever we find that the lowest reachable node from a current node is equal to the index of the current node then it must be the root of a strongly connected component and so we save it and it's equireachable vertices as a strongly connected component.  Complexity: strong_connect() is called at most once for each node and has a complexity of O(|E|) as it is DFS. Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)  >>> tarjan([[2, 3, 4], [2, 3, 4], [0, 1, 3], [0, 1, 2], [1]]) [[4, 3, 1, 2, 0]] >>> tarjan([[], [], [], []]) [[0], [1], [2], [3]] >>> a = [0, 1, 2, 3, 4, 5, 4] >>> b = [1, 0, 3, 2, 5, 4, 0] >>> n = 7 >>> sorted(tarjan(create_graph(n, list(zip(a, b))))) == sorted( ...     tarjan(create_graph(n, list(zip(a[::-1], b[::-1]))))) True >>> a = [0, 1, 2, 3, 4, 5, 6] >>> b = [0, 1, 2, 3, 4, 5, 6] >>> sorted(tarjan(create_graph(n, list(zip(a, b))))) [[0], [1], [2], [3], [4], [5], [6]]","len, deque, range, stack.append, range, range, stack.pop, component.append, components.append, strong_connect, strong_connect, stack.pop, component.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\tarjans_scc.py","","create_graph",">>> n = 7 >>> source = [0, 0, 1, 2, 3, 3, 4, 4, 6] >>> target = [1, 3, 2, 0, 1, 4, 5, 6, 5] >>> edges = list(zip(source, target)) >>> create_graph(n, edges) [[1, 3], [2], [0], [1, 4], [5, 6], [], [5]]",".append, range"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\tarjans_scc.py","","strong_connect","","stack.append, stack.pop, component.append, components.append, strong_connect, stack.pop, component.append"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\tests\test_min_spanning_tree_kruskal.py","","test_kruskal_successful_result","","kruskal, sorted, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\graphs\tests\test_min_spanning_tree_prim.py","","test_prim_successful_result","","defaultdict, mst, .append, .append, tuple, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\best_time_to_buy_and_sell_stock.py","","max_profit",">>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\fractional_cover_problem.py","Item","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\fractional_cover_problem.py","","fractional_cover","Solve the Fractional Cover Problem.  Args:     items: A list of items, where each item has weight and value attributes.     capacity: The maximum weight capacity of the knapsack.  Returns:     The maximum value that can be obtained by selecting fractions of items to cover     the knapsack's capacity.  Raises:     ValueError: If capacity is negative.  Examples: >>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50) 240.0  >>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25) 135.0  >>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60) 280.0  >>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30) 180.0  >>> fractional_cover(items=[], capacity=50) 0.0  >>> fractional_cover(items=[Item(10, 60)], capacity=5) 30.0  >>> fractional_cover(items=[Item(10, 60)], capacity=1) 6.0  >>> fractional_cover(items=[Item(10, 60)], capacity=0) 0.0  >>> fractional_cover(items=[Item(10, 60)], capacity=-1) Traceback (most recent call last):     ... ValueError: Capacity cannot be negative","sorted, ValueError, min, attrgetter"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\fractional_cover_problem.py","","ratio","Return the value-to-weight ratio for the item.  Returns:     float: The value-to-weight ratio for the item.  Examples: >>> Item(10, 65).ratio 6.5  >>> Item(20, 100).ratio 5.0  >>> Item(30, 120).ratio 4.0",""
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\fractional_knapsack.py","","frac_knapsack",">>> frac_knapsack([60, 100, 120], [10, 20, 30], 50, 3) 240.0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10, 4) 105.0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 4) 95.0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6], 8, 4) 60.0 >>> frac_knapsack([10, 40, 30], [5, 4, 6, 3], 8, 4) 60.0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 0, 4) 0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 0) 95.0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], -8, 4) 0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, -4) 95.0 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 800, 4) 130 >>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 400) 95.0 >>> frac_knapsack(""ABCD"", [5, 4, 6, 3], 8, 400) Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for /: 'str' and 'int'","sorted, list, bisect, zip, accumulate, sum, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\fractional_knapsack_2.py","","fractional_knapsack",">>> value = [1, 3, 5, 7, 9] >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1] >>> fractional_knapsack(value, weight, 5) (25, [1, 1, 1, 1, 1]) >>> fractional_knapsack(value, weight, 15) (25, [1, 1, 1, 1, 1]) >>> fractional_knapsack(value, weight, 25) (25, [1, 1, 1, 1, 1]) >>> fractional_knapsack(value, weight, 26) (25, [1, 1, 1, 1, 1]) >>> fractional_knapsack(value, weight, -1) (-90.0, [0, 0, 0, 0, -10.0]) >>> fractional_knapsack([1, 3, 5, 7], weight, 30) (16, [1, 1, 1, 1]) >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30) (25, [1, 1, 1, 1, 1]) >>> fractional_knapsack([], [], 30) (0, [])","list, index.sort, range, len, len, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\gas_station.py","GasStation","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\gas_station.py","","get_gas_stations","This function returns a tuple of gas stations.  Args:     gas_quantities: Amount of gas available at each station     costs: The cost of gas required to move from one station to the next  Returns:     A tuple of gas stations  >>> gas_stations = get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) >>> len(gas_stations) 5 >>> gas_stations[0] GasStation(gas_quantity=1, cost=3) >>> gas_stations[-1] GasStation(gas_quantity=5, cost=2)","tuple, GasStation, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\gas_station.py","","can_complete_journey","This function returns the index from which to start the journey in order to reach the end.  Args:     gas_quantities [list]: Amount of gas available at each station     cost [list]: The cost of gas required to move from one station to the next  Returns:     start [int]: start index needed to complete the journey  Examples: >>> can_complete_journey(get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])) 3 >>> can_complete_journey(get_gas_stations([2, 3, 4], [3, 4, 3])) -1","sum, sum, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\minimum_coin_change.py","","find_minimum_change","Find the minimum change from the given denominations and value >>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745) [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5] >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987) [500, 100, 100, 100, 100, 50, 20, 10, 5, 2] >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0) [] >>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98) [] >>> find_minimum_change([1, 5, 100, 500, 1000], 456) [100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]","int, reversed, int, int, int, answer.append"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\minimum_waiting_time.py","","minimum_waiting_time","This function takes a list of query times and returns the minimum waiting time for all queries to be completed.  Args:     queries: A list of queries measured in picoseconds  Returns:     total_waiting_time: Minimum waiting time measured in picoseconds  Examples: >>> minimum_waiting_time([3, 2, 1, 2, 6]) 17 >>> minimum_waiting_time([3, 2, 1]) 4 >>> minimum_waiting_time([1, 2, 3, 4]) 10 >>> minimum_waiting_time([5, 5, 5, 5]) 30 >>> minimum_waiting_time([]) 0","len, sum, enumerate, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\optimal_merge_pattern.py","","optimal_merge_pattern","Function to merge all the files with optimum cost  Args:     files [list]: A list of sizes of different files to be merged  Returns:     optimal_merge_cost [int]: Optimal cost to merge all those files  Examples: >>> optimal_merge_pattern([2, 3, 4]) 14 >>> optimal_merge_pattern([5, 10, 20, 30, 30]) 205 >>> optimal_merge_pattern([8, 8, 8, 8, 8]) 96","len, range, files.append, files.index, files.pop, min"
"C:/Users/Joseph Dania/Desktop/python_repo\greedy_methods\smallest_range.py","","smallest_range","Find the smallest range from each list in nums.  Uses min heap for efficiency. The range includes at least one number from each list.  Args:     `nums`: List of k sorted integer lists.  Returns:     list: Smallest range as a two-element list.  Examples:  >>> smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]) [20, 24] >>> smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) [1, 1] >>> smallest_range(((1, 2, 3), (1, 2, 3), (1, 2, 3))) [1, 1] >>> smallest_range(((-3, -2, -1), (0, 0, 0), (1, 2, 3))) [-1, 1] >>> smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [3, 7] >>> smallest_range([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [0, 0] >>> smallest_range([[], [], []]) Traceback (most recent call last):     ... IndexError: list index out of range","enumerate, heappush, max, heappop, heappush, max, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\adler32.py","","adler32","Function implements adler-32 hash. Iterates and evaluates a new value for each character  >>> adler32('Algorithms') 363791387  >>> adler32('go adler em all') 708642122","ord"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\chaos_machine.py","","push","","enumerate, float, round, max, max, float"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\chaos_machine.py","","pull","","range, int, int, round, xorshift, float"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\chaos_machine.py","","reset","",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\chaos_machine.py","","xorshift","",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\djb2.py","","djb2","Implementation of djb2 hash algorithm that is popular because of it's magic constants.  >>> djb2('Algorithms') 3782405311  >>> djb2('scramble bits') 1609059040","ord"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\elf.py","","elf_hash","Implementation of ElfHash Algorithm, a variant of PJW hash function.  >>> elf_hash('lorem ipsum') 253956621","ord"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\enigma_machine.py","","rotator","","gear_one.append, gear_two.append, len, gear_three.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\enigma_machine.py","","engine","","alphabets.index, gear_three.index, gear_two.index, gear_one.index, code.append, rotator"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\fletcher16.py","","fletcher16","Loop through every character in the data and add to two sums.  >>> fletcher16('hello world') 6752 >>> fletcher16('onethousandfourhundredthirtyfour') 28347 >>> fletcher16('The quick brown fox jumps over the lazy dog.') 5655","bytes"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\hamming_code.py","","text_to_bits",">>> text_to_bits(""msg"") '011011010111001101100111'","bits.zfill, bin, int.from_bytes, text.encode, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\hamming_code.py","","text_from_bits",">>> text_from_bits('011011010111001101100111') 'msg'","int, .decode, n.to_bytes, n.bit_length"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\hamming_code.py","","emitter_converter",":param size_par: how many parity bits the message must have :param data:  information bits :return: message to be transmitted by unreliable medium         - bits of information merged with parity bits  >>> emitter_converter(4, ""101010111111"") ['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1'] >>> emitter_converter(5, ""101010111111"") Traceback (most recent call last):     ... ValueError: size of parity don't match with size of data","range, range, range, ValueError, enumerate, parity.append, len, bin, range, .is_integer, data_out_gab.append, data_ord.append, data_ord.append, len, data_out.append, data_out.append, len, len, data_out_gab.append, data_out_gab.append, str, len, np.log, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\hamming_code.py","","receptor_converter",">>> receptor_converter(4, ""1111010010111111"") (['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)","enumerate, range, range, range, enumerate, parity.append, .is_integer, data_out_gab.append, data_out_gab.append, data_output.append, parity_received.append, bin, range, .is_integer, data_out_gab.append, data_out_gab.append, data_ord.append, data_ord.append, str, len, data_out.append, data_out.append, len, str, np.log, np.log, len, np.log, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\luhn.py","","is_luhn","Perform Luhn validation on an input string Algorithm: * Double every other digit starting from 2nd last digit. * Subtract 9 if number is greater than 9. * Sum the numbers * >>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713, ...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718, ...     79927398719) >>> [is_luhn(str(test_case)) for test_case in test_cases] [False, False, False, True, False, False, False, False, False, False]","list, vector.reverse, enumerate, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","to_little_endian","Converts the given string to little-endian in groups of 8 chars.  Arguments:     string_32 {[string]} -- [32-char string]  Raises:     ValueError -- [input is not 32 char]  Returns:     32-char little-endian string >>> to_little_endian(b'1234567890abcdfghijklmnopqrstuvw') b'pqrstuvwhijklmno90abcdfg12345678' >>> to_little_endian(b'1234567890') Traceback (most recent call last): ... ValueError: Input must be of length 32","len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","reformat_hex","Converts the given non-negative integer to hex string.  Example: Suppose the input is the following:     i = 1234      The input is 0x000004d2 in hex, so the little-endian hex string is     ""d2040000"".  Arguments:     i {[int]} -- [integer]  Raises:     ValueError -- [input is negative]  Returns:     8-char little-endian hex string  >>> reformat_hex(1234) b'd2040000' >>> reformat_hex(666) b'9a020000' >>> reformat_hex(0) b'00000000' >>> reformat_hex(1234567890) b'd2029649' >>> reformat_hex(1234567890987654321) b'b11c6cb1' >>> reformat_hex(-1) Traceback (most recent call last): ... ValueError: Input must be non-negative","ValueError, format, .encode"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","preprocess","Preprocesses the message string: - Convert message to bit string - Pad bit string to a multiple of 512 chars:     - Append a 1     - Append 0's until length = 448 (mod 512)     - Append length of original message (64 chars)  Example: Suppose the input is the following:     message = ""a""      The message bit string is ""01100001"", which is 8 bits long. Thus, the     bit string needs 439 bits of padding so that     (bit_string + ""1"" + padding) = 448 (mod 512).     The message length is ""000010000...0"" in 64-bit little-endian binary.     The combined bit string is then 512 bits long.  Arguments:     message {[string]} -- [message string]  Returns:     processed bit string padded to a multiple of 512 chars  >>> preprocess(b""a"") == (b""01100001"" + b""1"" + ...                     (b""0"" * 439) + b""00001000"" + (b""0"" * 56)) True >>> preprocess(b"""") == b""1"" + (b""0"" * 447) + (b""0"" * 64) True",".encode, .encode, to_little_endian, to_little_endian, format, len, format, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","get_block_words","Splits bit string into blocks of 512 chars and yields each block as a list of 32-bit words  Example: Suppose the input is the following:     bit_string =         ""000000000...0"" +  # 0x00 (32 bits, padded to the right)         ""000000010...0"" +  # 0x01 (32 bits, padded to the right)         ""000000100...0"" +  # 0x02 (32 bits, padded to the right)         ""000000110...0"" +  # 0x03 (32 bits, padded to the right)         ...         ""000011110...0""    # 0x0a (32 bits, padded to the right)      Then len(bit_string) == 512, so there'll be 1 block. The block is split     into 32-bit words, and each word is converted to little endian. The     first word is interpreted as 0 in decimal, the second word is     interpreted as 1 in decimal, etc.      Thus, block_words == [[0, 1, 2, 3, ..., 15]].  Arguments:     bit_string {[string]} -- [bit string with multiple of 512 as length]  Raises:     ValueError -- [length of bit string isn't multiple of 512]  Yields:     a list of 16 32-bit words  >>> test_string = ("""".join(format(n << 24, ""032b"") for n in range(16)) ...                  .encode(""utf-8"")) >>> list(get_block_words(test_string)) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]] >>> list(get_block_words(test_string * 4)) == [list(range(16))] * 4 True >>> list(get_block_words(b""1"" * 512)) == [[4294967295] * 16] True >>> list(get_block_words(b"""")) [] >>> list(get_block_words(b""1111"")) Traceback (most recent call last): ... ValueError: Input must have length that's a multiple of 512","range, ValueError, len, range, len, block_words.append, int, to_little_endian"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","not_32","Perform bitwise NOT on given int.  Arguments:     i {[int]} -- [given int]  Raises:     ValueError -- [input is negative]  Returns:     Result of bitwise NOT on i  >>> not_32(34) 4294967261 >>> not_32(1234) 4294966061 >>> not_32(4294966061) 1234 >>> not_32(0) 4294967295 >>> not_32(1) 4294967294 >>> not_32(-1) Traceback (most recent call last): ... ValueError: Input must be non-negative","format, int, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","sum_32","Add two numbers as 32-bit ints.  Arguments:     a {[int]} -- [first given int]     b {[int]} -- [second given int]  Returns:     (a + b) as an unsigned 32-bit int  >>> sum_32(1, 1) 2 >>> sum_32(2, 3) 5 >>> sum_32(0, 0) 0 >>> sum_32(-1, -1) 4294967294 >>> sum_32(4294967295, 1) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","left_rotate_32","Rotate the bits of a given int left by a given amount.  Arguments:     i {[int]} -- [given int]     shift {[int]} -- [shift amount]  Raises:     ValueError -- [either given int or shift is negative]  Returns:     `i` rotated to the left by `shift` bits  >>> left_rotate_32(1234, 1) 2468 >>> left_rotate_32(1111, 4) 17776 >>> left_rotate_32(2147483648, 1) 1 >>> left_rotate_32(2147483648, 3) 4 >>> left_rotate_32(4294967295, 4) 4294967295 >>> left_rotate_32(1234, 0) 1234 >>> left_rotate_32(0, 0) 0 >>> left_rotate_32(-1, 0) Traceback (most recent call last): ... ValueError: Input must be non-negative >>> left_rotate_32(0, -1) Traceback (most recent call last): ... ValueError: Shift must be non-negative","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\md5.py","","md5_me","Returns the 32-char MD5 hash of a given message.  Reference: https://en.wikipedia.org/wiki/MD5#Algorithm  Arguments:     message {[string]} -- [message]  Returns:     32-char MD5 hash string  >>> md5_me(b"""") b'd41d8cd98f00b204e9800998ecf8427e' >>> md5_me(b""The quick brown fox jumps over the lazy dog"") b'9e107d9d372bb6826bd81d3542a419d6' >>> md5_me(b""The quick brown fox jumps over the lazy dog."") b'e4d909c290d0fb1ca068ffaddf22cbd0'  >>> import hashlib >>> from string import ascii_letters >>> msgs = [b"""", ascii_letters.encode(""utf-8""), """".encode(""utf-8""), ...         b""The quick brown fox jumps over the lazy dog.""] >>> all(md5_me(msg) == hashlib.md5(msg).hexdigest().encode(""utf-8"") for msg in msgs) True","preprocess, get_block_words, int, range, sum_32, sum_32, sum_32, sum_32, reformat_hex, range, sum_32, reformat_hex, abs, left_rotate_32, reformat_hex, reformat_hex, sin, not_32"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sdbm.py","","sdbm","Function implements sdbm hash, easy to use, great for bits scrambling. iterates over each character in the given string and applies function to each of them.  >>> sdbm('Algorithms') 1462174910723540325254304520539387479031000036  >>> sdbm('scramble bits') 730247649148944819640658295400555317318720608290373040936089","ord"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","SHA1Hash","","Class to contain the entire pipeline for SHA1 hashing algorithm >>> SHA1Hash(bytes('Allan', 'utf-8')).final_hash() '872af2d8ac3d8695387e7c804bf0e02c18df9e6e'",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","test_sha1_hash","",".final_hash, .hexdigest, SHA1Hash, hashlib.sha1"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","main","Provides option 'string' or 'file' to take input and prints the calculated SHA1 hash. unittest.main() has been commented out because we probably don't want to run the test each time.","argparse.ArgumentParser, parser.add_argument, parser.add_argument, parser.parse_args, print, bytes, .final_hash, open, f.read, SHA1Hash"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","__init__","Initiates the variables data and h. h is a list of 5 8-digit hexadecimal numbers corresponding to (1732584193, 4023233417, 2562383102, 271733878, 3285377520) respectively. We will start with this as a message digest. 0x is how you write hexadecimal numbers in Python",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","rotate","Static method to be used inside other methods. Left rotates n by b. >>> SHA1Hash('').rotate(12,2) 48",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","padding","Pads the input message with zeros so that padded_data has 64 bytes or 512 bits","struct.pack, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","split_blocks","Returns a list of bytestrings each of length 64","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","expand_block","Takes a bytestring-block of length 64, unpacks it to a list of integers and returns a list of 80 integers after some bit operations","range, list, self.rotate, struct.unpack"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha1.py","","final_hash","Calls all the other methods to process the input. Pads the data, then splits into blocks and then does a series of operations for each block (including expansion). For each block, the variable h that was initialized is copied to a,b,c,d,e and these 5 variables a,b,c,d,e undergo several changes. After all the blocks are processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1] and so on. This h becomes our final hash which is returned.","self.padding, self.split_blocks, .format, self.expand_block, range, self.rotate, self.rotate"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","SHA256","","Class to contain the entire pipeline for SHA1 Hashing Algorithm  >>> SHA256(b'Python').hash '18885f27b5af9012df19e496460f9294d5ab76128824c6f993787004f6d9a7db'  >>> SHA256(b'hello world').hash 'b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9'",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","SHA256HashTest","","Test class for the SHA256 class. Inherits the TestCase class from unittest",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","","main","Provides option 'string' or 'file' to take input and prints the calculated SHA-256 hash","doctest.testmod, argparse.ArgumentParser, parser.add_argument, parser.add_argument, parser.parse_args, print, bytes, open, f.read, SHA256"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","","__init__","","self.preprocessing, self.final_hash"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","","preprocessing","","struct.pack, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","","final_hash","",".join, list, range, range, struct.unpack, .zfill, len, self.ror, self.ror, enumerate, self.ror, self.ror, self.ror, self.ror, self.ror, self.ror, self.ror, self.ror, hex"
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","","ror","Right rotate a given unsigned number by a certain amount of rotations",""
"C:/Users/Joseph Dania/Desktop/python_repo\hashes\sha256.py","","test_match_hashes","","bytes, .hexdigest, SHA256, hashlib.sha256"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\greedy_knapsack.py","","calc_profit","Function description is as follows- :param profit: Take a list of profits :param weight: Take a list of weight if bags corresponding to the profits :param max_weight: Maximum weight that could be carried :return: Maximum expected gain  >>> calc_profit([1, 2, 3], [3, 4, 5], 15) 6 >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25) 27","any, any, sorted, len, len, len, ValueError, ValueError, ValueError, ValueError, profit_by_weight.index, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\knapsack.py","","knapsack","Returns the maximum value that can be put in a knapsack of a capacity cap, whereby each weight w has a specific value val with option to allow repetitive selection of items  >>> cap = 50 >>> val = [60, 100, 120] >>> w = [10, 20, 30] >>> c = len(val) >>> knapsack(cap, w, val, c) 220  Given the repetition is NOT allowed, the result is 220 cause the values of 100 and 120 got the weight of 50 which is the limit of the capacity. >>> knapsack(cap, w, val, c, True) 300  Given the repetition is allowed, the result is 300 cause the values of 60*5 (pick 5 times) got the weight of 10*5 which is the limit of the capacity.","knapsack_recur, knapsack_recur, knapsack_recur, max, knapsack_recur"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\knapsack.py","","knapsack_recur","","knapsack_recur, knapsack_recur, max, knapsack_recur"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\recursive_approach_knapsack.py","","knapsack","Function description is as follows- :param weights: Take a list of weights :param values: Take a list of profits corresponding to the weights :param number_of_items: number of items available to pick from :param max_weight: Maximum weight that could be carried :param index: the element we are looking at :return: Maximum expected gain >>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0) 13 >>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0) 27","knapsack, max, knapsack"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","TestClass","","Test cases for knapsack",""
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","","test_sorted","kp.calc_profit takes the required argument (profit, weight, max_weight) and returns whether the answer matches to the expected ones","kp.calc_profit"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","","test_negative_max_weight","Returns ValueError for any negative max_weight value :return: ValueError","pytest.raises"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","","test_negative_profit_value","Returns ValueError for any negative profit value in the list :return: ValueError","pytest.raises"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","","test_negative_weight_value","Returns ValueError for any negative weight value in the list :return: ValueError","pytest.raises"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","","test_null_max_weight","Returns ValueError for any zero max_weight value :return: ValueError","pytest.raises"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_greedy_knapsack.py","","test_unequal_list_length","Returns IndexError if length of lists (profit and weight) are unequal. :return: IndexError","pytest.raises"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_knapsack.py","Test","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_knapsack.py","","test_base_case","test for the base case","len, len, k.knapsack, k.knapsack"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_knapsack.py","","test_easy_case","test for the easy case","len, k.knapsack"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_knapsack.py","","test_knapsack","test for the knapsack","len, k.knapsack"
"C:/Users/Joseph Dania/Desktop/python_repo\knapsack\tests\test_knapsack.py","","test_knapsack_repetition","test for the knapsack repetition","len, k.knapsack"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\gaussian_elimination.py","","retroactive_resolution","This function performs a retroactive linear system resolution for triangular matrix  Examples:     1.         * 2x1 + 2x2 - 1x3 = 5         * 0x1 - 2x2 - 1x3 = -7         * 0x1 + 0x2 + 5x3 = 15     2.         * 2x1 + 2x2 = -1         * 0x1 - 2x2 = -1  >>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]]) array([[2.],        [2.],        [3.]]) >>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]]) array([[-1. ],        [ 0.5]])","np.shape, np.zeros, reversed, range, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\gaussian_elimination.py","","gaussian_elimination","This function performs Gaussian elimination method  Examples:     1.         * 1x1 - 4x2 - 2x3 = -2         * 5x1 + 2x2 - 2x3 = -3         * 1x1 - 1x2 + 0x3 = 4     2.         * 1x1 + 2x2 = 5         * 5x1 + 2x2 = 5  >>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]]) array([[ 2.3 ],        [-1.7 ],        [ 5.55]]) >>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]]) array([[0. ],        [2.5]])","np.shape, np.concatenate, augmented_mat.astype, range, retroactive_resolution, np.array, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\jacobi_iteration_method.py","","jacobi_iteration_method","Jacobi Iteration Method: An iterative algorithm to determine the solutions of strictly diagonally dominant system of linear equations  4x1 +  x2 +  x3 =  2  x1 + 5x2 + 2x3 = -6  x1 + 2x2 + 4x3 = -4  x_init = [0.5, -0.5 , -0.5]  Examples:  >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]]) >>> constant = np.array([[2], [-6], [-4]]) >>> init_val = [0.5, -0.5, -0.5] >>> iterations = 3 >>> jacobi_iteration_method(coefficient, constant, init_val, iterations) [0.909375, -1.14375, -0.7484375]   >>> coefficient = np.array([[4, 1, 1], [1, 5, 2]]) >>> constant = np.array([[2], [-6], [-4]]) >>> init_val = [0.5, -0.5, -0.5] >>> iterations = 3 >>> jacobi_iteration_method(coefficient, constant, init_val, iterations) Traceback (most recent call last):     ... ValueError: Coefficient matrix dimensions must be nxn but received 2x3  >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]]) >>> constant = np.array([[2], [-6]]) >>> init_val = [0.5, -0.5, -0.5] >>> iterations = 3 >>> jacobi_iteration_method( ...     coefficient, constant, init_val, iterations ... )  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but             received 3x3 and 2x1  >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]]) >>> constant = np.array([[2], [-6], [-4]]) >>> init_val = [0.5, -0.5] >>> iterations = 3 >>> jacobi_iteration_method( ...     coefficient, constant, init_val, iterations ... )  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Number of initial values must be equal to number of rows in coefficient             matrix but received 2 and 3  >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]]) >>> constant = np.array([[2], [-6], [-4]]) >>> init_val = [0.5, -0.5, -0.5] >>> iterations = 0 >>> jacobi_iteration_method(coefficient, constant, init_val, iterations) Traceback (most recent call last):     ... ValueError: Iterations must be at least 1","np.concatenate, strictly_diagonally_dominant, np.diag, .reshape, np.where, i_col.reshape, range, new_val.tolist, ValueError, ValueError, ValueError, len, ValueError, ValueError, np.eye, np.take, np.sum, len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\jacobi_iteration_method.py","","strictly_diagonally_dominant",">>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]]) >>> strictly_diagonally_dominant(table) True  >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]]) >>> strictly_diagonally_dominant(table) Traceback (most recent call last):     ... ValueError: Coefficient matrix is not strictly diagonally dominant","range, range, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\lu_decomposition.py","","lower_upper_decomposition","Perform LU decomposition on a given matrix and raises an error if the matrix isn't square or if no such decomposition exists  >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]]) >>> lower_mat, upper_mat = lower_upper_decomposition(matrix) >>> lower_mat array([[1. , 0. , 0. ],        [0. , 1. , 0. ],        [2.5, 8. , 1. ]]) >>> upper_mat array([[  2. ,  -2. ,   1. ],        [  0. ,   1. ,   2. ],        [  0. ,   0. , -17.5]])  >>> matrix = np.array([[4, 3], [6, 3]]) >>> lower_mat, upper_mat = lower_upper_decomposition(matrix) >>> lower_mat array([[1. , 0. ],        [1.5, 1. ]]) >>> upper_mat array([[ 4. ,  3. ],        [ 0. , -1.5]])  >>> # Matrix is not square >>> matrix = np.array([[2, -2, 1], [0, 1, 2]]) >>> lower_mat, upper_mat = lower_upper_decomposition(matrix) Traceback (most recent call last):     ... ValueError: 'table' has to be of square shaped array but got a 2x3 array: [[ 2 -2  1]  [ 0  1  2]]  >>> # Matrix is invertible, but its first leading principal minor is 0 >>> matrix = np.array([[0, 1], [1, 0]]) >>> lower_mat, upper_mat = lower_upper_decomposition(matrix) Traceback (most recent call last): ... ArithmeticError: No LU decomposition exists  >>> # Matrix is singular, but its first leading principal minor is 1 >>> matrix = np.array([[1, 0], [1, 0]]) >>> lower_mat, upper_mat = lower_upper_decomposition(matrix) >>> lower_mat array([[1., 0.],        [1., 1.]]) >>> upper_mat array([[1., 0.],        [0., 0.]])  >>> # Matrix is singular, but its first leading principal minor is 0 >>> matrix = np.array([[0, 1], [0, 1]]) >>> lower_mat, upper_mat = lower_upper_decomposition(matrix) Traceback (most recent call last): ... ArithmeticError: No LU decomposition exists","np.shape, np.zeros, np.zeros, range, ValueError, range, range, np.sum, np.sum, ArithmeticError"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\matrix_inversion.py","","invert_matrix","Returns the inverse of a square matrix using NumPy.  Parameters: matrix (list[list[float]]): A square matrix.  Returns: list[list[float]]: Inverted matrix if invertible, else raises error.  >>> invert_matrix([[4.0, 7.0], [2.0, 6.0]]) [[0.6000000000000001, -0.7000000000000001], [-0.2, 0.4]] >>> invert_matrix([[1.0, 2.0], [0.0, 0.0]]) Traceback (most recent call last):     ... ValueError: Matrix is not invertible","np.array, inv_matrix.tolist, np.linalg.inv, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\conjugate_gradient.py","","_is_matrix_spd","Returns True if input matrix is symmetric positive definite. Returns False otherwise.  For a matrix to be SPD, all eigenvalues must be positive.  >>> import numpy as np >>> matrix = np.array([ ... [4.12401784, -5.01453636, -0.63865857], ... [-5.01453636, 12.33347422, -3.40493586], ... [-0.63865857, -3.40493586,  5.78591885]]) >>> _is_matrix_spd(matrix) True >>> matrix = np.array([ ... [0.34634879,  1.96165514,  2.18277744], ... [0.74074469, -1.19648894, -1.34223498], ... [-0.7687067 ,  0.06018373, -1.16315631]]) >>> _is_matrix_spd(matrix) False","np.linalg.eigh, bool, np.allclose, np.all, np.shape, np.shape"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\conjugate_gradient.py","","_create_spd_matrix","Returns a symmetric positive definite matrix given a dimension.  Input: dimension gives the square matrix dimension.  Output: spd_matrix is an diminesion x dimensions symmetric positive definite (SPD) matrix.  >>> import numpy as np >>> dimension = 3 >>> spd_matrix = _create_spd_matrix(dimension) >>> _is_matrix_spd(spd_matrix) True","np.random.default_rng, rng.normal, np.dot, _is_matrix_spd"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\conjugate_gradient.py","","conjugate_gradient","Returns solution to the linear system np.dot(spd_matrix, x) = b.  Input: spd_matrix is an NxN Symmetric Positive Definite (SPD) matrix. load_vector is an Nx1 vector.  Output: x is an Nx1 vector that is the solution vector.  >>> import numpy as np >>> spd_matrix = np.array([ ... [8.73256573, -5.02034289, -2.68709226], ... [-5.02034289,  3.78188322,  0.91980451], ... [-2.68709226,  0.91980451,  1.94746467]]) >>> b = np.array([ ... [-5.80872761], ... [ 3.23807431], ... [ 1.95381422]]) >>> conjugate_gradient(spd_matrix, b) array([[-0.63114139],        [-0.01561498],        [ 0.13979294]])","_is_matrix_spd, np.zeros, np.copy, np.copy, np.dot, np.linalg.norm, np.linalg.norm, np.maximum, np.copy, np.copy, np.copy, np.shape, np.shape, np.shape, np.shape, np.dot, np.dot, np.dot, np.dot, np.shape"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\conjugate_gradient.py","","test_conjugate_gradient",">>> test_conjugate_gradient()  # self running tests","_create_spd_matrix, np.random.default_rng, rng.normal, np.dot, np.linalg.solve, conjugate_gradient, np.linalg.norm, np.linalg.norm"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\gaussian_elimination_pivoting.py","","solve_linear_system","Solve a linear system of equations using Gaussian elimination with partial pivoting  Args:   - `matrix`: Coefficient matrix with the last column representing the constants.  Returns:   - Solution vector.  Raises:   - ``ValueError``: If the matrix is not correct (i.e., singular).  https://courses.engr.illinois.edu/cs357/su2013/lect.htm Lecture 7  Example:  >>> A = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float) >>> B = np.array([8, -11, -3], dtype=float) >>> solution = solve_linear_system(np.column_stack((A, B))) >>> np.allclose(solution, np.array([2., 3., -1.])) True >>> solve_linear_system(np.array([[0, 0, 0]], dtype=float)) Traceback (most recent call last):     ... ValueError: Matrix is not square >>> solve_linear_system(np.array([[0, 0, 0], [0, 0, 0]], dtype=float)) Traceback (most recent call last):     ... ValueError: Matrix is singular","np.copy, range, range, np.asarray, ValueError, range, x_lst.insert, range, abs, ValueError, range, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","Vector","","This class represents a vector of arbitrary size. You need to give the vector components.  Overview of the methods:      __init__(components: Collection[float] | None): init the vector     __len__(): gets the size of the vector (number of components)     __str__(): returns a string representation     __add__(other: Vector): vector addition     __sub__(other: Vector): vector subtraction     __mul__(other: float): scalar multiplication     __mul__(other: Vector): dot product     copy(): copies this vector and returns it     component(i): gets the i-th component (0-indexed)     change_component(pos: int, value: float): changes specified component     euclidean_length(): returns the euclidean length of the vector     angle(other: Vector, deg: bool): returns the angle between two vectors",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","zero_vector","returns a zero-vector of size 'dimension'","isinstance, Vector"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","unit_basis_vector","returns a unit basis vector with a One at index 'pos' (indexing at 0)","isinstance, isinstance, Vector"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","axpy","input: a 'scalar' and two vectors 'x' and 'y' output: a vector computes the axpy operation","isinstance, isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","random_vector","input: size (N) of the vector.        random range (a,b) output: returns a random vector of size N, with         random integer components between 'a' and 'b'.","random.seed, Vector, random.randint, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","Matrix","","class: Matrix This class represents an arbitrary matrix.  Overview of the methods:      __init__():     __str__(): returns a string representation     __add__(other: Matrix): matrix addition     __sub__(other: Matrix): matrix subtraction     __mul__(other: float): scalar multiplication     __mul__(other: Vector): vector multiplication     height() : returns height     width() : returns width     component(x: int, y: int): returns specified component     change_component(x: int, y: int, value: float): changes specified component     minor(x: int, y: int): returns minor along (x, y)     cofactor(x: int, y: int): returns cofactor along (x, y)     determinant() : returns determinant",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","square_zero_matrix","returns a square zero-matrix of dimension NxN","Matrix, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","random_matrix","returns a random matrix WxH with integer components between 'a' and 'b'","random.seed, Matrix, random.randint, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__init__","input: components or nothing simple constructor for init the vector","list"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__len__","returns the size of the vector","len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__str__","returns a string representation of the vector",".join, map"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__add__","input: other vector assumes: other vector has the same size returns a new vector that represents the sum.","len, len, Vector, Exception, other.component, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__sub__","input: other vector assumes: other vector has the same size returns a new vector that represents the difference.","len, len, Vector, Exception, other.component, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__eq__","performs the comparison between two vectors","all, isinstance, len, len, self.component, other.component, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__mul__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__mul__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__mul__","mul implements the scalar multiplication and the dot-product","isinstance, Vector, isinstance, len, sum, Exception, len, len, other.component, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","copy","copies this vector and returns it.","Vector"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","component","input: index (0-indexed) output: the i-th component of the vector.","isinstance, Exception, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","change_component","input: an index (pos) and a value changes the specified component (pos) with the 'value'","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","euclidean_length","returns the euclidean length of the vector  >>> Vector([2, 3, 4]).euclidean_length() 5.385164807134504 >>> Vector([1]).euclidean_length() 1.0 >>> Vector([0, -1, -2, -3, 4, 5, 6]).euclidean_length() 9.539392014169456 >>> Vector([]).euclidean_length() Traceback (most recent call last):     ... Exception: Vector is empty","math.sqrt, len, Exception, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","angle","find angle between two Vector (self, Vector)  >>> Vector([3, 4, -1]).angle(Vector([2, -1, 1])) 1.4906464636572374 >>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]), deg = True) 85.40775111366095 >>> Vector([3, 4, -1]).angle(Vector([2, -1])) Traceback (most recent call last):     ... Exception: invalid operand!","self.euclidean_length, other.euclidean_length, math.degrees, math.acos, math.acos"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__init__","simple constructor for initializing the matrix with components.",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__str__","returns a string representation of this matrix.","range, range, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__add__","implements matrix addition.","range, Matrix, Exception, other.width, other.height, matrix.append, other.component, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__sub__","implements matrix subtraction.","range, Matrix, Exception, other.width, other.height, matrix.append, other.component, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__mul__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__mul__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","__mul__","implements the matrix-vector multiplication. implements the matrix-scalar multiplication","isinstance, isinstance, len, zero_vector, range, Exception, Matrix, ans.change_component, sum, range, other.component, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","height","getter for the height",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","width","getter for the width",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","component","returns the specified (x,y) component","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","change_component","changes the x-y component of this matrix","Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","minor","returns the minor along (x, y)","range, .determinant, Exception, len, Matrix"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","cofactor","returns the cofactor (signed minor) along (x, y)","Exception, Exception, self.minor"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\lib.py","","determinant","returns the determinant of an nxn matrix using Laplace expansion","Exception, Exception, sum, self.cofactor, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\polynom_for_points.py","","points_to_polynomial","coordinates is a two dimensional matrix: [[x, y], [x, y], ...] number of points you want to use  >>> points_to_polynomial([]) Traceback (most recent call last):     ... ValueError: The program cannot work out a fitting polynomial. >>> points_to_polynomial([[]]) Traceback (most recent call last):     ... ValueError: The program cannot work out a fitting polynomial. >>> points_to_polynomial([[1, 0], [2, 0], [3, 0]]) 'f(x)=x^2*0.0+x^1*-0.0+x^0*0.0' >>> points_to_polynomial([[1, 1], [2, 1], [3, 1]]) 'f(x)=x^2*0.0+x^1*-0.0+x^0*1.0' >>> points_to_polynomial([[1, 3], [2, 3], [3, 3]]) 'f(x)=x^2*0.0+x^1*-0.0+x^0*3.0' >>> points_to_polynomial([[1, 1], [2, 2], [3, 3]]) 'f(x)=x^2*0.0+x^1*1.0+x^0*0.0' >>> points_to_polynomial([[1, 1], [2, 4], [3, 9]]) 'f(x)=x^2*1.0+x^1*-0.0+x^0*0.0' >>> points_to_polynomial([[1, 3], [2, 6], [3, 11]]) 'f(x)=x^2*1.0+x^1*-0.0+x^0*2.0' >>> points_to_polynomial([[1, -3], [2, -6], [3, -11]]) 'f(x)=x^2*-1.0+x^1*-0.0+x^0*-2.0' >>> points_to_polynomial([[1, 5], [2, 2], [3, 9]]) 'f(x)=x^2*5.0+x^1*-18.0+x^0*18.0' >>> points_to_polynomial([[1, 1], [1, 2], [1, 3]]) 'x=1' >>> points_to_polynomial([[1, 1], [2, 2], [2, 2]]) Traceback (most recent call last):     ... ValueError: The program cannot work out a fitting polynomial.","len, range, range, ValueError, len, len, ValueError, len, len, len, ValueError, range, str, .split, len, all, range, range, enumerate, range, len, tuple, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\power_iteration.py","","power_iteration","Power Iteration. Find the largest eigenvalue and corresponding eigenvector of matrix input_matrix given a random vector in the same space. Will work so long as vector has component of largest eigenvector. input_matrix must be either real or Hermitian.  Input input_matrix: input matrix whose largest eigenvalue we will find. Numpy array. np.shape(input_matrix) == (N,N). vector: random initial vector in same space as matrix. Numpy array. np.shape(vector) == (N,) or (N,1)  Output largest_eigenvalue: largest eigenvalue of the matrix input_matrix. Float. Scalar. largest_eigenvector: eigenvector corresponding to largest_eigenvalue. Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).  >>> import numpy as np >>> input_matrix = np.array([ ... [41,  4, 20], ... [ 4, 26, 30], ... [20, 30, 50] ... ]) >>> vector = np.array([41,4,20]) >>> power_iteration(input_matrix,vector) (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))","np.iscomplexobj, np.iscomplexobj, np.iscomplexobj, np.array_equal, np.dot, np.dot, np.real, float, np.shape, np.shape, np.shape, np.shape, np.linalg.norm, np.dot, np.abs, input_matrix.conj, vector.conj"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\power_iteration.py","","test_power_iteration",">>> test_power_iteration()  # self running tests","np.array, np.array, real_input_matrix.astype, np.triu, .astype, power_iteration, np.linalg.eigh, np.array, np.abs, np.linalg.norm, np.abs, np.abs"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\rank_of_matrix.py","","rank_of_matrix","Finds the rank of a matrix.  Args:     `matrix`: The matrix as a list of lists.  Returns:     The rank of the matrix.  Example:  >>> matrix1 = [[1, 2, 3], ...            [4, 5, 6], ...            [7, 8, 9]] >>> rank_of_matrix(matrix1) 2 >>> matrix2 = [[1, 0, 0], ...            [0, 1, 0], ...            [0, 0, 0]] >>> rank_of_matrix(matrix2) 2 >>> matrix3 = [[1, 2, 3, 4], ...            [5, 6, 7, 8], ...            [9, 10, 11, 12]] >>> rank_of_matrix(matrix3) 2 >>> rank_of_matrix([[2,3,-1,-1], ...                [1,-1,-2,4], ...                [3,1,3,-2], ...                [6,3,0,-7]]) 4 >>> rank_of_matrix([[2,1,-3,-6], ...                [3,-3,1,2], ...                [1,1,1,2]]) 3 >>> rank_of_matrix([[2,-1,0], ...                [1,3,4], ...                [4,1,-3]]) 3 >>> rank_of_matrix([[3,2,1], ...                [-6,-4,-2]]) 1 >>> rank_of_matrix([[],[]]) 0 >>> rank_of_matrix([[1]]) 1 >>> rank_of_matrix([[]]) 0","len, len, min, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\rayleigh_quotient.py","","is_hermitian","Checks if a matrix is Hermitian. >>> import numpy as np >>> A = np.array([ ... [2,    2+1j, 4], ... [2-1j,  3,  1j], ... [4,    -1j,  1]]) >>> is_hermitian(A) True >>> A = np.array([ ... [2,    2+1j, 4+1j], ... [2-1j,  3,  1j], ... [4,    -1j,  1]]) >>> is_hermitian(A) False","np.array_equal, matrix.conjugate"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\rayleigh_quotient.py","","rayleigh_quotient","Returns the Rayleigh quotient of a Hermitian matrix A and vector v. >>> import numpy as np >>> A = np.array([ ... [1,  2, 4], ... [2,  3,  -1], ... [4, -1,  1] ... ]) >>> v = np.array([ ... [1], ... [2], ... [3] ... ]) >>> rayleigh_quotient(A, v) array([[3.]])","v_star.dot, isinstance, v.conjugate, v_star_dot.dot, v_star.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\rayleigh_quotient.py","","tests","","np.array, np.array, is_hermitian, print, np.array, is_hermitian, rayleigh_quotient, rayleigh_quotient, float"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\schur_complement.py","","schur_complement","Schur complement of a symmetric matrix X given as a 2x2 block matrix consisting of matrices `A`, `B` and `C`. Matrix `A` must be quadratic and non-singular. In case `A` is singular, a pseudo-inverse may be provided using the `pseudo_inv` argument.  | Link to Wiki: https://en.wikipedia.org/wiki/Schur_complement | See also Convex Optimization - Boyd and Vandenberghe, A.5.5  >>> import numpy as np >>> a = np.array([[1, 2], [2, 1]]) >>> b = np.array([[0, 3], [3, 0]]) >>> c = np.array([[2, 1], [6, 3]]) >>> schur_complement(a, b, c) array([[ 5., -5.],        [ 0.,  6.]])","np.shape, np.shape, np.shape, ValueError, ValueError, np.linalg.inv, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\schur_complement.py","TestSchurComplement","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\schur_complement.py","","test_schur_complement","","np.array, np.array, np.array, schur_complement, np.block, np.linalg.det, np.linalg.det, np.linalg.det, np.is_close"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\schur_complement.py","","test_improper_a_b_dimensions","","np.array, np.array, np.array, pytest.raises, schur_complement"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\schur_complement.py","","test_improper_b_c_dimensions","","np.array, np.array, np.array, pytest.raises, schur_complement"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","Test","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_component","test for method component()","Vector, Vector, x.component, x.component"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_str","test for method toString()","Vector, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_size","test for method size()","Vector, len"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_euclidean_length","test for method euclidean_length()","Vector, Vector, Vector, Vector, x.euclidean_length, pytest.approx, y.euclidean_length, pytest.approx, z.euclidean_length, w.euclidean_length, pytest.approx"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_add","test for + operator","Vector, Vector, .component, .component, .component"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_sub","test for - operator","Vector, Vector, .component, .component, .component"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_mul","test for * operator","Vector, Vector, Vector, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_zero_vector","test for global function zero_vector()",".count, str, zero_vector"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_unit_basis_vector","test for global function unit_basis_vector()","str, unit_basis_vector"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_axpy","test for global function axpy() (operation)","Vector, Vector, str, axpy"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_copy","test for method copy()","Vector, x.copy, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_change_component","test for method change_component()","Vector, x.change_component, x.change_component, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_str_matrix","test for Matrix method str()","Matrix, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_minor","test for Matrix method minor()","Matrix, range, a.height, range, a.width, a.minor"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_cofactor","test for Matrix method cofactor()","Matrix, range, a.height, range, a.width, a.cofactor"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_determinant","test for Matrix method determinant()","Matrix, a.determinant"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test__mul__matrix","test for Matrix * operator","Matrix, Vector, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_change_component_matrix","test for Matrix method change_component()","Matrix, a.change_component, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_component_matrix","test for Matrix method component()","Matrix, a.component"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test__add__matrix","test for Matrix + operator","Matrix, Matrix, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test__sub__matrix","test for Matrix - operator","Matrix, Matrix, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\test_linear_algebra.py","","test_square_zero_matrix","test for global function square_zero_matrix()","str, square_zero_matrix"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\transformations_2d.py","","scaling",">>> scaling(5) [[5.0, 0.0], [0.0, 5.0]]","float, range, int, range"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\transformations_2d.py","","rotation",">>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE [[0.5253219888177297, -0.8509035245341184],  [0.8509035245341184, 0.5253219888177297]]","cos, sin"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\transformations_2d.py","","projection",">>> projection(45)  # doctest: +NORMALIZE_WHITESPACE [[0.27596319193541496, 0.446998331800279],  [0.446998331800279, 0.7240368080645851]]","cos, sin"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_algebra\src\transformations_2d.py","","reflection",">>> reflection(45)  # doctest: +NORMALIZE_WHITESPACE [[0.05064397763545947, 0.893996663600558],  [0.893996663600558, 0.7018070490682369]]","cos, sin"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","Tableau","","Operate on simplex tableaus  >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4]]), 2, 2) Traceback (most recent call last): ... TypeError: Tableau must have type float64  >>> Tableau(np.array([[-1,-1,0,0,-1],[1,3,1,0,4],[3,1,0,1,4.]]), 2, 2) Traceback (most recent call last): ... ValueError: RHS must be > 0  >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]), -2, 2) Traceback (most recent call last): ... ValueError: number of (artificial) variables must be a natural number",""
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","__init__","","self.generate_col_titles, TypeError, .all, ValueError, ValueError, self.objectives.append"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","generate_col_titles","Generate column titles for tableau of specific dimensions  >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]), ... 2, 0).generate_col_titles() ['x1', 'x2', 's1', 's2', 'RHS']  >>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]), ... 2, 2).generate_col_titles() ['x1', 'x2', 'RHS']","range, titles.append, range, titles.append, str"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","find_pivot","Finds the pivot row and column. >>> tuple(int(x) for x in Tableau(np.array([[-2,1,0,0,0], [3,1,1,0,6], ... [1,2,0,1,7.]]), 2, 0).find_pivot()) (1, 0)","np.argmax, slice, np.full, np.divide, np.nanargmin"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","pivot","Pivots on value on the intersection of pivot row and column.  >>> Tableau(np.array([[-2,-3,0,0,0],[1,3,1,0,4],[3,1,0,1,4.]]), ... 2, 2).pivot(1, 0).tolist() ... # doctest: +NORMALIZE_WHITESPACE [[0.0, 3.0, 2.0, 0.0, 8.0], [1.0, 3.0, 1.0, 0.0, 4.0], [0.0, -8.0, -3.0, 1.0, -8.0]]",".copy, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","change_stage","Exits first phase of the two-stage method by deleting artificial rows and columns, or completes the algorithm if exiting the standard case.  >>> Tableau(np.array([ ... [3, 3, -1, -1, 0, 0, 4], ... [2, 1, 0, 0, 0, 0, 0.], ... [1, 2, -1, 0, 1, 0, 2], ... [2, 1, 0, -1, 0, 1, 2] ... ]), 2, 2).change_stage().tolist() ... # doctest: +NORMALIZE_WHITESPACE [[2.0, 1.0, 0.0, 0.0, 0.0], [1.0, 2.0, -1.0, 0.0, 2.0], [2.0, 1.0, 0.0, -1.0, 2.0]]","self.objectives.pop, slice, np.delete, np.delete"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","run_simplex","Operate on tableau until objective function cannot be improved further.  # Standard linear program: Max:  x1 +  x2 ST:   x1 + 3x2 <= 4      3x1 +  x2 <= 4 >>> {key: float(value) for key, value in Tableau(np.array([[-1,-1,0,0,0], ... [1,3,1,0,4],[3,1,0,1,4.]]), 2, 0).run_simplex().items()} {'P': 2.0, 'x1': 1.0, 'x2': 1.0}  # Standard linear program with 3 variables: Max: 3x1 +  x2 + 3x3 ST:  2x1 +  x2 +  x3  2       x1 + 2x2 + 3x3  5      2x1 + 2x2 +  x3  6 >>> {key: float(value) for key, value in Tableau(np.array([ ... [-3,-1,-3,0,0,0,0], ... [2,1,1,1,0,0,2], ... [1,2,3,0,1,0,5], ... [2,2,1,0,0,1,6.] ... ]),3,0).run_simplex().items()} # doctest: +ELLIPSIS {'P': 5.4, 'x1': 0.199..., 'x3': 1.6}   # Optimal tableau input: >>> {key: float(value) for key, value in Tableau(np.array([ ... [0, 0, 0.25, 0.25, 2], ... [0, 1, 0.375, -0.125, 1], ... [1, 0, -0.125, 0.375, 1] ... ]), 2, 0).run_simplex().items()} {'P': 2.0, 'x1': 1.0, 'x2': 1.0}  # Non-standard: >= constraints Max: 2x1 + 3x2 +  x3 ST:   x1 +  x2 +  x3 <= 40      2x1 +  x2 -  x3 >= 10          -  x2 +  x3 >= 10 >>> {key: float(value) for key, value in Tableau(np.array([ ... [2, 0, 0, 0, -1, -1, 0, 0, 20], ... [-2, -3, -1, 0, 0, 0, 0, 0, 0], ... [1, 1, 1, 1, 0, 0, 0, 0, 40], ... [2, 1, -1, 0, -1, 0, 1, 0, 10], ... [0, -1, 1, 0, 0, -1, 0, 1, 10.] ... ]), 3, 2).run_simplex().items()} {'P': 70.0, 'x1': 10.0, 'x2': 10.0, 'x3': 20.0}  # Non standard: minimisation and equalities Min: x1 +  x2 ST: 2x1 +  x2 = 12     6x1 + 5x2 = 40 >>> {key: float(value) for key, value in Tableau(np.array([ ... [8, 6, 0, 0, 52], ... [1, 1, 0, 0, 0], ... [2, 1, 1, 0, 12], ... [6, 5, 0, 1, 40.], ... ]), 2, 2).run_simplex().items()} {'P': 7.0, 'x1': 5.0, 'x2': 2.0}   # Pivot on slack variables Max: 8x1 + 6x2 ST:   x1 + 3x2 <= 33      4x1 + 2x2 <= 48      2x1 + 4x2 <= 48       x1 +  x2 >= 10      x1        >= 2 >>> {key: float(value) for key, value in Tableau(np.array([ ... [2, 1, 0, 0, 0, -1, -1, 0, 0, 12.0], ... [-8, -6, 0, 0, 0, 0, 0, 0, 0, 0.0], ... [1, 3, 1, 0, 0, 0, 0, 0, 0, 33.0], ... [4, 2, 0, 1, 0, 0, 0, 0, 0, 60.0], ... [2, 4, 0, 0, 1, 0, 0, 0, 0, 48.0], ... [1, 1, 0, 0, 0, -1, 0, 1, 0, 10.0], ... [1, 0, 0, 0, 0, 0, -1, 0, 1, 2.0] ... ]), 2, 2).run_simplex().items()} # doctest: +ELLIPSIS {'P': 132.0, 'x1': 12.000... 'x2': 5.999...}","range, self.find_pivot, self.interpret_tableau, self.change_stage, self.pivot"
"C:/Users/Joseph Dania/Desktop/python_repo\linear_programming\simplex.py","","interpret_tableau","Given the final tableau, add the corresponding values of the basic decision variables to the `output_dict` >>> {key: float(value) for key, value in Tableau(np.array([ ... [0,0,0.875,0.375,5], ... [0,1,0.375,-0.125,1], ... [1,0,-0.125,0.375,1] ... ]),2, 0).interpret_tableau().items()} {'P': 5.0, 'x1': 1.0, 'x2': 1.0}","range, abs, np.nonzero, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\apriori_algorithm.py","","load_data","Returns a sample transaction dataset.  >>> load_data() [['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\apriori_algorithm.py","","prune","Prune candidate itemsets that are not frequent. The goal of pruning is to filter out candidate itemsets that are not frequent.  This is done by checking if all the (k-1) subsets of a candidate itemset are present in the frequent itemsets of the previous iteration (valid subsequences of the frequent itemsets from the previous iteration).  Prunes candidate itemsets that are not frequent.  >>> itemset = ['X', 'Y', 'Z'] >>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']] >>> prune(itemset, candidates, 2) [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]  >>> itemset = ['1', '2', '3', '4'] >>> candidates = ['1', '2', '4'] >>> prune(itemset, candidates, 3) []","Counter, tuple, tuple, pruned.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\apriori_algorithm.py","","apriori","Returns a list of frequent itemsets and their support counts.  >>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']] >>> apriori(data, 2) [(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]  >>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']] >>> apriori(data, 3) []","list, enumerate, prune, len, enumerate, frequent_itemsets.append, list, all, enumerate, combinations, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","Cell","","Class cell represents a cell in the world which have the properties: position: represented by tuple of x and y coordinates initially set to (0,0). parent: Contains the parent cell object visited before we arrived at this cell. g, h, f: Parameters used when calling our heuristic function.",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","Gridworld","","Gridworld class represents the  external world here a grid M*M matrix. world_size: create a numpy array with the given world_size default is 5.",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","astar","Implementation of a start algorithm. world : Object of the world object. start : Object of the cell as  start position. stop  : Object of the cell as goal position.  >>> p = Gridworld() >>> start = Cell() >>> start.position = (0,0) >>> goal = Cell() >>> goal.position = (4,4) >>> astar(p, start, goal) [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]","_open.append, path.append, np.argmin, _closed.append, world.get_neighbours, path.append, _open.pop, _open.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","__eq__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","showcell","","print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","__init__","","np.zeros"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","show","","print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\astar.py","","get_neighbours","Return the neighbours of cell","Cell, neighbours.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","OpType","","Class represents list of supported operations on Variable for gradient calculation.",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","Variable","","Class represents n-dimensional object which is used to wrap numpy array on which operations will be performed and the gradient will be calculated.  Examples: >>> Variable(5.0) Variable(5.0) >>> Variable([5.0, 2.9]) Variable([5.  2.9]) >>> Variable([5.0, 2.9]) + Variable([1.0, 5.5]) Variable([6.  8.4]) >>> Variable([[8.0, 10.0]]) Variable([[ 8. 10.]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","Operation","","Class represents operation between single or two Variable objects. Operation objects contains type of operation, pointers to input Variable objects and pointer to resulting Variable from the operation.",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","GradientTracker","","Class contains methods to compute partial derivatives of Variable based on the computation graph.  Examples:  >>> with GradientTracker() as tracker: ...     a = Variable([2.0, 5.0]) ...     b = Variable([1.0, 2.0]) ...     m = Variable([1.0, 2.0]) ...     c = a + b ...     d = a * b ...     e = c / d >>> tracker.gradient(e, a) array([-0.25, -0.04]) >>> tracker.gradient(e, b) array([-1.  , -0.25]) >>> tracker.gradient(e, m) is None True  >>> with GradientTracker() as tracker: ...     a = Variable([[2.0, 5.0]]) ...     b = Variable([[1.0], [2.0]]) ...     c = a @ b >>> tracker.gradient(c, a) array([[1., 2.]]) >>> tracker.gradient(c, b) array([[2.],        [5.]])  >>> with GradientTracker() as tracker: ...     a = Variable([[2.0, 5.0]]) ...     b = a ** 3 >>> tracker.gradient(b, a) array([[12., 75.]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__init__","","np.array, Operation"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","to_ndarray","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__add__","","Variable, GradientTracker, tracker.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__sub__","","Variable, GradientTracker, tracker.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__mul__","","Variable, GradientTracker, tracker.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__truediv__","","Variable, GradientTracker, tracker.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__matmul__","","Variable, GradientTracker, tracker.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__pow__","","Variable, GradientTracker, tracker.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","add_param_to","","self.param_to.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","add_result_of","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","add_params","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","add_output","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__eq__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__new__","Executes at the creation of class object and returns if object is already created. This class follows singleton design pattern.",".__new__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__enter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","__exit__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","append","Adds Operation object to the related Variable objects for creating computational graph for calculating gradients.  Args:     op_type: Operation type     params: Input parameters to the operation     output: Output variable of the operation","Operation, output.add_result_of, operation.add_params, operation.add_output, param.add_param_to, param_nodes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","gradient","Reverse accumulation of partial derivatives to calculate gradients of target variable with respect to source variable.  Args:     target: target variable for which gradients are calculated.     source: source variable with respect to which the gradients are     calculated.  Returns:     Gradient of the source variable with respect to the target variable","defaultdict, np.ones_like, partial_deriv.get, target.to_ndarray, len, operation_queue.pop, self.derivative, operation_queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\automatic_differentiation.py","","derivative","Compute the derivative of given operation/function  Args:     param: variable to be differentiated     operation: function performed on the input variable  Returns:     Derivative of input variable with respect to the output of     the operation","ValueError, np.ones_like, .to_ndarray, np.ones_like, np.ones_like, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray, .to_ndarray"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\data_transformations.py","","normalization","Return a normalized list of values.  @params: data, a list of values to normalize @returns: a list of normalized values (rounded to ndigits decimal places) @examples: >>> normalization([2, 7, 10, 20, 30, 50]) [0.0, 0.104, 0.167, 0.375, 0.583, 1.0] >>> normalization([5, 10, 15, 20, 25]) [0.0, 0.25, 0.5, 0.75, 1.0]","min, max, round"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\data_transformations.py","","standardization","Return a standardized list of values.  @params: data, a list of values to standardize @returns: a list of standardized values (rounded to ndigits decimal places) @examples: >>> standardization([2, 7, 10, 20, 30, 50]) [-0.999, -0.719, -0.551, 0.009, 0.57, 1.69] >>> standardization([5, 10, 15, 20, 25]) [-1.265, -0.632, 0.0, 0.632, 1.265]","mean, stdev, round"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","DecisionTree","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","TestDecisionTree","","Decision Tres test class",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","","main","In this demonstration we're generating a sample data set from the sin function in numpy.  We then train a decision tree on the data set and use the decision tree to predict the label of 10 different test values. Then the mean squared error over this test is displayed.","np.arange, np.sin, DecisionTree, tree.train, np.random.default_rng, np.array, np.mean, print, print, print, rng.random, tree.predict, str, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","","mean_squared_error","mean_squared_error: @param labels: a one-dimensional numpy array @param prediction: a floating point value return value: mean_squared_error calculates the error if prediction is used to     estimate the labels >>> tester = DecisionTree() >>> test_labels = np.array([1,2,3,4,5,6,7,8,9,10]) >>> test_prediction = float(6) >>> bool(tester.mean_squared_error(test_labels, test_prediction) == ( ...     TestDecisionTree.helper_mean_squared_error_test(test_labels, ...         test_prediction))) True >>> test_labels = np.array([1,2,3]) >>> test_prediction = float(2) >>> bool(tester.mean_squared_error(test_labels, test_prediction) == ( ...     TestDecisionTree.helper_mean_squared_error_test(test_labels, ...         test_prediction))) True","np.mean, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","","train","train: @param x: a one-dimensional numpy array @param y: a one-dimensional numpy array. The contents of y are the labels for the corresponding X values  train() does not have a return value  Examples: 1. Try to train when x & y are of same length & 1 dimensions (No errors) >>> dt = DecisionTree() >>> dt.train(np.array([10,20,30,40,50]),np.array([0,0,0,1,1]))  2. Try to train when x is 2 dimensions >>> dt = DecisionTree() >>> dt.train(np.array([[1,2,3,4,5],[1,2,3,4,5]]),np.array([0,0,0,1,1])) Traceback (most recent call last):     ... ValueError: Input data set must be one-dimensional  3. Try to train when x and y are not of the same length >>> dt = DecisionTree() >>> dt.train(np.array([1,2,3,4,5]),np.array([[0,0,0,1,1],[0,0,0,1,1]])) Traceback (most recent call last):     ... ValueError: x and y have different lengths  4. Try to train when x & y are of the same length but different dimensions >>> dt = DecisionTree() >>> dt.train(np.array([1,2,3,4,5]),np.array([[1],[2],[3],[4],[5]])) Traceback (most recent call last):     ... ValueError: Data set labels must be one-dimensional  This section is to check that the inputs conform to our dimensionality constraints","range, ValueError, len, len, ValueError, ValueError, len, np.mean, np.mean, self.mean_squared_error, len, DecisionTree, DecisionTree, self.left.train, self.right.train, np.mean, np.mean, len, len, self.mean_squared_error, self.mean_squared_error, np.mean, np.mean"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","","predict","predict: @param x: a floating point value to predict the label of the prediction function works by recursively calling the predict function of the appropriate subtrees based on the tree's decision boundary","ValueError, self.right.predict, self.left.predict"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\decision_tree.py","","helper_mean_squared_error_test","helper_mean_squared_error_test: @param labels: a one dimensional numpy array @param prediction: a floating point value return value: helper_mean_squared_error_test calculates the mean squared error","float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","column_reshape","Function to reshape a row Numpy array into a column Numpy array >>> input_array = np.array([1, 2, 3]) >>> column_reshape(input_array) array([[1],        [2],        [3]])","input_array.reshape"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","covariance_within_classes","Function to compute the covariance matrix inside each class. >>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> labels = np.array([0, 1, 0]) >>> covariance_within_classes(features, labels, 2) array([[0.66666667, 0.66666667, 0.66666667],        [0.66666667, 0.66666667, 0.66666667],        [0.66666667, 0.66666667, 0.66666667]])","range, data.mean, column_reshape, np.dot, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","covariance_between_classes","Function to compute the covariance matrix between multiple classes >>> features = np.array([[9, 2, 3], [4, 3, 6], [1, 8, 9]]) >>> labels = np.array([0, 1, 0]) >>> covariance_between_classes(features, labels, 2) array([[ 3.55555556,  1.77777778, -2.66666667],        [ 1.77777778,  0.88888889, -1.33333333],        [-2.66666667, -1.33333333,  2.        ]])","features.mean, range, data.mean, np.dot, np.dot, column_reshape, column_reshape, column_reshape, column_reshape, column_reshape, column_reshape, column_reshape, column_reshape"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","principal_component_analysis","Principal Component Analysis.  For more details, see: https://en.wikipedia.org/wiki/Principal_component_analysis. Parameters:     * features: the features extracted from the dataset     * dimensions: to filter the projected data for the desired dimension  >>> test_principal_component_analysis()","features.any, features.mean, np.linalg.eigh, np.dot, logging.info, logging.basicConfig, logging.error, np.reshape, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","linear_discriminant_analysis","Linear Discriminant Analysis.  For more details, see: https://en.wikipedia.org/wiki/Linear_discriminant_analysis. Parameters:     * features: the features extracted from the dataset     * labels: the class labels of the features     * classes: the number of classes present in the dataset     * dimensions: to filter the projected data for the desired dimension  >>> test_linear_discriminant_analysis()","eigh, np.linalg.svd, np.dot, logging.info, logging.basicConfig, logging.error, covariance_between_classes, covariance_within_classes"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","test_linear_discriminant_analysis","","np.array, np.array, pytest.raises, linear_discriminant_analysis, isinstance, AssertionError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\dimensionality_reduction.py","","test_principal_component_analysis","","np.array, np.array, pytest.raises, principal_component_analysis, np.allclose"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","TreeNode","","A node in a Frequent Pattern tree.  Args:     name: The name of this node.     num_occur: The number of occurrences of the node.     parent_node: The parent node.  Example: >>> parent = TreeNode(""Parent"", 1, None) >>> child = TreeNode(""Child"", 2, parent) >>> child.name 'Child' >>> child.count 2",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","create_tree","Create Frequent Pattern tree  Args:     data_set: A list of transactions, where each transaction is a list of items.     min_sup: The minimum support threshold.     Items with support less than this will be pruned. Default is 1.  Returns:     The root of the FP-Tree.     header_table: The header table dictionary with item information.  Example: >>> data_set = [ ...    ['A', 'B', 'C'], ...    ['A', 'C'], ...    ['A', 'B', 'E'], ...    ['A', 'B', 'C', 'E'], ...    ['B', 'E'] ... ] >>> min_sup = 2 >>> fp_tree, header_table = create_tree(data_set, min_sup) >>> fp_tree TreeNode('Null Set', 1, None) >>> len(header_table) 4 >>> header_table[""A""] [[4, None], TreeNode('A', 4, TreeNode('Null Set', 1, None))] >>> header_table[""E""][1]  # doctest: +NORMALIZE_WHITESPACE TreeNode('E', 1, TreeNode('B', 3, TreeNode('A', 4, TreeNode('Null Set', 1, None)))) >>> sorted(header_table) ['A', 'B', 'C', 'E'] >>> fp_tree.name 'Null Set' >>> sorted(fp_tree.children) ['A', 'B'] >>> fp_tree.children['A'].name 'A' >>> sorted(fp_tree.children['A'].children) ['B', 'C']","list, header_table.items, TreeNode, header_table.get, set, TreeNode, sorted, update_tree, local_d.items"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","update_tree","Update the FP-Tree with a transaction.  Args:     items: List of items in the transaction.     in_tree: The current node in the FP-Tree.     header_table: The header table dictionary with item information.     count: The count of the transaction.  Example: >>> data_set = [ ...    ['A', 'B', 'C'], ...    ['A', 'C'], ...    ['A', 'B', 'E'], ...    ['A', 'B', 'C', 'E'], ...    ['B', 'E'] ... ] >>> min_sup = 2 >>> fp_tree, header_table = create_tree(data_set, min_sup) >>> fp_tree TreeNode('Null Set', 1, None) >>> transaction = ['A', 'B', 'E'] >>> update_tree(transaction, fp_tree, header_table, 1) >>> fp_tree TreeNode('Null Set', 1, None) >>> fp_tree.children['A'].children['B'].children['E'].children {} >>> fp_tree.children['A'].children['B'].children['E'].count 2 >>> header_table['E'][1].name 'E'",".inc, TreeNode, len, update_tree, update_header"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","update_header","Update the header table with a node link.  Args:     node_to_test: The node to be updated in the header table.     target_node: The node to link to.  Example: >>> data_set = [ ...    ['A', 'B', 'C'], ...    ['A', 'C'], ...    ['A', 'B', 'E'], ...    ['A', 'B', 'C', 'E'], ...    ['B', 'E'] ... ] >>> min_sup = 2 >>> fp_tree, header_table = create_tree(data_set, min_sup) >>> fp_tree TreeNode('Null Set', 1, None) >>> node1 = TreeNode(""A"", 3, None) >>> node2 = TreeNode(""B"", 4, None) >>> node1 TreeNode('A', 3, None) >>> node1 = update_header(node1, node2) >>> node1 TreeNode('A', 3, None) >>> node1.node_link TreeNode('B', 4, None) >>> node2.node_link is None True",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","ascend_tree","Ascend the FP-Tree from a leaf node to its root, adding item names to the prefix path.  Args:     leaf_node: The leaf node to start ascending from.     prefix_path: A list to store the item as they are ascended.  Example: >>> data_set = [ ...    ['A', 'B', 'C'], ...    ['A', 'C'], ...    ['A', 'B', 'E'], ...    ['A', 'B', 'C', 'E'], ...    ['B', 'E'] ... ] >>> min_sup = 2 >>> fp_tree, header_table = create_tree(data_set, min_sup)  >>> path = [] >>> ascend_tree(fp_tree.children['A'], path) >>> path # ascending from a leaf node 'A' ['A']","prefix_path.append, ascend_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","find_prefix_path","Find the conditional pattern base for a given base pattern.  Args:     base_pat: The base pattern for which to find the conditional pattern base.     tree_node: The node in the FP-Tree.  Example: >>> data_set = [ ...    ['A', 'B', 'C'], ...    ['A', 'C'], ...    ['A', 'B', 'E'], ...    ['A', 'B', 'C', 'E'], ...    ['B', 'E'] ... ] >>> min_sup = 2 >>> fp_tree, header_table = create_tree(data_set, min_sup) >>> fp_tree TreeNode('Null Set', 1, None) >>> len(header_table) 4 >>> base_pattern = frozenset(['A']) >>> sorted(find_prefix_path(base_pattern, fp_tree.children['A'])) []","ascend_tree, len, frozenset"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","mine_tree","Mine the FP-Tree recursively to discover frequent itemsets.  Args:     in_tree: The FP-Tree to mine.     header_table: The header table dictionary with item information.     min_sup: The minimum support threshold.     pre_fix: A set of items as a prefix for the itemsets being mined.     freq_item_list: A list to store the frequent itemsets.  Example: >>> data_set = [ ...    ['A', 'B', 'C'], ...    ['A', 'C'], ...    ['A', 'B', 'E'], ...    ['A', 'B', 'C', 'E'], ...    ['B', 'E'] ... ] >>> min_sup = 2 >>> fp_tree, header_table = create_tree(data_set, min_sup) >>> fp_tree TreeNode('Null Set', 1, None) >>> frequent_itemsets = [] >>> mine_tree(fp_tree, header_table, min_sup, set([]), frequent_itemsets) >>> expe_itm = [{'C'}, {'C', 'A'}, {'E'}, {'A', 'E'}, {'E', 'B'}, {'A'}, {'B'}] >>> all(expected in frequent_itemsets for expected in expe_itm) True","sorted, header_table.items, pre_fix.copy, new_freq_set.add, freq_item_list.append, find_prefix_path, create_tree, list, update_header, mine_tree"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","inc","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\frequent_pattern_growth.py","","disp","","print, self.children.values, child.disp"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_boosting_classifier.py","GradientBoostingClassifier","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_boosting_classifier.py","","__init__","Initialize a GradientBoostingClassifier.  Parameters: - n_estimators (int): The number of weak learners to train. - learning_rate (float): The learning rate for updating the model.  Attributes: - n_estimators (int): The number of weak learners. - learning_rate (float): The learning rate. - models (list): A list to store the trained weak learners.",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_boosting_classifier.py","","fit","Fit the GradientBoostingClassifier to the training data.  Parameters: - features (np.ndarray): The training features. - target (np.ndarray): The target values.  Returns: None  >>> import numpy as np >>> from sklearn.datasets import load_iris >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1) >>> iris = load_iris() >>> X, y = iris.data, iris.target >>> clf.fit(X, y) >>> # Check if the model is trained >>> len(clf.models) == 100 True","range, DecisionTreeRegressor, model.fit, self.models.append, self.gradient, self.predict"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_boosting_classifier.py","","predict","Make predictions on input data.  Parameters: - features (np.ndarray): The input data for making predictions.  Returns: - np.ndarray: An array of binary predictions (-1 or 1).  >>> import numpy as np >>> from sklearn.datasets import load_iris >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1) >>> iris = load_iris() >>> X, y = iris.data, iris.target >>> clf.fit(X, y) >>> y_pred = clf.predict(X) >>> # Check if the predictions have the correct shape >>> y_pred.shape == y.shape True","np.zeros, np.sign, model.predict"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_boosting_classifier.py","","gradient","Calculate the negative gradient (pseudo-residuals) for logistic loss.  Parameters: - target (np.ndarray): The target values. - y_pred (np.ndarray): The predicted values.  Returns: - np.ndarray: An array of pseudo-residuals.  >>> import numpy as np >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1) >>> target = np.array([0, 1, 0, 1]) >>> y_pred = np.array([0.2, 0.8, 0.3, 0.7]) >>> residuals = clf.gradient(target, y_pred) >>> # Check if residuals have the correct shape >>> residuals.shape == target.shape True","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","_error",":param data_set: train data or test data :param example_no: example number whose error has to be checked :return: error in example pointed by example number.","calculate_hypothesis_value, output"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","_hypothesis_value","Calculates hypothesis function value for a given input :param data_input_tuple: Input tuple of a particular example :return: Value of hypothesis function at that point. Note that there is an 'biased input' whose value is fixed as 1. It is not explicitly mentioned in input data.. But, ML hypothesis functions use it. So, we have to take care of it separately. Line 36 takes care of it.","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","output",":param data_set: test data or train data :param example_no: example whose output is to be fetched :return: output for that example",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","calculate_hypothesis_value","Calculates hypothesis value for a given example :param data_set: test data or train_data :param example_no: example whose hypothesis value is to be calculated :return: hypothesis value for that example","_hypothesis_value, _hypothesis_value"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","summation_of_cost_derivative","Calculates the sum of cost function derivative :param index: index wrt derivative is being calculated :param end: value where summation ends, default is m, number of examples :return: Returns the summation of cost derivative Note: If index is -1, this means we are calculating summation wrt to biased     parameter.","range, _error, _error"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","get_cost_derivative",":param index: index of the parameter vector wrt to derivative is to be calculated :return: derivative wrt to that index Note: If index is -1, this means we are calculating summation wrt to biased     parameter.","summation_of_cost_derivative"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","run_gradient_descent","","print, range, np.allclose, len, get_cost_derivative"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\gradient_descent.py","","test_gradient_descent","","range, len, print, print, output, calculate_hypothesis_value"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","get_initial_centroids","Randomly choose k data points as initial centroids","np.random.default_rng, rng.integers"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","centroid_pairwise_dist","","pairwise_distances"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","assign_clusters","","centroid_pairwise_dist, np.argmin"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","revise_centroids","","range, np.array, member_data_points.mean, new_centroids.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","compute_heterogeneity","","range, pairwise_distances, np.sum"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","plot_heterogeneity","","plt.figure, plt.plot, plt.xlabel, plt.ylabel, plt.title, plt.rcParams.update, plt.show"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","plot_kmeans","","plt.axes, ax.scatter, ax.scatter, ax.set_xlabel, ax.set_ylabel, ax.set_zlabel, ax.set_title, plt.show"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","kmeans","Runs k-means on given data and initial set of centroids. maxiter: maximum number of iterations to run.(default=500) record_heterogeneity: (optional) a list, to store the history of heterogeneity                       as function of iterations                       if None, do not store the history. verbose: if True, print how many data points changed their cluster labels in                       each iteration","range, assign_clusters, revise_centroids, print, .all, np.sum, compute_heterogeneity, record_heterogeneity.append, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_means_clust.py","","report_generator","Generate a clustering report given these two arguments:     predicted - dataframe with predicted cluster column     fill_missing_report - dictionary of rules on how we are going to fill in missing     values for final generated report (not included in modelling); >>> predicted = pd.DataFrame() >>> predicted['numbers'] = [1, 2, 3] >>> predicted['col1'] = [0.5, 2.5, 4.5] >>> predicted['col2'] = [100, 200, 300] >>> predicted['col3'] = [10, 20, 30] >>> predicted['Cluster'] = [1, 1, 2] >>> report_generator(predicted, ['col1', 'col2'], 0)            Features               Type   Mark           1           2 0    # of Customers        ClusterSize  False    2.000000    1.000000 1    % of Customers  ClusterProportion  False    0.666667    0.333333 2              col1    mean_with_zeros   True    1.500000    4.500000 3              col2    mean_with_zeros   True  150.000000  300.000000 4           numbers    mean_with_zeros  False    1.500000    3.000000 ..              ...                ...    ...         ...         ... 99            dummy                 5%  False    1.000000    1.000000 100           dummy                95%  False    1.000000    1.000000 101           dummy              stdev  False    0.000000         NaN 102           dummy               mode  False    1.000000    1.000000 103           dummy             median  False    1.000000    1.000000 <BLANKLINE> [104 rows x 5 columns]",".rename, .copy, pd.DataFrame, clusterproportion.columns.tolist, pd.DataFrame, .Features.tolist, a.columns.tolist, report.drop, pd.concat, .isin, report.columns.tolist, .drop, report.reset_index, report.drop, predicted.fillna, predicted.select_dtypes, abs, .T.reset_index, .to_numpy, .sum, .sort_values, .to_numpy, .to_numpy, .to_numpy, report.assign, .agg, x.Type.map, list, predicted.groupby, reversed, np.mean, .mean, np.mean, x.min, x.quantile, x.quantile, x.quantile, x.quantile, x.quantile, x.max, x.count, x.std, x.median, .sum, range, np.nan_to_num, np.nan_to_num, x.mode, len, x.replace, sorted, round, round, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_nearest_neighbours.py","KNN","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_nearest_neighbours.py","","__init__","Create a kNN classifier using the given training data and class labels","zip"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_nearest_neighbours.py","","_euclidean_distance","Calculate the Euclidean distance between two points >>> KNN._euclidean_distance(np.array([0, 0]), np.array([3, 4])) 5.0 >>> KNN._euclidean_distance(np.array([1, 2, 3]), np.array([1, 8, 11])) 10.0","float, np.linalg.norm"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\k_nearest_neighbours.py","","classify","Classify a given point using the kNN algorithm >>> train_X = np.array( ...     [[0, 0], [1, 0], [0, 1], [0.5, 0.5], [3, 3], [2, 3], [3, 2]] ... ) >>> train_y = np.array([0, 0, 0, 0, 1, 1, 1]) >>> classes = ['A', 'B'] >>> knn = KNN(train_X, train_y, classes) >>> point = np.array([1.2, 1.2]) >>> knn.classify(point) 'A'","self._euclidean_distance, nsmallest, .most_common, Counter"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","gaussian_distribution","Generate gaussian distribution instances based-on given mean and standard deviation :param mean: mean value of class :param std_dev: value of standard deviation entered by usr or default value of it :param instance_count: instance number of class :return: a list containing generated values based-on given mean, std_dev and     instance_count  >>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE [6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,  3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,   5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,    5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,     5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]","seed, gauss, range"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","y_generator","Generate y values for corresponding classes :param class_count: Number of classes(data groupings) in dataset :param instance_count: number of instances in class :return: corresponding values for data groupings in dataset  >>> y_generator(1, [10]) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> y_generator(2, [5, 10]) [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","calculate_mean","Calculate given class mean :param instance_count: Number of instances in class :param items: items that related to specific class(data grouping) :return: calculated actual mean of considered class  >>> items = gaussian_distribution(5.0, 1.0, 20) >>> calculate_mean(len(items), items) 5.011267842911003","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","calculate_probabilities","Calculate the probability that a given instance will belong to which class :param instance_count: number of instances in class :param total_count: the number of all instances :return: value of probability for considered class  >>> calculate_probabilities(20, 60) 0.3333333333333333 >>> calculate_probabilities(30, 100) 0.3",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","calculate_variance","Calculate the variance :param items: a list containing all items(gaussian distribution of all classes) :param means: a list containing real mean values of each class :param total_count: the number of all instances :return: calculated variance for considered dataset  >>> items = gaussian_distribution(5.0, 1.0, 20) >>> means = [5.011267842911003] >>> total_count = 20 >>> calculate_variance([items], means, total_count) 0.9618530973487491","range, len, len, range, sum, len, squared_diff.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","predict_y_values","This function predicts new indexes(groups for our data) :param x_items: a list containing all items(gaussian distribution of all classes) :param means: a list containing real mean values of each class :param variance: calculated value of variance by calculate_variance function :param probabilities: a list containing all probabilities of classes :return: a list containing predicted Y values  >>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262, ...                4.235456349028368, 3.9078267848958586, 5.031334516831717, ...                3.977896829989127, 3.56317055489747, 5.199311976483754, ...                5.133374604658605, 5.546468300338232, 4.086029056264687, ...                5.005005283626573, 4.935258239627312, 3.494170998739258, ...                5.537997178661033, 5.320711100998849, 7.3891120432406865, ...                5.202969177309964, 4.855297691835079], [11.288184753155463, ...                11.44944560869977, 10.066335808938263, 9.235456349028368, ...                8.907826784895859, 10.031334516831716, 8.977896829989128, ...                8.56317055489747, 10.199311976483754, 10.133374604658606, ...                10.546468300338232, 9.086029056264687, 10.005005283626572, ...                9.935258239627313, 8.494170998739259, 10.537997178661033, ...                10.320711100998848, 12.389112043240686, 10.202969177309964, ...                9.85529769183508], [16.288184753155463, 16.449445608699772, ...                15.066335808938263, 14.235456349028368, 13.907826784895859, ...                15.031334516831716, 13.977896829989128, 13.56317055489747, ...                15.199311976483754, 15.133374604658606, 15.546468300338232, ...                14.086029056264687, 15.005005283626572, 14.935258239627313, ...                13.494170998739259, 15.537997178661033, 15.320711100998848, ...                17.389112043240686, 15.202969177309964, 14.85529769183508]]  >>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002] >>> variance = 0.9618530973487494 >>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333] >>> predict_y_values(x_items, means, variance, ...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]","range, len, range, result.index, len, range, results.append, max, len, temp.append, log"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","accuracy","Calculate the value of accuracy based-on predictions :param actual_y:a list containing initial Y values generated by 'y_generator'     function :param predicted_y: a list containing predicted Y values generated by     'predict_y_values' function :return: percentage of accuracy  >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, ... 1, 1 ,1 ,1 ,1 ,1 ,1] >>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, ... 0, 0, 1, 1, 1, 0, 1, 1, 1] >>> accuracy(actual_y, predicted_y) 50.0  >>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, ... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] >>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, ... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2] >>> accuracy(actual_y, predicted_y) 100.0","sum, len, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","valid_input","Ask for user value and validate that it fulfill a condition.  :input_type: user input expected type of value :input_msg: message to show user in the screen :err_msg: message to show in the screen in case of error :condition: function that represents the condition that user input is valid. :default: Default value in case the user does not type anything :return: user's input","input_type, condition, print, print, .strip, input"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_discriminant_analysis.py","","main","This function starts execution phase","print, print, print, print, valid_input, print, valid_input, print, range, print, range, print, print, enumerate, print, enumerate, print, print, print, y_generator, print, print, enumerate, print, enumerate, print, calculate_variance, print, print, predict_y_values, print, print, print, print, system, .center, valid_input, counts.append, valid_input, user_means.append, print, print, gaussian_distribution, calculate_mean, print, calculate_probabilities, print, sum, .center, .lower, print, range, range, sum, range, accuracy, .strip, .center, input"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_regression.py","","collect_dataset","Collect dataset of CSGO The dataset contains ADR vs Rating of a Player :return : dataset obtained from the link, as matrix","httpx.get, response.text.splitlines, data.pop, np.matrix, item.split, data.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_regression.py","","run_steep_gradient_descent","Run steep gradient descent and updates the Feature vector accordingly_ :param data_x   : contains the dataset :param data_y   : contains the output associated with each data-entry :param len_data : length of the data_ :param alpha    : Learning rate of the model :param theta    : Feature vector (weight's for our model) ;param return    : Updated Feature's, using                    curr_features - alpha_ * gradient(w.r.t. feature) >>> import numpy as np >>> data_x = np.array([[1, 2], [3, 4]]) >>> data_y = np.array([5, 6]) >>> len_data = len(data_x) >>> alpha = 0.01 >>> theta = np.array([0.1, 0.2]) >>> run_steep_gradient_descent(data_x, data_y, len_data, alpha, theta) array([0.196, 0.343])","np.dot, data_y.transpose, np.dot, data_x.transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_regression.py","","sum_of_square_error","Return sum of square error for error calculation :param data_x    : contains our dataset :param data_y    : contains the output (result vector) :param len_data  : len of the dataset :param theta     : contains the feature vector :return          : sum of square error computed from given feature's  Example: >>> vc_x = np.array([[1.1], [2.1], [3.1]]) >>> vc_y = np.array([1.2, 2.2, 3.2]) >>> round(sum_of_square_error(vc_x, vc_y, 3, np.array([1])),3) np.float64(0.005)","np.dot, data_y.transpose, np.sum, data_x.transpose, np.square"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_regression.py","","run_linear_regression","Implement Linear regression over the dataset :param data_x  : contains our dataset :param data_y  : contains the output (result vector) :return        : feature for line of best fit (Feature vector)","np.zeros, range, run_steep_gradient_descent, sum_of_square_error, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_regression.py","","mean_absolute_error","Return sum of square error for error calculation :param predicted_y   : contains the output of prediction (result vector) :param original_y    : contains values of expected outcome :return          : mean absolute error computed from given feature's  >>> predicted_y = [3, -0.5, 2, 7] >>> original_y = [2.5, 0.0, 2, 8] >>> mean_absolute_error(predicted_y, original_y) 0.5","sum, len, abs, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\linear_regression.py","","main","Driver function","collect_dataset, .astype, .astype, run_linear_regression, print, range, print, np.ones"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\logistic_regression.py","","sigmoid_function","Also known as Logistic Function.              1 f(x) =   -------           1 + e  The sigmoid function approaches a value of 1 as its input 'x' becomes increasing positive. Opposite for negative values.  Reference: https://en.wikipedia.org/wiki/Sigmoid_function  @param z:  input to the function @returns: returns value in the range 0 to 1  Examples: >>> float(sigmoid_function(4)) 0.9820137900379085 >>> sigmoid_function(np.array([-3, 3])) array([0.04742587, 0.95257413]) >>> sigmoid_function(np.array([-3, 3, 1])) array([0.04742587, 0.95257413, 0.73105858]) >>> sigmoid_function(np.array([-0.01, -2, -1.9])) array([0.49750002, 0.11920292, 0.13010847]) >>> sigmoid_function(np.array([-1.3, 5.3, 12])) array([0.21416502, 0.9950332 , 0.99999386]) >>> sigmoid_function(np.array([0.01, 0.02, 4.1])) array([0.50249998, 0.50499983, 0.9836975 ]) >>> sigmoid_function(np.array([0.8])) array([0.68997448])","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\logistic_regression.py","","cost_function","Cost function quantifies the error between predicted and expected values. The cost function used in Logistic Regression is called Log Loss or Cross Entropy Function.  J() = (1/m) *  [ -y * log(h(x)) - (1 - y) * log(1 - h(x)) ]  Where:    - J() is the cost that we want to minimize during training    - m is the number of training examples    -  represents the summation over all training examples    - y is the actual binary label (0 or 1) for a given example    - h(x) is the predicted probability that x belongs to the positive class  @param h: the output of sigmoid function. It is the estimated probability that the input example 'x' belongs to the positive class  @param y: the actual binary label associated with input example 'x'  Examples: >>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1])) >>> cost_function(h=estimations,y=np.array([1, 0, 1])) 0.18937868932131605 >>> estimations = sigmoid_function(np.array([4, 3, 1])) >>> cost_function(h=estimations,y=np.array([1, 0, 0])) 1.459999655669926 >>> estimations = sigmoid_function(np.array([4, -3, -1])) >>> cost_function(h=estimations,y=np.array([1,0,0])) 0.1266663223365915 >>> estimations = sigmoid_function(0) >>> cost_function(h=estimations,y=np.array([1])) 0.6931471805599453  References:    - https://en.wikipedia.org/wiki/Logistic_regression","float, .mean, np.log, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\logistic_regression.py","","log_likelihood","","np.dot, np.sum, np.log, np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\logistic_regression.py","","logistic_reg","","np.zeros, range, np.dot, sigmoid_function, np.dot, sigmoid_function, cost_function, np.dot, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\logistic_regression.py","","predict_prob","","sigmoid_function, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","binary_cross_entropy","Calculate the mean binary cross-entropy (BCE) loss between true labels and predicted probabilities.  BCE loss quantifies dissimilarity between true labels (0 or 1) and predicted probabilities. It's widely used in binary classification tasks.  BCE = -(y_true * ln(y_pred) + (1 - y_true) * ln(1 - y_pred))  Reference: https://en.wikipedia.org/wiki/Cross_entropy  Parameters: - y_true: True binary labels (0 or 1) - y_pred: Predicted probabilities for class 1 - epsilon: Small constant to avoid numerical instability  >>> true_labels = np.array([0, 1, 1, 0, 1]) >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8]) >>> float(binary_cross_entropy(true_labels, predicted_probs)) 0.2529995012327421 >>> true_labels = np.array([0, 1, 1, 0, 1]) >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2]) >>> binary_cross_entropy(true_labels, predicted_probs) Traceback (most recent call last):     ... ValueError: Input arrays must have the same length.","np.clip, np.mean, len, len, ValueError, np.log, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","binary_focal_cross_entropy","Calculate the mean binary focal cross-entropy (BFCE) loss between true labels and predicted probabilities.  BFCE loss quantifies dissimilarity between true labels (0 or 1) and predicted probabilities. It's a variation of binary cross-entropy that addresses class imbalance by focusing on hard examples.  BCFE = -(alpha * (1 - y_pred)**gamma * y_true * log(y_pred)             + (1 - alpha) * y_pred**gamma * (1 - y_true) * log(1 - y_pred))  Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)  Parameters: - y_true: True binary labels (0 or 1). - y_pred: Predicted probabilities for class 1. - gamma: Focusing parameter for modulating the loss (default: 2.0). - alpha: Weighting factor for class 1 (default: 0.25). - epsilon: Small constant to avoid numerical instability.  >>> true_labels = np.array([0, 1, 1, 0, 1]) >>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8]) >>> float(binary_focal_cross_entropy(true_labels, predicted_probs)) 0.008257977659239775 >>> true_labels = np.array([0, 1, 1, 0, 1]) >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2]) >>> binary_focal_cross_entropy(true_labels, predicted_probs) Traceback (most recent call last):     ... ValueError: Input arrays must have the same length.","np.clip, np.mean, len, len, ValueError, np.log, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","categorical_cross_entropy","Calculate categorical cross-entropy (CCE) loss between true class labels and predicted class probabilities.  CCE = -(y_true * ln(y_pred))  Reference: https://en.wikipedia.org/wiki/Cross_entropy  Parameters: - y_true: True class labels (one-hot encoded) - y_pred: Predicted class probabilities - epsilon: Small constant to avoid numerical instability  >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]]) >>> float(categorical_cross_entropy(true_labels, pred_probs)) 0.567395975254385 >>> true_labels = np.array([[1, 0], [0, 1]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]]) >>> categorical_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: Input arrays must have the same shape. >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]]) >>> categorical_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: y_true must be one-hot encoded. >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]]) >>> categorical_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: y_true must be one-hot encoded. >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]]) >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]]) >>> categorical_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: Predicted probabilities must sum to approximately 1.","np.clip, ValueError, np.any, np.any, ValueError, np.all, ValueError, np.sum, np.isclose, y_true.sum, np.sum, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","categorical_focal_cross_entropy","Calculate the mean categorical focal cross-entropy (CFCE) loss between true labels and predicted probabilities for multi-class classification.  CFCE loss is a generalization of binary focal cross-entropy for multi-class classification. It addresses class imbalance by focusing on hard examples.  CFCE = - alpha * (1 - y_pred)**gamma * y_true * log(y_pred)  Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)  Parameters: - y_true: True labels in one-hot encoded form. - y_pred: Predicted probabilities for each class. - alpha: Array of weighting factors for each class. - gamma: Focusing parameter for modulating the loss (default: 2.0). - epsilon: Small constant to avoid numerical instability.  Returns: - The mean categorical focal cross-entropy loss.  >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]]) >>> alpha = np.array([0.6, 0.2, 0.7]) >>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha)) 0.0025966118981496423  >>> true_labels = np.array([[0, 1, 0], [0, 0, 1]]) >>> pred_probs = np.array([[0.05, 0.95, 0], [0.1, 0.8, 0.1]]) >>> alpha = np.array([0.25, 0.25, 0.25]) >>> float(categorical_focal_cross_entropy(true_labels, pred_probs, alpha)) 0.23315276982014324  >>> true_labels = np.array([[1, 0], [0, 1]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]]) >>> categorical_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: Input arrays must have the same shape.  >>> true_labels = np.array([[2, 0, 1], [1, 0, 0]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]]) >>> categorical_focal_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: y_true must be one-hot encoded.  >>> true_labels = np.array([[1, 0, 1], [1, 0, 0]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]]) >>> categorical_focal_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: y_true must be one-hot encoded.  >>> true_labels = np.array([[1, 0, 0], [0, 1, 0]]) >>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]]) >>> categorical_focal_cross_entropy(true_labels, pred_probs) Traceback (most recent call last):     ... ValueError: Predicted probabilities must sum to approximately 1.  >>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) >>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]]) >>> alpha = np.array([0.6, 0.2]) >>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha) Traceback (most recent call last):     ... ValueError: Length of alpha must match the number of classes.","np.clip, np.mean, ValueError, np.ones, np.any, np.any, ValueError, len, ValueError, np.all, ValueError, np.sum, np.isclose, y_true.sum, np.sum, np.log, np.power"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","hinge_loss","Calculate the mean hinge loss for between true labels and predicted probabilities for training support vector machines (SVMs).  Hinge loss = max(0, 1 - true * pred)  Reference: https://en.wikipedia.org/wiki/Hinge_loss  Args: - y_true: actual values (ground truth) encoded as -1 or 1 - y_pred: predicted values  >>> true_labels = np.array([-1, 1, 1, -1, 1]) >>> pred = np.array([-4, -0.3, 0.7, 5, 10]) >>> float(hinge_loss(true_labels, pred)) 1.52 >>> true_labels = np.array([-1, 1, 1, -1, 1, 1]) >>> pred = np.array([-4, -0.3, 0.7, 5, 10]) >>> hinge_loss(true_labels, pred) Traceback (most recent call last): ... ValueError: Length of predicted and actual array must be same. >>> true_labels = np.array([-1, 1, 10, -1, 1]) >>> pred = np.array([-4, -0.3, 0.7, 5, 10]) >>> hinge_loss(true_labels, pred) Traceback (most recent call last): ... ValueError: y_true can have values -1 or 1 only.","np.any, np.maximum, np.mean, len, len, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","huber_loss","Calculate the mean Huber loss between the given ground truth and predicted values.  The Huber loss describes the penalty incurred by an estimation procedure, and it serves as a measure of accuracy for regression models.  Huber loss =     0.5 * (y_true - y_pred)^2                   if |y_true - y_pred| <= delta     delta * |y_true - y_pred| - 0.5 * delta^2   otherwise  Reference: https://en.wikipedia.org/wiki/Huber_loss  Parameters: - y_true: The true values (ground truth) - y_pred: The predicted values  >>> true_values = np.array([0.9, 10.0, 2.0, 1.0, 5.2]) >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2]) >>> bool(np.isclose(huber_loss(true_values, predicted_values, 1.0), 2.102)) True >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0, 5.0]) >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0]) >>> bool(np.isclose(huber_loss(true_labels, predicted_probs, 1.0), 1.80164)) True >>> true_labels = np.array([11.0, 21.0, 3.32, 4.0]) >>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0]) >>> huber_loss(true_labels, predicted_probs, 1.0) Traceback (most recent call last): ... ValueError: Input arrays must have the same length.",".mean, len, len, ValueError, np.abs, np.where, np.abs"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","mean_squared_error","Calculate the mean squared error (MSE) between ground truth and predicted values.  MSE measures the squared difference between true values and predicted values, and it serves as a measure of accuracy for regression models.  MSE = (1/n) * (y_true - y_pred)^2  Reference: https://en.wikipedia.org/wiki/Mean_squared_error  Parameters: - y_true: The true values (ground truth) - y_pred: The predicted values  >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2]) >>> bool(np.isclose(mean_squared_error(true_values, predicted_values), 0.028)) True >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2]) >>> mean_squared_error(true_labels, predicted_probs) Traceback (most recent call last): ... ValueError: Input arrays must have the same length.","np.mean, len, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","mean_absolute_error","Calculates the Mean Absolute Error (MAE) between ground truth (observed)     and predicted values.  MAE measures the absolute difference between true values and predicted values.  Equation: MAE = (1/n) * (abs(y_true - y_pred))  Reference: https://en.wikipedia.org/wiki/Mean_absolute_error  Parameters: - y_true: The true values (ground truth) - y_pred: The predicted values  >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2]) >>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 0.16)) True >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2]) >>> bool(np.isclose(mean_absolute_error(true_values, predicted_values), 2.16)) False >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_probs = np.array([0.3, 0.8, 0.9, 5.2]) >>> mean_absolute_error(true_labels, predicted_probs) Traceback (most recent call last): ... ValueError: Input arrays must have the same length.","np.mean, len, len, ValueError, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","mean_squared_logarithmic_error","Calculate the mean squared logarithmic error (MSLE) between ground truth and predicted values.  MSLE measures the squared logarithmic difference between true values and predicted values for regression models. It's particularly useful for dealing with skewed or large-value data, and it's often used when the relative differences between predicted and true values are more important than absolute differences.  MSLE = (1/n) * (log(1 + y_true) - log(1 + y_pred))^2  Reference: https://insideaiml.com/blog/MeanSquared-Logarithmic-Error-Loss-1035  Parameters: - y_true: The true values (ground truth) - y_pred: The predicted values  >>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2]) >>> float(mean_squared_logarithmic_error(true_values, predicted_values)) 0.0030860877925181344 >>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) >>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2]) >>> mean_squared_logarithmic_error(true_labels, predicted_probs) Traceback (most recent call last): ... ValueError: Input arrays must have the same length.","np.mean, len, len, ValueError, np.log1p, np.log1p"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","mean_absolute_percentage_error","Calculate the Mean Absolute Percentage Error between y_true and y_pred.  Mean Absolute Percentage Error calculates the average of the absolute percentage differences between the predicted and true values.  Formula = (|y_true[i]-Y_pred[i]/y_true[i]|)/n  Source: https://stephenallwright.com/good-mape-score/  Parameters: y_true (np.ndarray): Numpy array containing true/target values. y_pred (np.ndarray): Numpy array containing predicted values.  Returns: float: The Mean Absolute Percentage error between y_true and y_pred.  Examples: >>> y_true = np.array([10, 20, 30, 40]) >>> y_pred = np.array([12, 18, 33, 45]) >>> float(mean_absolute_percentage_error(y_true, y_pred)) 0.13125  >>> y_true = np.array([1, 2, 3, 4]) >>> y_pred = np.array([2, 3, 4, 5]) >>> float(mean_absolute_percentage_error(y_true, y_pred)) 0.5208333333333333  >>> y_true = np.array([34, 37, 44, 47, 48, 48, 46, 43, 32, 27, 26, 24]) >>> y_pred = np.array([37, 40, 46, 44, 46, 50, 45, 44, 34, 30, 22, 23]) >>> float(mean_absolute_percentage_error(y_true, y_pred)) 0.064671076436071","np.where, np.abs, np.mean, len, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","perplexity_loss","Calculate the perplexity for the y_true and y_pred.  Compute the Perplexity which useful in predicting language model accuracy in Natural Language Processing (NLP.) Perplexity is measure of how certain the model in its predictions.  Perplexity Loss = exp(-1/N ( ln(p(x)))  Reference: https://en.wikipedia.org/wiki/Perplexity  Args:     y_true: Actual label encoded sentences of shape (batch_size, sentence_length)     y_pred: Predicted sentences of shape (batch_size, sentence_length, vocab_size)     epsilon: Small floating point number to avoid getting inf for log(0)  Returns:     Perplexity loss between y_true and y_pred.  >>> y_true = np.array([[1, 4], [2, 3]]) >>> y_pred = np.array( ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15], ...      [0.24, 0.19, 0.09, 0.18, 0.27]], ...      [[0.03, 0.26, 0.21, 0.18, 0.30], ...       [0.28, 0.10, 0.33, 0.15, 0.12]]] ... ) >>> float(perplexity_loss(y_true, y_pred)) 5.0247347775367945 >>> y_true = np.array([[1, 4], [2, 3]]) >>> y_pred = np.array( ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15], ...      [0.24, 0.19, 0.09, 0.18, 0.27], ...      [0.30, 0.10, 0.20, 0.15, 0.25]], ...      [[0.03, 0.26, 0.21, 0.18, 0.30], ...       [0.28, 0.10, 0.33, 0.15, 0.12], ...       [0.30, 0.10, 0.20, 0.15, 0.25]],] ... ) >>> perplexity_loss(y_true, y_pred) Traceback (most recent call last): ... ValueError: Sentence length of y_true and y_pred must be equal. >>> y_true = np.array([[1, 4], [2, 11]]) >>> y_pred = np.array( ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15], ...      [0.24, 0.19, 0.09, 0.18, 0.27]], ...      [[0.03, 0.26, 0.21, 0.18, 0.30], ...       [0.28, 0.10, 0.33, 0.15, 0.12]]] ... ) >>> perplexity_loss(y_true, y_pred) Traceback (most recent call last): ... ValueError: Label value must not be greater than vocabulary size. >>> y_true = np.array([[1, 4]]) >>> y_pred = np.array( ...    [[[0.28, 0.19, 0.21 , 0.15, 0.15], ...      [0.24, 0.19, 0.09, 0.18, 0.27]], ...      [[0.03, 0.26, 0.21, 0.18, 0.30], ...       [0.28, 0.10, 0.33, 0.15, 0.12]]] ... ) >>> perplexity_loss(y_true, y_pred) Traceback (most recent call last): ... ValueError: Batch size of y_true and y_pred must be equal.","np.array, .clip, np.exp, np.mean, ValueError, ValueError, np.max, ValueError, np.negative, np.sum, np.mean, list, np.log, np.eye"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","smooth_l1_loss","Calculate the Smooth L1 Loss between y_true and y_pred.  The Smooth L1 Loss is less sensitive to outliers than the L2 Loss and is often used in regression problems, such as object detection.  Smooth L1 Loss =     0.5 * (x - y)^2 / beta, if |x - y| < beta     |x - y| - 0.5 * beta, otherwise  Reference: https://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html  Args:     y_true: Array of true values.     y_pred: Array of predicted values.     beta: Specifies the threshold at which to change between L1 and L2 loss.  Returns:     The calculated Smooth L1 Loss between y_true and y_pred.  Raises:     ValueError: If the length of the two arrays is not the same.  >>> y_true = np.array([3, 5, 2, 7]) >>> y_pred = np.array([2.9, 4.8, 2.1, 7.2]) >>> float(smooth_l1_loss(y_true, y_pred, 1.0)) 0.012500000000000022  >>> y_true = np.array([2, 4, 6]) >>> y_pred = np.array([1, 5, 7]) >>> float(smooth_l1_loss(y_true, y_pred, 1.0)) 0.5  >>> y_true = np.array([1, 3, 5, 7]) >>> y_pred = np.array([1, 3, 5, 7]) >>> float(smooth_l1_loss(y_true, y_pred, 1.0)) 0.0  >>> y_true = np.array([1, 3, 5]) >>> y_pred = np.array([1, 3, 5, 7]) >>> smooth_l1_loss(y_true, y_pred, 1.0) Traceback (most recent call last): ... ValueError: The length of the two arrays should be the same.","np.abs, np.where, np.mean, len, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\loss_functions.py","","kullback_leibler_divergence","Calculate the Kullback-Leibler divergence (KL divergence) loss between true labels and predicted probabilities.  KL divergence loss quantifies dissimilarity between true labels and predicted probabilities. It's often used in training generative models.  KL = (y_true * ln(y_true / y_pred))  Reference: https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence  Parameters: - y_true: True class probabilities - y_pred: Predicted class probabilities  >>> true_labels = np.array([0.2, 0.3, 0.5]) >>> predicted_probs = np.array([0.3, 0.3, 0.4]) >>> float(kullback_leibler_divergence(true_labels, predicted_probs)) 0.030478754035472025 >>> true_labels = np.array([0.2, 0.3, 0.5]) >>> predicted_probs = np.array([0.3, 0.3, 0.4, 0.5]) >>> kullback_leibler_divergence(true_labels, predicted_probs) Traceback (most recent call last):     ... ValueError: Input arrays must have the same length.","np.sum, len, len, ValueError, np.log"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","mfcc","Calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio signal.  Args:     audio: The input audio signal.     sample_rate: The sample rate of the audio signal (in Hz).     ftt_size: The size of the FFT window (default is 1024).     hop_length: The hop length for frame creation (default is 20ms).     mel_filter_num: The number of Mel filters (default is 10).     dct_filter_num: The number of DCT filters (default is 40).  Returns:     A matrix of MFCCs for the input audio.  Raises:     ValueError: If the input audio is empty.  Example: >>> sample_rate = 44100  # Sample rate of 44.1 kHz >>> duration = 2.0  # Duration of 1 second >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) >>> audio = 0.5 * np.sin(2 * np.pi * 440.0 * t)  # Generate a 440 Hz sine wave >>> mfccs = mfcc(audio, sample_rate) >>> mfccs.shape (40, 101)","logging.info, logging.info, logging.info, logging.info, normalize, logging.info, logging.info, audio_frames, logging.info, logging.info, get_window, logging.info, logging.info, calculate_fft, logging.info, logging.info, calculate_signal_power, logging.info, logging.info, mel_spaced_filterbank, logging.info, np.dot, logging.info, discrete_cosine_transform, np.dot, logging.info, np.transpose, np.log10, np.min, np.max, np.min, np.max, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","normalize","Normalize an audio signal by scaling it to have values between -1 and 1.  Args:     audio: The input audio signal.  Returns:     The normalized audio signal.  Examples: >>> audio = np.array([1, 2, 3, 4, 5]) >>> normalized_audio = normalize(audio) >>> float(np.max(normalized_audio)) 1.0 >>> float(np.min(normalized_audio)) 0.2","np.max, np.abs"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","audio_frames","Split an audio signal into overlapping frames.  Args:     audio: The input audio signal.     sample_rate: The sample rate of the audio signal.     hop_length: The length of the hopping (default is 20ms).     ftt_size: The size of the FFT window (default is 1024).  Returns:     An array of overlapping frames.  Examples: >>> audio = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000) >>> sample_rate = 8000 >>> frames = audio_frames(audio, sample_rate, hop_length=10, ftt_size=512) >>> frames.shape (126, 512)",".astype, np.pad, np.zeros, range, int, int, np.round, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","calculate_fft","Calculate the Fast Fourier Transform (FFT) of windowed audio data.  Args:     audio_windowed: The windowed audio signal.     ftt_size: The size of the FFT (default is 1024).  Returns:     The FFT of the audio data.  Examples: >>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]) >>> audio_fft = calculate_fft(audio_windowed, ftt_size=4) >>> bool(np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j, ...     -1.5-0.8660254j]))) True","np.transpose, np.empty, range, np.transpose, int, fft.fft"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","calculate_signal_power","Calculate the power of the audio signal from its FFT.  Args:     audio_fft: The FFT of the audio signal.  Returns:     The power of the audio signal.  Examples: >>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j]) >>> power = calculate_signal_power(audio_fft) >>> np.allclose(power, np.array([5, 13, 25, 41])) True","np.square, np.abs"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","freq_to_mel","Convert a frequency in Hertz to the mel scale.  Args:     freq: The frequency in Hertz.  Returns:     The frequency in mel scale.  Examples: >>> float(round(freq_to_mel(1000), 2)) 999.99","np.log10"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","mel_to_freq","Convert a frequency in the mel scale to Hertz.  Args:     mels: The frequency in mel scale.  Returns:     The frequency in Hertz.  Examples: >>> round(mel_to_freq(999.99), 2) 1000.01",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","mel_spaced_filterbank","Create a Mel-spaced filter bank for audio processing.  Args:     sample_rate: The sample rate of the audio.     mel_filter_num: The number of mel filters (default is 10).     ftt_size: The size of the FFT (default is 1024).  Returns:     Mel-spaced filter bank.  Examples: >>> float(round(mel_spaced_filterbank(8000, 10, 1024)[0][1], 10)) 0.0004603981","logging.info, logging.info, get_filter_points, get_filters"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","get_filters","Generate filters for audio processing.  Args:     filter_points: A list of filter points.     ftt_size: The size of the FFT.  Returns:     A matrix of filters.  Examples: >>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape (4, 257)","np.zeros, range, len, np.linspace, np.linspace, int"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","get_filter_points","Calculate the filter points and frequencies for mel frequency filters.  Args:     sample_rate: The sample rate of the audio.     freq_min: The minimum frequency in Hertz.     freq_high: The maximum frequency in Hertz.     mel_filter_num: The number of mel filters (default is 10).     ftt_size: The size of the FFT (default is 1024).  Returns:     Filter points and corresponding frequencies.  Examples: >>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512) >>> filter_points[0] array([  0,  20,  51,  95, 161, 256]) >>> filter_points[1] array([   0.        ,  324.46707094,  799.33254207, 1494.30973963,        2511.42581671, 4000.        ])","freq_to_mel, freq_to_mel, logging.info, logging.info, np.linspace, mel_to_freq, .astype, np.floor"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","discrete_cosine_transform","Compute the Discrete Cosine Transform (DCT) basis matrix.  Args:     dct_filter_num: The number of DCT filters to generate.     filter_num: The number of the fbank filters.  Returns:     The DCT basis matrix.  Examples: >>> float(round(discrete_cosine_transform(3, 5)[0][0], 5)) 0.44721","np.empty, range, np.sqrt, np.arange, np.cos, np.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\mfcc.py","","example","Example function to calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio file.  Args:     wav_file_path: The path to the WAV audio file.  Returns:     np.ndarray: The computed MFCCs for the audio.","wavfile.read, mfcc"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\multilayer_perceptron_classifier.py","","wrapper",">>> [int(x) for x in wrapper(Y)] [0, 0, 1]","list"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\polynomial_regression.py","PolynomialRegression","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\polynomial_regression.py","","main","Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg dataset  >>> pass    # Placeholder, function is only for demo purposes","sns.load_dataset, PolynomialRegression, poly_reg.fit, np.sort, poly_reg.predict, plt.scatter, plt.plot, plt.title, plt.xlabel, plt.ylabel, plt.show"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\polynomial_regression.py","","__init__","@raises ValueError: if the polynomial degree is negative","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\polynomial_regression.py","","_design_matrix","Constructs a polynomial regression design matrix for the given input data. For input data x = (x, x, ..., x) and polynomial degree m, the design matrix is the Vandermonde matrix      |1  x  x  x| X = |1  x  x  x|     |           |     |1  x  x   x|  Reference: https://en.wikipedia.org/wiki/Vandermonde_matrix  @param data:    the input predictor values x, either for model fitting or for                 prediction @param degree:  the polynomial degree m @returns:       the Vandermonde matrix X (see above) @raises ValueError: if input data is not N x 1  >>> x = np.array([0, 1, 2]) >>> PolynomialRegression._design_matrix(x, degree=0) array([[1],        [1],        [1]]) >>> PolynomialRegression._design_matrix(x, degree=1) array([[1, 0],        [1, 1],        [1, 2]]) >>> PolynomialRegression._design_matrix(x, degree=2) array([[1, 0, 0],        [1, 1, 1],        [1, 2, 4]]) >>> PolynomialRegression._design_matrix(x, degree=3) array([[1, 0, 0, 0],        [1, 1, 1, 1],        [1, 2, 4, 8]]) >>> PolynomialRegression._design_matrix(np.array([[0, 0], [0 , 0]]), degree=3) Traceback (most recent call last): ... ValueError: Data must have dimensions N x 1","np.vander, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\polynomial_regression.py","","fit","Computes the polynomial regression model parameters using ordinary least squares (OLS) estimation:   = (XX)Xy = Xy  where X denotes the Moore-Penrose pseudoinverse of the design matrix X. This function computes X using singular value decomposition (SVD).  References:     - https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse     - https://en.wikipedia.org/wiki/Singular_value_decomposition     - https://en.wikipedia.org/wiki/Multicollinearity  @param x_train: the predictor values x for model fitting @param y_train: the response values y for model fitting @raises ArithmeticError:    if X isn't full rank, then XX is singular and                              doesn't exist  >>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) >>> y = x**3 - 2 * x**2 + 3 * x - 5 >>> poly_reg = PolynomialRegression(degree=3) >>> poly_reg.fit(x, y) >>> poly_reg.params array([-5.,  3., -2.,  1.]) >>> poly_reg = PolynomialRegression(degree=20) >>> poly_reg.fit(x, y) Traceback (most recent call last): ... ArithmeticError: Design matrix is not full rank, can't compute coefficients  Make sure errors don't grow too large: >>> coefs = np.array([-250, 50, -2, 36, 20, -12, 10, 2, -1, -15, 1]) >>> y = PolynomialRegression._design_matrix(x, len(coefs) - 1) @ coefs >>> poly_reg = PolynomialRegression(degree=len(coefs) - 1) >>> poly_reg.fit(x, y) >>> np.allclose(poly_reg.params, coefs, atol=10e-3) True","PolynomialRegression._design_matrix, np.linalg.matrix_rank, ArithmeticError, np.linalg.pinv"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\polynomial_regression.py","","predict","Computes the predicted response values y for the given input data by constructing the design matrix X and evaluating y = X.  @param data:    the predictor values x for prediction @returns:       the predicted response values y = X @raises ArithmeticError:    if this function is called before the model                             parameters are fit  >>> x = np.array([0, 1, 2, 3, 4]) >>> y = x**3 - 2 * x**2 + 3 * x - 5 >>> poly_reg = PolynomialRegression(degree=3) >>> poly_reg.fit(x, y) >>> poly_reg.predict(np.array([-1])) array([-11.]) >>> poly_reg.predict(np.array([-2])) array([-27.]) >>> poly_reg.predict(np.array([6])) array([157.]) >>> PolynomialRegression(degree=3).predict(x) Traceback (most recent call last): ... ArithmeticError: Predictor hasn't been fit yet","ArithmeticError, PolynomialRegression._design_matrix"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\principle_component_analysis.py","","collect_dataset","Collects the dataset (Iris dataset) and returns feature matrix and target values.  :return: Tuple containing feature matrix (X) and target labels (y)  Example: >>> X, y = collect_dataset() >>> X.shape (150, 4) >>> y.shape (150,)","load_iris, np.array, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\principle_component_analysis.py","","apply_pca","Applies Principal Component Analysis (PCA) to reduce dimensionality.  :param data_x: Original dataset (features) :param n_components: Number of principal components to retain :return: Tuple containing transformed dataset and explained variance ratio  Example: >>> X, _ = collect_dataset() >>> transformed_X, variance = apply_pca(X, 2) >>> transformed_X.shape (150, 2) >>> len(variance) == 2 True","StandardScaler, scaler.fit_transform, PCA, pca.fit_transform"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\principle_component_analysis.py","","main","Driver function to execute PCA and display results.","collect_dataset, apply_pca, print, print, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\scoring_functions.py","","mae","Examples(rounded for precision): >>> actual = [1,2,3];predict = [1,4,3] >>> float(np.around(mae(predict,actual),decimals = 2)) 0.67  >>> actual = [1,1,1];predict = [1,1,1] >>> float(mae(predict,actual)) 0.0","np.array, np.array, abs, difference.mean"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\scoring_functions.py","","mse","Examples(rounded for precision): >>> actual = [1,2,3];predict = [1,4,3] >>> float(np.around(mse(predict,actual),decimals = 2)) 1.33  >>> actual = [1,1,1];predict = [1,1,1] >>> float(mse(predict,actual)) 0.0","np.array, np.array, np.square, square_diff.mean"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\scoring_functions.py","","rmse","Examples(rounded for precision): >>> actual = [1,2,3];predict = [1,4,3] >>> float(np.around(rmse(predict,actual),decimals = 2)) 1.15  >>> actual = [1,1,1];predict = [1,1,1] >>> float(rmse(predict,actual)) 0.0","np.array, np.array, np.square, square_diff.mean, np.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\scoring_functions.py","","rmsle","Examples(rounded for precision): >>> float(np.around(rmsle(predict=[10, 2, 30], actual=[10, 10, 30]), decimals=2)) 0.75  >>> float(rmsle(predict=[1, 1, 1], actual=[1, 1, 1])) 0.0","np.array, np.array, np.log, np.log, np.square, square_diff.mean, np.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\scoring_functions.py","","mbd","This value is Negative, if the model underpredicts, positive, if it overpredicts.  Example(rounded for precision):  Here the model overpredicts >>> actual = [1,2,3];predict = [2,3,4] >>> float(np.around(mbd(predict,actual),decimals = 2)) 50.0  Here the model underpredicts >>> actual = [1,2,3];predict = [0,1,1] >>> float(np.around(mbd(predict,actual),decimals = 2)) -66.67","np.array, np.array, np.sum, len, np.sum, len, float"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\scoring_functions.py","","manual_accuracy","","np.mean, np.array, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\self_organizing_map.py","SelfOrganizingMap","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\self_organizing_map.py","","main","","SelfOrganizingMap, range, self_organizing_map.get_winner, print, print, range, len, self_organizing_map.get_winner, self_organizing_map.update"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\self_organizing_map.py","","get_winner","Compute the winning vector by Euclidean distance  >>> SelfOrganizingMap().get_winner([[1, 2, 3], [4, 5, 6]], [1, 2, 3]) 1","range, len, math.pow, math.pow"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\self_organizing_map.py","","update","Update the winning vector.  >>> SelfOrganizingMap().update([[1, 2, 3], [4, 5, 6]], [1, 2, 3], 1, 0.1) [[1, 2, 3], [3.7, 4.7, 6]]","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","SmoSVM","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","Kernel","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","count_time","","time.time, func, time.time, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","test_cancer_data","","print, pd.read_csv, data.dropna, data.replace, Kernel, np.zeros, SmoSVM, mysvm.fit, mysvm.predict, range, print, print, os.path.exists, urllib.request.Request, urllib.request.urlopen, .decode, np.array, open, f.write, data.columns.tolist, np.float64, np.float64, response.read"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","test_demonstration","","print, open, plt.subplot2grid, plt.subplot2grid, plt.subplot2grid, plt.subplot2grid, ax1.set_title, test_linear_kernel, ax2.set_title, test_linear_kernel, ax3.set_title, test_rbf_kernel, ax4.set_title, test_rbf_kernel, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","test_linear_kernel","","make_blobs, StandardScaler, scaler.fit_transform, np.hstack, Kernel, SmoSVM, mysvm.fit, plot_partition_boundary, train_y.reshape"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","test_rbf_kernel","","make_circles, StandardScaler, scaler.fit_transform, np.hstack, Kernel, SmoSVM, mysvm.fit, plot_partition_boundary, train_y.reshape"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","plot_partition_boundary","We cannot get the optimal w of our kernel SVM model, which is different from a linear SVM.  For this reason, we generate randomly distributed points with high density, and predicted values of these points are calculated using our trained model. Then we could use this predicted values to draw contour map, and this contour map represents the SVM's partition boundary.","np.linspace, np.linspace, .reshape, model.predict, test_tags.reshape, ax.contour, ax.scatter, ax.scatter, train_data_x.min, train_data_x.max, train_data_y.min, train_data_y.max, np.array, len, len, np.asmatrix"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","__init__","","np.float64, np.float64, list, self._calculate_k_matrix, np.zeros, self._choose_alphas, np.float64, np.float64, self._norm, np.zeros, range"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","fit","","self._get_new_alpha, np.float64, np.float64, self._is_unbound, self._is_unbound, self.choose_alpha.send, .copy, .copy, self._e, self._e, print, self._is_unbound, np.float64, np.float64, k, k, k, k, k, k"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","predict","","np.array, ValueError, self._norm, self._predict, results.append, results.append"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_check_obey_kkt","","self._e"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_k","","isinstance, self.Kernel"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_e","Two cases:     1: Sample[index] is non-bound, fetch error from list: _error     2: sample[index] is bound, use predicted value minus true value: g(xi) - yi","self._is_unbound, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_calculate_k_matrix","","np.zeros, np.float64, self.Kernel"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_predict","","np.sum, k"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_choose_alphas","","self._choose_a1"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_choose_a1","Choose first alpha Steps:     1: First loop over all samples     2: Second loop over all non-bound samples until no non-bound samples violate        the KKT condition.     3: Repeat these two processes until no samples violate the KKT condition        after the first loop.","print, print, print, self._check_obey_kkt, self._choose_a2, print, self._choose_a2, self._check_obey_kkt, self._is_unbound"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_choose_a2","Choose the second alpha using a heuristic algorithm Steps:     1: Choose alpha2 that maximizes the step size (|E1 - E2|).     2: Start in a random point, loop over all non-bound samples till alpha1 and        alpha2 are optimized.     3: Start in a random point, loop over all samples till alpha1 and alpha2 are        optimized.","np.random.default_rng, np.roll, np.roll, len, .tolist, rng.choice, rng.choice, self._is_unbound, self._e, min, max, self._error.copy, enumerate, self._is_unbound"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_get_new_alpha","","k, k, k, max, min, max, min, k, k, k, k, k, k, k, k, k, k"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_norm","","np.min, np.max"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_is_unbound","","bool"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_is_support","","bool"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","unbound","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","support","","range, self._is_support"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","length","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","__init__","","np.float64, np.float64, np.float64, self._get_kernel, self._check"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_polynomial","","np.inner"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_linear","","np.inner"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_rbf","","np.exp, np.linalg.norm"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_check","","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","_get_kernel","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","__call__","","self._kernel"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\sequential_minimum_optimization.py","","call_func","","time.time, func, time.time, print"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\similarity_search.py","","euclidean","Calculates euclidean distance between two data. :param input_a: ndarray of first vector. :param input_b: ndarray of second vector. :return: Euclidean distance of input_a and input_b. By using math.sqrt(),          result will be float.  >>> euclidean(np.array([0]), np.array([1])) 1.0 >>> euclidean(np.array([0, 1]), np.array([1, 1])) 1.0 >>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1])) 1.0","math.sqrt, sum, pow, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\similarity_search.py","","similarity_search",":param dataset: Set containing the vectors. Should be ndarray. :param value_array: vector/vectors we want to know the nearest vector from dataset. :return: Result will be a list containing         1. the nearest vector         2. distance from the vector  >>> dataset = np.array([[0], [1], [2]]) >>> value_array = np.array([[0]]) >>> similarity_search(dataset, value_array) [[[0], 0.0]]  >>> dataset = np.array([[0, 0], [1, 1], [2, 2]]) >>> value_array = np.array([[0, 1]]) >>> similarity_search(dataset, value_array) [[[0, 0], 1.0]]  >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]]) >>> value_array = np.array([[0, 0, 1]]) >>> similarity_search(dataset, value_array) [[[0, 0, 0], 1.0]]  >>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]]) >>> value_array = np.array([[0, 0, 0], [0, 0, 1]]) >>> similarity_search(dataset, value_array) [[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]  These are the errors that might occur:  1. If dimensions are different. For example, dataset has 2d array and value_array has 1d array: >>> dataset = np.array([[1]]) >>> value_array = np.array([1]) >>> similarity_search(dataset, value_array) Traceback (most recent call last):     ... ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1  2. If data's shapes are different. For example, dataset has shape of (3, 2) and value_array has (2, 3). We are expecting same shapes of two arrays, so it is wrong. >>> dataset = np.array([[0, 0], [1, 1], [2, 2]]) >>> value_array = np.array([[0, 0, 0], [0, 0, 1]]) >>> similarity_search(dataset, value_array) Traceback (most recent call last):     ... ValueError: Wrong input data's shape... dataset : 2, value_array : 3  3. If data types are different. When trying to compare, we are expecting same types so they should be same. If not, it'll come up with errors. >>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32) >>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32) >>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... TypeError: Input data have different datatype... dataset : float32, value_array : int32","ValueError, TypeError, euclidean, .tolist, answer.append, ValueError, euclidean, TypeError, dataset_value.tolist"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\similarity_search.py","","cosine_similarity","Calculates cosine similarity between two data. :param input_a: ndarray of first vector. :param input_b: ndarray of second vector. :return: Cosine similarity of input_a and input_b. By using math.sqrt(),          result will be float.  >>> cosine_similarity(np.array([1]), np.array([1])) 1.0 >>> cosine_similarity(np.array([1, 2]), np.array([6, 32])) 0.9615239476408232","float, np.dot, norm, norm"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","norm_squared","Return the squared second norm of vector norm_squared(v) = sum(x * x for x in v)  Args:     vector (ndarray): input vector  Returns:     float: squared second norm of vector  >>> int(norm_squared([1, 2])) 5 >>> int(norm_squared(np.asarray([1, 2]))) 5 >>> int(norm_squared([0, 0])) 0","np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","SVC","","Support Vector Classifier  Args:     kernel (str): kernel to use. Default: linear         Possible choices:             - linear     regularization: constraint for soft margin (data not linearly separable)         Default: unbound  >>> SVC(kernel=""asdf"") Traceback (most recent call last):     ... ValueError: Unknown kernel: asdf  >>> SVC(kernel=""rbf"") Traceback (most recent call last):     ... ValueError: rbf kernel requires gamma  >>> SVC(kernel=""rbf"", gamma=-1) Traceback (most recent call last):     ... ValueError: gamma must be > 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","__init__","","ValueError, ValueError, isinstance, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","__linear","Linear kernel (as if no kernel used at all)","np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","__rbf","RBF: Radial Basis Function Kernel  Note: for more information see:     https://en.wikipedia.org/wiki/Radial_basis_function_kernel  Args:     vector1 (ndarray): first vector     vector2 (ndarray): second vector)  Returns:     float: exp(-(gamma * norm_squared(vector1 - vector2)))","np.exp, norm_squared"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","fit","Fits the SVC with a set of observations.  Args:     observations (list[ndarray]): list of observations     classes (ndarray): classification of each observation (in {1, -1})","np.shape, LinearConstraint, Bounds, range, np.shape, range, minimize, range, range, sum, np.ones, self.kernel, self.kernel"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","predict","Get the expected class of an observation  Args:     observation (Vector): observation  Returns:     int {1, -1}: expected class  >>> xs = [ ...     np.asarray([0, 1]), np.asarray([0, 2]), ...     np.asarray([1, 1]), np.asarray([1, 2]) ... ] >>> y = np.asarray([1, 1, -1, -1]) >>> s = SVC() >>> s.fit(xs, y) >>> s.predict(np.asarray([0, 1])) 1 >>> s.predict(np.asarray([1, 1])) -1 >>> s.predict(np.asarray([2, 2])) -1","sum, self.kernel, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\support_vector_machines.py","","to_minimize","Opposite of the function to maximize  Args:     candidate (ndarray): candidate array to test  Return:     float: Wolfe's Dual result to minimize","np.shape, range, range, sum, self.kernel"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\t_stochastic_neighbour_embedding.py","","collect_dataset","Load the Iris dataset and return features and labels.  Returns:     tuple[ndarray, ndarray]: Feature matrix and target labels.  >>> features, targets = collect_dataset() >>> features.shape (150, 4) >>> targets.shape (150,)","load_iris, np.array, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\t_stochastic_neighbour_embedding.py","","compute_pairwise_affinities","Compute high-dimensional affinities (P matrix) using a Gaussian kernel.  Args:     data_matrix: Input data of shape (n_samples, n_features).     sigma: Gaussian kernel bandwidth.  Returns:     ndarray: Symmetrized probability matrix.  >>> x = np.array([[0.0, 0.0], [1.0, 0.0]]) >>> probabilities = compute_pairwise_affinities(x) >>> float(round(probabilities[0, 1], 3)) 0.25","np.sum, np.add, np.exp, np.fill_diagonal, np.sum, np.square, np.add, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\t_stochastic_neighbour_embedding.py","","compute_low_dim_affinities","Compute low-dimensional affinities (Q matrix) using a Student-t distribution.  Args:     embedding_matrix: Low-dimensional embedding of shape (n_samples, n_components).  Returns:     tuple[ndarray, ndarray]: (Q probability matrix, numerator matrix).  >>> y = np.array([[0.0, 0.0], [1.0, 0.0]]) >>> q_matrix, numerators = compute_low_dim_affinities(y) >>> q_matrix.shape (2, 2)","np.sum, np.fill_diagonal, np.square, np.sum, np.add, np.add, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\t_stochastic_neighbour_embedding.py","","apply_tsne","Apply t-SNE for dimensionality reduction.  Args:     data_matrix: Original dataset (features).     n_components: Target dimension (2D or 3D).     learning_rate: Step size for gradient descent.     n_iter: Number of iterations.  Returns:     ndarray: Low-dimensional embedding of the data.  >>> features, _ = collect_dataset() >>> embedding = apply_tsne(features, n_components=2, n_iter=50) >>> embedding.shape (150, 2)","np.random.default_rng, compute_pairwise_affinities, np.maximum, np.zeros_like, range, ValueError, rng.standard_normal, compute_low_dim_affinities, np.maximum, int, np.dot, np.multiply, np.sum"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\t_stochastic_neighbour_embedding.py","","main","Run t-SNE on the Iris dataset and display the first 5 embeddings.  >>> main()  # doctest: +ELLIPSIS t-SNE embedding (first 5 points): [[...","collect_dataset, apply_tsne, print, print, isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\word_frequency_functions.py","","term_frequency","Return the number of times a term occurs within a given document. @params: term, the term to search a document for, and document,         the document to search within @returns: an integer representing the number of times a term is         found within the document  @examples: >>> term_frequency(""to"", ""To be, or not to be"") 2",".replace, document_without_punctuation.split, len, document.translate, str.maketrans, word.lower, term.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\word_frequency_functions.py","","document_frequency","Calculate the number of documents in a corpus that contain a given term @params : term, the term to search each document for, and corpus, a collection of          documents. Each document should be separated by a newline. @returns : the number of documents in the corpus that contain the term you are            searching for and the number of documents in the corpus @examples : >>> document_frequency(""first"", ""This is the first document in the corpus.\nThIsis the second document in the corpus.\nTHIS is the third document in the corpus."") (1, 3)",".translate, corpus_without_punctuation.split, term.lower, str.maketrans, len, len, corpus.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\word_frequency_functions.py","","inverse_document_frequency","Return an integer denoting the importance of a word. This measure of importance is calculated by log10(N/df), where N is the number of documents and df is the Document Frequency. @params : df, the Document Frequency, N, the number of documents in the corpus and smoothing, if True return the idf-smooth @returns : log10(N/df) or 1+log10(N/1+df) @examples : >>> inverse_document_frequency(3, 0) Traceback (most recent call last):  ... ValueError: log10(0) is undefined. >>> inverse_document_frequency(1, 3) 0.477 >>> inverse_document_frequency(0, 3) Traceback (most recent call last):  ... ZeroDivisionError: df must be > 0 >>> inverse_document_frequency(0, 3,True) 1.477","round, round, ZeroDivisionError, log10, ValueError, ValueError, log10"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\word_frequency_functions.py","","tf_idf","Combine the term frequency and inverse document frequency functions to calculate the originality of a term. This 'originality' is calculated by multiplying the term frequency and the inverse document frequency : tf-idf = TF * IDF @params : tf, the term frequency, and idf, the inverse document frequency @examples : >>> tf_idf(2, 0.477) 0.954","round"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\xgboost_classifier.py","","data_handling",">>> data_handling(({'data':'[5.1, 3.5, 1.4, 0.2]','target':([0])})) ('[5.1, 3.5, 1.4, 0.2]', [0]) >>> data_handling( ...     {'data': '[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', 'target': ([0, 0])} ... ) ('[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', [0, 0])",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\xgboost_classifier.py","","xgboost","# THIS TEST IS BROKEN!! >>> xgboost(np.array([[5.1, 3.6, 1.4, 0.2]]), np.array([0])) XGBClassifier(base_score=0.5, booster='gbtree', callbacks=None,               colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,               early_stopping_rounds=None, enable_categorical=False,               eval_metric=None, gamma=0, gpu_id=-1, grow_policy='depthwise',               importance_type=None, interaction_constraints='',               learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,               max_delta_step=0, max_depth=6, max_leaves=0, min_child_weight=1,               missing=nan, monotone_constraints='()', n_estimators=100,               n_jobs=0, num_parallel_tree=1, predictor='auto', random_state=0,               reg_alpha=0, reg_lambda=1, ...)","XGBClassifier, classifier.fit"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\xgboost_classifier.py","","main","Url for the algorithm: https://xgboost.readthedocs.io/en/stable/ Iris type dataset is used to demonstrate algorithm.","load_iris, data_handling, train_test_split, xgboost, ConfusionMatrixDisplay.from_estimator, plt.title, plt.show"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\xgboost_regressor.py","","data_handling",">>> data_handling(( ...  {'data':'[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]' ...  ,'target':([4.526])})) ('[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]', [4.526])",""
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\xgboost_regressor.py","","xgboost",">>> xgboost(np.array([[ 2.3571 ,   52. , 6.00813008, 1.06775068, ...    907. , 2.45799458,   40.58 , -124.26]]),np.array([1.114]), ... np.array([[1.97840000e+00,  3.70000000e+01,  4.98858447e+00,  1.03881279e+00, ...    1.14300000e+03,  2.60958904e+00,  3.67800000e+01, -1.19780000e+02]])) array([[1.1139996]], dtype=float32)","XGBRegressor, xgb.fit, xgb.predict, predictions.reshape, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\xgboost_regressor.py","","main","The URL for this algorithm https://xgboost.readthedocs.io/en/stable/ California house price dataset is used to demonstrate the algorithm.  Expected error values: Mean Absolute Error: 0.30957163379906033 Mean Square Error: 0.22611560196662744","fetch_california_housing, data_handling, train_test_split, xgboost, print, print, mean_absolute_error, mean_squared_error"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\forecasting\run.py","","linear_regression_prediction","First method: linear regression input : training data (date, total_user, total_event) in list of float output : list of total user prediction in float >>> n = linear_regression_prediction([2,3,4,5], [5,3,4,6], [3,1,2,4], [2,1], [2,2]) >>> bool(abs(n - 5.0) < 1e-6)  # Checking precision because of floating point errors True","np.array, np.array, np.dot, abs, np.dot, np.linalg.inv, x.transpose, enumerate, np.dot, x.transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\forecasting\run.py","","sarimax_predictor","second method: Sarimax sarimax is a statistic method which using previous input and learn its pattern to predict future data input : training data (total_user, with exog data = total_event) in list of float output : list of total user prediction in float >>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2]) 6.6666671111109626","simplefilter, SARIMAX, model.fit, model_fit.predict, float, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\forecasting\run.py","","support_vector_regressor","Third method: Support vector regressor svr is quite the same with svm(support vector machine) it uses the same principles as the SVM for classification, with only a few minor differences and the only different is that it suits better for regression purpose input : training data (date, total_user, total_event) in list of float where x = list of set (date and total event) output : list of total user prediction in float >>> support_vector_regressor([[5,2],[1,5],[6,2]], [[3,2]], [2,1,4]) 1.634932078116079","SVR, regressor.fit, regressor.predict, float"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\forecasting\run.py","","interquartile_range_checker","Optional method: interquatile range input : list of total user in float output : low limit of input in float this method can be used to check whether some data is outlier or not >>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10]) 2.8","train_user.sort, np.percentile, np.percentile, float"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\forecasting\run.py","","data_safety_checker","Used to review all the votes (list result prediction) and compare it to the actual result. input : list of predictions output : print whether it's safe or not >>> data_safety_checker([2, 3, 4], 5.0) False","isinstance, TypeError, abs, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\local_weighted_learning\local_weighted_learning.py","","weight_matrix","Calculate the weight of every point in the training data around a given prediction point  Args:     point: x-value at which the prediction is being made     x_train: ndarray of x-values for training     tau: bandwidth value, controls how quickly the weight of training values         decreases as the distance from the prediction point increases  Returns:     m x m weight matrix around the prediction point, where m is the size of     the training set >>> weight_matrix( ...     np.array([1., 1.]), ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]), ...     0.6 ... ) array([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],        [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],        [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])","len, np.eye, range, np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\local_weighted_learning\local_weighted_learning.py","","local_weight","Calculate the local weights at a given prediction point using the weight matrix for that point  Args:     point: x-value at which the prediction is being made     x_train: ndarray of x-values for training     y_train: ndarray of y-values for training     tau: bandwidth value, controls how quickly the weight of training values         decreases as the distance from the prediction point increases Returns:     ndarray of local weights >>> local_weight( ...     np.array([1., 1.]), ...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]), ...     np.array([[1.01, 1.66, 3.5]]), ...     0.6 ... ) array([[0.00873174],        [0.08272556]])","weight_matrix, np.linalg.inv"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\local_weighted_learning\local_weighted_learning.py","","local_weight_regression","Calculate predictions for each point in the training data  Args:     x_train: ndarray of x-values for training     y_train: ndarray of y-values for training     tau: bandwidth value, controls how quickly the weight of training values         decreases as the distance from the prediction point increases  Returns:     ndarray of predictions >>> local_weight_regression( ...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]), ...     np.array([[1.01, 1.66, 3.5]]), ...     0.6 ... ) array([1.07173261, 1.65970737, 3.50160179])","np.zeros, enumerate, len, .item, np.dot, local_weight"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\local_weighted_learning\local_weighted_learning.py","","load_data","Load data from seaborn and split it into x and y points >>> pass    # No doctests, function is for demo purposes only","sns.load_dataset, np.array, np.array, np.ones, np.column_stack, len"
"C:/Users/Joseph Dania/Desktop/python_repo\machine_learning\local_weighted_learning\local_weighted_learning.py","","plot_preds","Plot predictions and display the graph >>> pass    # No doctests, function is for demo purposes only","np.sort, plt.scatter, plt.plot, plt.title, plt.xlabel, plt.ylabel, plt.show, .argsort"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\abs.py","","abs_val","Find the absolute value of a number.  >>> abs_val(-5.1) 5.1 >>> abs_val(-5) == abs_val(5) True >>> abs_val(0) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\abs.py","","abs_min",">>> abs_min([0,5,1,11]) 0 >>> abs_min([3,-10,-2]) -2 >>> abs_min([]) Traceback (most recent call last):     ... ValueError: abs_min() arg is an empty sequence","len, ValueError, abs_val, abs_val"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\abs.py","","abs_max",">>> abs_max([0,5,1,11]) 11 >>> abs_max([3,-10,-2]) -10 >>> abs_max([]) Traceback (most recent call last):     ... ValueError: abs_max() arg is an empty sequence","len, ValueError, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\abs.py","","abs_max_sort",">>> abs_max_sort([0,5,1,11]) 11 >>> abs_max_sort([3,-10,-2]) -10 >>> abs_max_sort([]) Traceback (most recent call last):     ... ValueError: abs_max_sort() arg is an empty sequence","len, ValueError, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\abs.py","","test_abs_val",">>> test_abs_val()","abs_val, abs_val, abs_val, abs_max, abs_max_sort, abs_min"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\addition_without_arithmetic.py","","add","Implementation of addition of integer  Examples: >>> add(3, 5) 8 >>> add(13, 5) 18 >>> add(-7, 2) -5 >>> add(0, -7) -7 >>> add(-321, 0) -321",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\aliquot_sum.py","","aliquot_sum","Finds the aliquot sum of an input integer, where the aliquot sum of a number n is defined as the sum of all natural numbers less than n that divide n evenly. For example, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is a simple O(n) implementation. @param input_num: a positive integer whose aliquot sum is to be found @return: the aliquot sum of input_num, if input_num is positive. Otherwise, raise a ValueError Wikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum  >>> aliquot_sum(15) 9 >>> aliquot_sum(6) 6 >>> aliquot_sum(-1) Traceback (most recent call last):   ... ValueError: Input must be positive >>> aliquot_sum(0) Traceback (most recent call last):   ... ValueError: Input must be positive >>> aliquot_sum(1.6) Traceback (most recent call last):   ... ValueError: Input must be an integer >>> aliquot_sum(12) 16 >>> aliquot_sum(1) 0 >>> aliquot_sum(19) 1","sum, isinstance, ValueError, ValueError, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\allocation_number.py","","allocation_num","Divide a number of bytes into x partitions. :param number_of_bytes: the total of bytes. :param partitions: the number of partition need to be allocated. :return: list of bytes to be assigned to each worker thread  >>> allocation_num(16647, 4) ['1-4161', '4162-8322', '8323-12483', '12484-16647'] >>> allocation_num(50000, 5) ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000'] >>> allocation_num(888, 999) Traceback (most recent call last):     ... ValueError: partitions can not > number_of_bytes! >>> allocation_num(888, -4) Traceback (most recent call last):     ... ValueError: partitions must be a positive number!","range, ValueError, ValueError, allocation_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\arc_length.py","","arc_length",">>> arc_length(45, 5) 3.9269908169872414 >>> arc_length(120, 15) 31.415926535897928 >>> arc_length(90, 10) 15.707963267948966",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_cube","Calculate the Surface Area of a Cube.  >>> surface_area_cube(1) 6 >>> surface_area_cube(1.6) 15.360000000000003 >>> surface_area_cube(0) 0 >>> surface_area_cube(3) 54 >>> surface_area_cube(-1) Traceback (most recent call last):     ... ValueError: surface_area_cube() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_cuboid","Calculate the Surface Area of a Cuboid.  >>> surface_area_cuboid(1, 2, 3) 22 >>> surface_area_cuboid(0, 0, 0) 0 >>> surface_area_cuboid(1.6, 2.6, 3.6) 38.56 >>> surface_area_cuboid(-1, 2, 3) Traceback (most recent call last):     ... ValueError: surface_area_cuboid() only accepts non-negative values >>> surface_area_cuboid(1, -2, 3) Traceback (most recent call last):     ... ValueError: surface_area_cuboid() only accepts non-negative values >>> surface_area_cuboid(1, 2, -3) Traceback (most recent call last):     ... ValueError: surface_area_cuboid() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_sphere","Calculate the Surface Area of a Sphere. Wikipedia reference: https://en.wikipedia.org/wiki/Sphere Formula: 4 * pi * r^2  >>> surface_area_sphere(5) 314.1592653589793 >>> surface_area_sphere(1) 12.566370614359172 >>> surface_area_sphere(1.6) 32.169908772759484 >>> surface_area_sphere(0) 0.0 >>> surface_area_sphere(-1) Traceback (most recent call last):     ... ValueError: surface_area_sphere() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_hemisphere","Calculate the Surface Area of a Hemisphere. Formula: 3 * pi * r^2  >>> surface_area_hemisphere(5) 235.61944901923448 >>> surface_area_hemisphere(1) 9.42477796076938 >>> surface_area_hemisphere(0) 0.0 >>> surface_area_hemisphere(1.1) 11.40398133253095 >>> surface_area_hemisphere(-1) Traceback (most recent call last):     ... ValueError: surface_area_hemisphere() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_cone","Calculate the Surface Area of a Cone. Wikipedia reference: https://en.wikipedia.org/wiki/Cone Formula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)  >>> surface_area_cone(10, 24) 1130.9733552923256 >>> surface_area_cone(6, 8) 301.59289474462014 >>> surface_area_cone(1.6, 2.6) 23.387862992395807 >>> surface_area_cone(0, 0) 0.0 >>> surface_area_cone(-1, -2) Traceback (most recent call last):     ... ValueError: surface_area_cone() only accepts non-negative values >>> surface_area_cone(1, -2) Traceback (most recent call last):     ... ValueError: surface_area_cone() only accepts non-negative values >>> surface_area_cone(-1, 2) Traceback (most recent call last):     ... ValueError: surface_area_cone() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_conical_frustum","Calculate the Surface Area of a Conical Frustum.  >>> surface_area_conical_frustum(1, 2, 3) 45.511728065337266 >>> surface_area_conical_frustum(4, 5, 6) 300.7913575056268 >>> surface_area_conical_frustum(0, 0, 0) 0.0 >>> surface_area_conical_frustum(1.6, 2.6, 3.6) 78.57907060751548 >>> surface_area_conical_frustum(-1, 2, 3) Traceback (most recent call last):     ... ValueError: surface_area_conical_frustum() only accepts non-negative values >>> surface_area_conical_frustum(1, -2, 3) Traceback (most recent call last):     ... ValueError: surface_area_conical_frustum() only accepts non-negative values >>> surface_area_conical_frustum(1, 2, -3) Traceback (most recent call last):     ... ValueError: surface_area_conical_frustum() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_cylinder","Calculate the Surface Area of a Cylinder. Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder Formula: 2 * pi * r * (h + r)  >>> surface_area_cylinder(7, 10) 747.6990515543707 >>> surface_area_cylinder(1.6, 2.6) 42.22300526424682 >>> surface_area_cylinder(0, 0) 0.0 >>> surface_area_cylinder(6, 8) 527.7875658030853 >>> surface_area_cylinder(-1, -2) Traceback (most recent call last):     ... ValueError: surface_area_cylinder() only accepts non-negative values >>> surface_area_cylinder(1, -2) Traceback (most recent call last):     ... ValueError: surface_area_cylinder() only accepts non-negative values >>> surface_area_cylinder(-1, 2) Traceback (most recent call last):     ... ValueError: surface_area_cylinder() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","surface_area_torus","Calculate the Area of a Torus. Wikipedia reference: https://en.wikipedia.org/wiki/Torus :return 4pi^2 * torus_radius * tube_radius >>> surface_area_torus(1, 1) 39.47841760435743 >>> surface_area_torus(4, 3) 473.7410112522892 >>> surface_area_torus(3, 4) Traceback (most recent call last):     ... ValueError: surface_area_torus() does not support spindle or self intersecting tori >>> surface_area_torus(1.6, 1.6) 101.06474906715503 >>> surface_area_torus(0, 0) 0.0 >>> surface_area_torus(-1, 1) Traceback (most recent call last):     ... ValueError: surface_area_torus() only accepts non-negative values >>> surface_area_torus(1, -1) Traceback (most recent call last):     ... ValueError: surface_area_torus() only accepts non-negative values","ValueError, ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_rectangle","Calculate the area of a rectangle.  >>> area_rectangle(10, 20) 200 >>> area_rectangle(1.6, 2.6) 4.16 >>> area_rectangle(0, 0) 0 >>> area_rectangle(-1, -2) Traceback (most recent call last):     ... ValueError: area_rectangle() only accepts non-negative values >>> area_rectangle(1, -2) Traceback (most recent call last):     ... ValueError: area_rectangle() only accepts non-negative values >>> area_rectangle(-1, 2) Traceback (most recent call last):     ... ValueError: area_rectangle() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_square","Calculate the area of a square.  >>> area_square(10) 100 >>> area_square(0) 0 >>> area_square(1.6) 2.5600000000000005 >>> area_square(-1) Traceback (most recent call last):     ... ValueError: area_square() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_triangle","Calculate the area of a triangle given the base and height.  >>> area_triangle(10, 10) 50.0 >>> area_triangle(1.6, 2.6) 2.08 >>> area_triangle(0, 0) 0.0 >>> area_triangle(-1, -2) Traceback (most recent call last):     ... ValueError: area_triangle() only accepts non-negative values >>> area_triangle(1, -2) Traceback (most recent call last):     ... ValueError: area_triangle() only accepts non-negative values >>> area_triangle(-1, 2) Traceback (most recent call last):     ... ValueError: area_triangle() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_triangle_three_sides","Calculate area of triangle when the length of 3 sides are known. This function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula  >>> area_triangle_three_sides(5, 12, 13) 30.0 >>> area_triangle_three_sides(10, 11, 12) 51.521233486786784 >>> area_triangle_three_sides(0, 0, 0) 0.0 >>> area_triangle_three_sides(1.6, 2.6, 3.6) 1.8703742940919619 >>> area_triangle_three_sides(-1, -2, -1) Traceback (most recent call last):     ... ValueError: area_triangle_three_sides() only accepts non-negative values >>> area_triangle_three_sides(1, -2, 1) Traceback (most recent call last):     ... ValueError: area_triangle_three_sides() only accepts non-negative values >>> area_triangle_three_sides(2, 4, 7) Traceback (most recent call last):     ... ValueError: Given three sides do not form a triangle >>> area_triangle_three_sides(2, 7, 4) Traceback (most recent call last):     ... ValueError: Given three sides do not form a triangle >>> area_triangle_three_sides(7, 2, 4) Traceback (most recent call last):     ... ValueError: Given three sides do not form a triangle","sqrt, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_parallelogram","Calculate the area of a parallelogram.  >>> area_parallelogram(10, 20) 200 >>> area_parallelogram(1.6, 2.6) 4.16 >>> area_parallelogram(0, 0) 0 >>> area_parallelogram(-1, -2) Traceback (most recent call last):     ... ValueError: area_parallelogram() only accepts non-negative values >>> area_parallelogram(1, -2) Traceback (most recent call last):     ... ValueError: area_parallelogram() only accepts non-negative values >>> area_parallelogram(-1, 2) Traceback (most recent call last):     ... ValueError: area_parallelogram() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_trapezium","Calculate the area of a trapezium.  >>> area_trapezium(10, 20, 30) 450.0 >>> area_trapezium(1.6, 2.6, 3.6) 7.5600000000000005 >>> area_trapezium(0, 0, 0) 0.0 >>> area_trapezium(-1, -2, -3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values >>> area_trapezium(-1, 2, 3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values >>> area_trapezium(1, -2, 3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values >>> area_trapezium(1, 2, -3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values >>> area_trapezium(-1, -2, 3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values >>> area_trapezium(1, -2, -3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values >>> area_trapezium(-1, 2, -3) Traceback (most recent call last):     ... ValueError: area_trapezium() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_circle","Calculate the area of a circle.  >>> area_circle(20) 1256.6370614359173 >>> area_circle(1.6) 8.042477193189871 >>> area_circle(0) 0.0 >>> area_circle(-1) Traceback (most recent call last):     ... ValueError: area_circle() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_ellipse","Calculate the area of a ellipse.  >>> area_ellipse(10, 10) 314.1592653589793 >>> area_ellipse(10, 20) 628.3185307179587 >>> area_ellipse(0, 0) 0.0 >>> area_ellipse(1.6, 2.6) 13.06902543893354 >>> area_ellipse(-10, 20) Traceback (most recent call last):     ... ValueError: area_ellipse() only accepts non-negative values >>> area_ellipse(10, -20) Traceback (most recent call last):     ... ValueError: area_ellipse() only accepts non-negative values >>> area_ellipse(-10, -20) Traceback (most recent call last):     ... ValueError: area_ellipse() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_rhombus","Calculate the area of a rhombus.  >>> area_rhombus(10, 20) 100.0 >>> area_rhombus(1.6, 2.6) 2.08 >>> area_rhombus(0, 0) 0.0 >>> area_rhombus(-1, -2) Traceback (most recent call last):     ... ValueError: area_rhombus() only accepts non-negative values >>> area_rhombus(1, -2) Traceback (most recent call last):     ... ValueError: area_rhombus() only accepts non-negative values >>> area_rhombus(-1, 2) Traceback (most recent call last):     ... ValueError: area_rhombus() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area.py","","area_reg_polygon","Calculate the area of a regular polygon. Wikipedia reference: https://en.wikipedia.org/wiki/Polygon#Regular_polygons Formula: (n*s^2*cot(pi/n))/4  >>> area_reg_polygon(3, 10) 43.301270189221945 >>> area_reg_polygon(4, 10) 100.00000000000001 >>> area_reg_polygon(0, 0) Traceback (most recent call last):     ... ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides >>> area_reg_polygon(-1, -2) Traceback (most recent call last):     ... ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides >>> area_reg_polygon(5, -2) Traceback (most recent call last):     ... ValueError: area_reg_polygon() only accepts non-negative values as length of a side >>> area_reg_polygon(-1, 2) Traceback (most recent call last):     ... ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides","ValueError, isinstance, ValueError, tan, tan"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area_under_curve.py","","trapezoidal_area","Treats curve as a collection of linear lines and sums the area of the trapezium shape they form :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases the accuracy :return: a float representing the length of the curve  >>> def f(x): ...    return 5 >>> f""{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}"" '10.000' >>> def f(x): ...    return 9*x**2 >>> f""{trapezoidal_area(f, -4.0, 0, 10000):.4f}"" '192.0000' >>> f""{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}"" '384.0000'","fnc, range, fnc, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\area_under_curve.py","","f","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\average_absolute_deviation.py","","average_absolute_deviation","Return the average absolute deviation of a list of numbers. Wiki: https://en.wikipedia.org/wiki/Average_absolute_deviation  >>> average_absolute_deviation([0]) 0.0 >>> average_absolute_deviation([4, 1, 3, 2]) 1.0 >>> average_absolute_deviation([2, 70, 6, 50, 20, 8, 4, 0]) 20.0 >>> average_absolute_deviation([-20, 0, 30, 15]) 16.25 >>> average_absolute_deviation([]) Traceback (most recent call last):     ... ValueError: List is empty","ValueError, sum, len, sum, len, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\average_mean.py","","mean","Find mean of a list of numbers. Wiki: https://en.wikipedia.org/wiki/Mean  >>> mean([3, 6, 9, 12, 15, 18, 21]) 12.0 >>> mean([5, 10, 15, 20, 25, 30, 35]) 20.0 >>> mean([1, 2, 3, 4, 5, 6, 7, 8]) 4.5 >>> mean([]) Traceback (most recent call last):     ... ValueError: List is empty","ValueError, sum, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\average_median.py","","median","Find median of a list of numbers. Wiki: https://en.wikipedia.org/wiki/Median  >>> median([0]) 0 >>> median([4, 1, 3, 2]) 2.5 >>> median([2, 70, 6, 50, 20, 8, 4]) 8  Args:     nums: List of nums  Returns:     Median.","sorted, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\average_median.py","","main","","doctest.testmod"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\average_mode.py","","mode","This function returns the mode(Mode as in the measures of central tendency) of the input data.  The input list may contain any Datastructure or any Datatype.  >>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2]) [2] >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2]) [2] >>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2]) [2, 4] >>> mode([""x"", ""y"", ""y"", ""z""]) ['y'] >>> mode([""x"", ""x"" , ""y"", ""y"", ""z""]) ['x', 'y']","max, sorted, input_list.count, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\bailey_borwein_plouffe.py","","bailey_borwein_plouffe","Implement a popular pi-digit-extraction algorithm known as the Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi. Wikipedia page: https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula @param digit_position: a positive integer representing the position of the digit to extract. The digit immediately after the decimal point is located at position 1. @param precision: number of terms in the second summation to calculate. A higher number reduces the chance of an error but increases the runtime. @return: a hexadecimal digit representing the digit at the nth position in pi's decimal expansion.  >>> """".join(bailey_borwein_plouffe(i) for i in range(1, 11)) '243f6a8885' >>> bailey_borwein_plouffe(5, 10000) '6' >>> bailey_borwein_plouffe(-10) Traceback (most recent call last):   ... ValueError: Digit position must be a positive integer >>> bailey_borwein_plouffe(0) Traceback (most recent call last):   ... ValueError: Digit position must be a positive integer >>> bailey_borwein_plouffe(1.7) Traceback (most recent call last):   ... ValueError: Digit position must be a positive integer >>> bailey_borwein_plouffe(2, -10) Traceback (most recent call last):   ... ValueError: Precision must be a nonnegative integer >>> bailey_borwein_plouffe(2, 1.6) Traceback (most recent call last):   ... ValueError: Precision must be a nonnegative integer","ValueError, _subsum, hex, isinstance, ValueError, _subsum, int, isinstance, _subsum, _subsum"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\bailey_borwein_plouffe.py","","_subsum","Private helper function to implement the summation functionality. @param digit_pos_to_extract: digit position to extract @param denominator_addend: added to denominator of fractions in the formula @param precision: same as precision in main function @return: floating-point number whose integer part is not important","range, pow, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\base_neg2_conversion.py","","decimal_to_negative_base_2","This function returns the number negative base 2     of the decimal number of the input data.  Args:     int: The decimal number to convert.  Returns:     int: The negative base 2 number.  Examples:     >>> decimal_to_negative_base_2(0)     0     >>> decimal_to_negative_base_2(-19)     111101     >>> decimal_to_negative_base_2(4)     100     >>> decimal_to_negative_base_2(7)     11011","int, divmod, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\basic_maths.py","","prime_factors","Find Prime Factors. >>> prime_factors(100) [2, 2, 5, 5] >>> prime_factors(0) Traceback (most recent call last):     ... ValueError: Only positive integers have prime factors >>> prime_factors(-10) Traceback (most recent call last):     ... ValueError: Only positive integers have prime factors","range, ValueError, pf.append, int, pf.append, int, pf.append, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\basic_maths.py","","number_of_divisors","Calculate Number of Divisors of an Integer. >>> number_of_divisors(100) 9 >>> number_of_divisors(0) Traceback (most recent call last):     ... ValueError: Only positive numbers are accepted >>> number_of_divisors(-10) Traceback (most recent call last):     ... ValueError: Only positive numbers are accepted","range, ValueError, int, int, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\basic_maths.py","","sum_of_divisors","Calculate Sum of Divisors. >>> sum_of_divisors(100) 217 >>> sum_of_divisors(0) Traceback (most recent call last):     ... ValueError: Only positive numbers are accepted >>> sum_of_divisors(-10) Traceback (most recent call last):     ... ValueError: Only positive numbers are accepted","range, int, ValueError, int, int, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\basic_maths.py","","euler_phi","Calculate Euler's Phi Function. >>> euler_phi(100) 40 >>> euler_phi(0) Traceback (most recent call last):     ... ValueError: Only positive numbers are accepted >>> euler_phi(-10) Traceback (most recent call last):     ... ValueError: Only positive numbers are accepted","set, int, ValueError, prime_factors"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binary_exponentiation.py","","binary_exp_recursive","Computes a^b recursively, where a is the base and b is the exponent  >>> binary_exp_recursive(3, 5) 243 >>> binary_exp_recursive(11, 13) 34522712143931 >>> binary_exp_recursive(-1, 3) -1 >>> binary_exp_recursive(0, 5) 0 >>> binary_exp_recursive(3, 1) 3 >>> binary_exp_recursive(3, 0) 1 >>> binary_exp_recursive(1.5, 4) 5.0625 >>> binary_exp_recursive(3, -1) Traceback (most recent call last):     ... ValueError: Exponent must be a non-negative integer","binary_exp_recursive, ValueError, binary_exp_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binary_exponentiation.py","","binary_exp_iterative","Computes a^b iteratively, where a is the base and b is the exponent  >>> binary_exp_iterative(3, 5) 243 >>> binary_exp_iterative(11, 13) 34522712143931 >>> binary_exp_iterative(-1, 3) -1 >>> binary_exp_iterative(0, 5) 0 >>> binary_exp_iterative(3, 1) 3 >>> binary_exp_iterative(3, 0) 1 >>> binary_exp_iterative(1.5, 4) 5.0625 >>> binary_exp_iterative(3, -1) Traceback (most recent call last):     ... ValueError: Exponent must be a non-negative integer","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binary_exponentiation.py","","binary_exp_mod_recursive","Computes a^b % c recursively, where a is the base, b is the exponent, and c is the modulus  >>> binary_exp_mod_recursive(3, 4, 5) 1 >>> binary_exp_mod_recursive(11, 13, 7) 4 >>> binary_exp_mod_recursive(1.5, 4, 3) 2.0625 >>> binary_exp_mod_recursive(7, -1, 10) Traceback (most recent call last):     ... ValueError: Exponent must be a non-negative integer >>> binary_exp_mod_recursive(7, 13, 0) Traceback (most recent call last):     ... ValueError: Modulus must be a positive integer","binary_exp_mod_recursive, ValueError, ValueError, binary_exp_mod_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binary_exponentiation.py","","binary_exp_mod_iterative","Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the modulus  >>> binary_exp_mod_iterative(3, 4, 5) 1 >>> binary_exp_mod_iterative(11, 13, 7) 4 >>> binary_exp_mod_iterative(1.5, 4, 3) 2.0625 >>> binary_exp_mod_iterative(7, -1, 10) Traceback (most recent call last):     ... ValueError: Exponent must be a non-negative integer >>> binary_exp_mod_iterative(7, 13, 0) Traceback (most recent call last):     ... ValueError: Modulus must be a positive integer","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binary_multiplication.py","","binary_multiply","Multiply 'a' and 'b' using bitwise multiplication.  Parameters: a (int): The first number. b (int): The second number.  Returns: int: a * b  Examples: >>> binary_multiply(2, 3) 6 >>> binary_multiply(5, 0) 0 >>> binary_multiply(3, 4) 12 >>> binary_multiply(10, 5) 50 >>> binary_multiply(0, 5) 0 >>> binary_multiply(2, 1) 2 >>> binary_multiply(1, 10) 10",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binary_multiplication.py","","binary_mod_multiply","Calculate (a * b) % c using binary multiplication and modular arithmetic.  Parameters: a (int): The first number. b (int): The second number. modulus (int): The modulus.  Returns: int: (a * b) % modulus.  Examples: >>> binary_mod_multiply(2, 3, 5) 1 >>> binary_mod_multiply(5, 0, 7) 0 >>> binary_mod_multiply(3, 4, 6) 0 >>> binary_mod_multiply(10, 5, 13) 11 >>> binary_mod_multiply(2, 1, 5) 2 >>> binary_mod_multiply(1, 10, 3) 1",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binomial_coefficient.py","","binomial_coefficient","Find binomial coefficient using Pascal's triangle.  Calculate C(n, r) using Pascal's triangle.  :param n: The total number of items. :param r: The number of items to choose. :return: The binomial coefficient C(n, r).  >>> binomial_coefficient(10, 5) 252 >>> binomial_coefficient(10, 0) 1 >>> binomial_coefficient(0, 10) 1 >>> binomial_coefficient(10, 10) 1 >>> binomial_coefficient(5, 2) 10 >>> binomial_coefficient(5, 6) 0 >>> binomial_coefficient(3, 5) 0 >>> binomial_coefficient(-2, 3) Traceback (most recent call last):     ... ValueError: n and r must be non-negative integers >>> binomial_coefficient(5, -1) Traceback (most recent call last):     ... ValueError: n and r must be non-negative integers >>> binomial_coefficient(10.1, 5) Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer >>> binomial_coefficient(10, 5.1) Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer","range, ValueError, min, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\binomial_distribution.py","","binomial_distribution","Return probability of k successes out of n tries, with p probability for one success  The function uses the factorial function in order to calculate the binomial coefficient  >>> binomial_distribution(3, 5, 0.7) 0.30870000000000003 >>> binomial_distribution (2, 4, 0.5) 0.375","float, ValueError, ValueError, ValueError, ValueError, factorial, factorial, factorial, isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\ceil.py","","ceil","Return the ceiling of x as an Integral.  :param x: the number :return: the smallest integer >= x.  >>> import math >>> all(ceil(n) == math.ceil(n) for n ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000)) True","int, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\chebyshev_distance.py","","chebyshev_distance","This function calculates the Chebyshev distance (also known as the Chessboard distance) between two n-dimensional points represented as lists.  https://en.wikipedia.org/wiki/Chebyshev_distance  >>> chebyshev_distance([1.0, 1.0], [2.0, 2.0]) 1.0 >>> chebyshev_distance([1.0, 1.0, 9.0], [2.0, 2.0, -5.2]) 14.2 >>> chebyshev_distance([1.0], [2.0, 2.0]) Traceback (most recent call last):     ... ValueError: Both points must have the same dimension.","max, len, len, ValueError, abs, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\check_polygon.py","","check_polygon","Takes list of possible side lengths and determines whether a two-dimensional polygon with such side lengths can exist.  Returns a boolean value for the < comparison of the largest side length with sum of the rest. Wiki: https://en.wikipedia.org/wiki/Triangle_inequality  >>> check_polygon([6, 10, 5]) True >>> check_polygon([3, 7, 13, 2]) False >>> check_polygon([1, 4.3, 5.2, 12.2]) False >>> nums = [3, 7, 13, 2] >>> _ = check_polygon(nums) #   Run function, do not show answer in output >>> nums #  Check numbers are not reordered [3, 7, 13, 2] >>> check_polygon([]) Traceback (most recent call last):     ... ValueError: Monogons and Digons are not polygons in the Euclidean space >>> check_polygon([-2, 5, 6]) Traceback (most recent call last):     ... ValueError: All values must be greater than 0","any, nums.copy, copy_nums.sort, len, ValueError, ValueError, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\chinese_remainder_theorem.py","","extended_euclid",">>> extended_euclid(10, 6) (-1, 2)  >>> extended_euclid(7, 5) (-2, 3)","extended_euclid"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\chinese_remainder_theorem.py","","chinese_remainder_theorem",">>> chinese_remainder_theorem(5,1,7,3) 31  Explanation : 31 is the smallest number such that             (i)  When we divide it by 5, we get remainder 1             (ii) When we divide it by 7, we get remainder 3  >>> chinese_remainder_theorem(6,1,4,3) 14","extended_euclid"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\chinese_remainder_theorem.py","","invert_modulo",">>> invert_modulo(2, 5) 3  >>> invert_modulo(8,7) 1","extended_euclid"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\chinese_remainder_theorem.py","","chinese_remainder_theorem2",">>> chinese_remainder_theorem2(5,1,7,3) 31  >>> chinese_remainder_theorem2(6,1,4,3) 14","invert_modulo, invert_modulo"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\chudnovsky_algorithm.py","","pi","The Chudnovsky algorithm is a fast method for calculating the digits of PI, based on Ramanujan's PI formulae.  https://en.wikipedia.org/wiki/Chudnovsky_algorithm  PI = constant_term / ((multinomial_term * linear_term) / exponential_term)     where constant_term = 426880 * sqrt(10005)  The linear_term and the exponential_term can be defined iteratively as follows:     L_k+1 = L_k + 545140134            where L_0 = 13591409     X_k+1 = X_k * -262537412640768000  where X_0 = 1  The multinomial_term is defined as follows:     6k! / ((3k)! * (k!) ^ 3)         where k is the k_th iteration.  This algorithm correctly calculates around 14 digits of PI per iteration  >>> pi(10) '3.14159265' >>> pi(100) '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706' >>> pi('hello') Traceback (most recent call last):     ... TypeError: Undefined for non-integers >>> pi(-1) Traceback (most recent call last):     ... ValueError: Undefined for non-natural numbers","ceil, Decimal, range, isinstance, TypeError, getcontext, .sqrt, str, ValueError, factorial, Decimal, Decimal, factorial, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\collatz_sequence.py","","collatz_sequence","Generate the Collatz sequence starting at n. >>> tuple(collatz_sequence(2.1)) Traceback (most recent call last):     ... Exception: Sequence only defined for positive integers >>> tuple(collatz_sequence(0)) Traceback (most recent call last):     ... Exception: Sequence only defined for positive integers >>> tuple(collatz_sequence(4)) (4, 2, 1) >>> tuple(collatz_sequence(11)) (11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1) >>> tuple(collatz_sequence(31))     # doctest: +NORMALIZE_WHITESPACE (31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1) >>> tuple(collatz_sequence(43))     # doctest: +NORMALIZE_WHITESPACE (43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)","Exception, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\collatz_sequence.py","","main","","int, tuple, print, print, input, collatz_sequence, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\combinations.py","","combinations","Returns the number of different combinations of k length which can be made from n values, where n >= k.  Examples: >>> combinations(10,5) 252  >>> combinations(6,3) 20  >>> combinations(20,5) 15504  >>> combinations(52, 5) 2598960  >>> combinations(0, 0) 1  >>> combinations(-4, -5) ... Traceback (most recent call last): ValueError: Please enter positive integers for n and k where n >= k","range, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\continued_fraction.py","","continued_fraction",":param num: Fraction of the number whose continued fractions to be found. Use Fraction(str(number)) for more accurate results due to float inaccuracies.  :return: The continued fraction of rational number. It is the all commas in the (n + 1)-tuple notation.  >>> continued_fraction(Fraction(2)) [2] >>> continued_fraction(Fraction(""3.245"")) [3, 4, 12, 4] >>> continued_fraction(Fraction(""2.25"")) [2, 4] >>> continued_fraction(1/Fraction(""2.25"")) [0, 2, 4] >>> continued_fraction(Fraction(""415/93"")) [4, 2, 6, 7] >>> continued_fraction(Fraction(0)) [0] >>> continued_fraction(Fraction(0.75)) [0, 1, 3] >>> continued_fraction(Fraction(""-2.25""))    # -2.25 = -3 + 0.75 [-3, 1, 3]","num.as_integer_ratio, floor, continued_fraction_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\decimal_isolate.py","","decimal_isolate","Isolates the decimal part of a number. If digitAmount > 0 round to that decimal place, else print the entire decimal. >>> decimal_isolate(1.53, 0) 0.53 >>> decimal_isolate(35.345, 1) 0.3 >>> decimal_isolate(35.345, 2) 0.34 >>> decimal_isolate(35.345, 3) 0.345 >>> decimal_isolate(-14.789, 3) -0.789 >>> decimal_isolate(0, 2) 0 >>> decimal_isolate(-14.123, 1) -0.1 >>> decimal_isolate(-14.123, 2) -0.12 >>> decimal_isolate(-14.123, 3) -0.123","round, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\decimal_to_fraction.py","","decimal_to_fraction","Return a decimal number in its simplest fraction form >>> decimal_to_fraction(2) (2, 1) >>> decimal_to_fraction(89.) (89, 1) >>> decimal_to_fraction(""67"") (67, 1) >>> decimal_to_fraction(""45.0"") (45, 1) >>> decimal_to_fraction(1.5) (3, 2) >>> decimal_to_fraction(""6.25"") (25, 4) >>> decimal_to_fraction(""78td"") Traceback (most recent call last): ValueError: Please enter a valid number >>> decimal_to_fraction(0) (0, 1) >>> decimal_to_fraction(-2.5) (-5, 2) >>> decimal_to_fraction(0.125) (1, 8) >>> decimal_to_fraction(1000000.25) (4000001, 4) >>> decimal_to_fraction(1.3333) (13333, 10000) >>> decimal_to_fraction(""1.23e2"") (123, 1) >>> decimal_to_fraction(""0.500"") (1, 2)","float, int, len, int, ValueError, int, .split, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dodecahedron.py","","dodecahedron_surface_area","Calculates the surface area of a regular dodecahedron a = 3 * ((25 + 10 * (5** (1 / 2))) ** (1 / 2 )) * (e**2) where: a --> is the area of the dodecahedron e --> is the length of the edge reference-->""Dodecahedron"" Study.com <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>  :param edge: length of the edge of the dodecahedron :type edge: float :return: the surface area of the dodecahedron as a float   Tests: >>> dodecahedron_surface_area(5) 516.1432201766901 >>> dodecahedron_surface_area(10) 2064.5728807067603 >>> dodecahedron_surface_area(-1) Traceback (most recent call last):   ... ValueError: Length must be a positive.","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dodecahedron.py","","dodecahedron_volume","Calculates the volume of a regular dodecahedron v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3) where: v --> is the volume of the dodecahedron e --> is the length of the edge reference-->""Dodecahedron"" Study.com <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>  :param edge: length of the edge of the dodecahedron :type edge: float :return: the volume of the dodecahedron as a float  Tests: >>> dodecahedron_volume(5) 957.8898700780791 >>> dodecahedron_volume(10) 7663.118960624633 >>> dodecahedron_volume(-1) Traceback (most recent call last):   ... ValueError: Length must be a positive.","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\double_factorial.py","","double_factorial_recursive","Compute double factorial using recursive method. Recursion can be costly for large numbers.  To learn about the theory behind this algorithm: https://en.wikipedia.org/wiki/Double_factorial  >>> from math import prod >>> all(double_factorial_recursive(i) == prod(range(i, 0, -2)) for i in range(20)) True >>> double_factorial_recursive(0.1) Traceback (most recent call last):     ... ValueError: double_factorial_recursive() only accepts integral values >>> double_factorial_recursive(-1) Traceback (most recent call last):     ... ValueError: double_factorial_recursive() not defined for negative values","isinstance, ValueError, ValueError, double_factorial_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\double_factorial.py","","double_factorial_iterative","Compute double factorial using iterative method.  To learn about the theory behind this algorithm: https://en.wikipedia.org/wiki/Double_factorial  >>> from math import prod >>> all(double_factorial_iterative(i) == prod(range(i, 0, -2)) for i in range(20)) True >>> double_factorial_iterative(0.1) Traceback (most recent call last):     ... ValueError: double_factorial_iterative() only accepts integral values >>> double_factorial_iterative(-1) Traceback (most recent call last):     ... ValueError: double_factorial_iterative() not defined for negative values","range, isinstance, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","Dual","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","differentiate",">>> differentiate(lambda x: x**2, 2, 2) 2 >>> differentiate(lambda x: x**2 * x**4, 9, 2) 196830 >>> differentiate(lambda y: 0.5 * (y + 3) ** 6, 3.5, 4) 7605.0 >>> differentiate(lambda y: y ** 2, 4, 3) 0 >>> differentiate(8, 8, 8) Traceback (most recent call last):     ... ValueError: differentiate() requires a function as input for func >>> differentiate(lambda x: x **2, """", 1) Traceback (most recent call last):     ... ValueError: differentiate() requires a float as input for position >>> differentiate(lambda x: x**2, 3, """") Traceback (most recent call last):     ... ValueError: differentiate() requires an int as input for order","Dual, func, callable, ValueError, isinstance, ValueError, isinstance, ValueError, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__init__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__repr__","",".join, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","reduce","","self.duals.copy, Dual, cur.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__add__","","self.duals.copy, other.duals.copy, range, Dual, isinstance, Dual, len, len, o_dual.extend, len, new_duals.append, len, len, s_dual.extend, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__sub__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__mul__","","enumerate, range, range, Dual, isinstance, Dual, enumerate, len, len, new_duals.append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__truediv__","","isinstance, Dual, new_duals.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__floordiv__","","isinstance, Dual, new_duals.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","__pow__","","range, isinstance, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\dual_number_automatic_differentiation.py","","f","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\entropy.py","","calculate_prob","This method takes path and two dict as argument and than calculates entropy of them. :param dict: :param dict: :return: Prints 1) Entropy of information based on 1 alphabet 2) Entropy of information based on couples of 2 alphabet 3) print Entropy of H(X n|Xn-1)  Text from random books. Also, random quotes. >>> text = (""Behind Winston's back the voice "" ...         ""from the telescreen was still "" ...         ""babbling and the overfulfilment"") >>> calculate_prob(text) 4.0 6.0 2.0  >>> text = (""The Ministry of TruthMinitrue, in Newspeak [Newspeak was the official"" ...         ""face in elegant lettering, the three"") >>> calculate_prob(text) 4.0 5.0 1.0 >>> text = (""Had repulsive dashwoods suspicion sincerity but advantage now him. "" ...         ""Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. "" ...         ""You greatest jointure saw horrible. He private he on be imagine "" ...         ""suppose. Fertile beloved evident through no service elderly is. Blind "" ...         ""there if every no so at. Own neglected you preferred way sincerity "" ...         ""delivered his attempted. To of message cottage windows do besides "" ...         ""against uncivil.  Delightful unreserved impossible few estimating "" ...         ""men favourable see entreaties. She propriety immediate was improving. "" ...         ""He or entrance humoured likewise moderate. Much nor game son say "" ...         ""feel. Fat make met can must form into gate. Me we offending prevailed "" ...         ""discovery."") >>> calculate_prob(text) 4.0 7.0 3.0","analyze_text, list, sum, print, sum, print, print, single_char_strings.values, two_char_strings.values, math.log2, round, round, round, int, math.log2"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\entropy.py","","analyze_text","Convert text input into two dicts of counts. The first dictionary stores the frequency of single character strings. The second dictionary stores the frequency of two character strings.","Counter, Counter, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\entropy.py","","main","","doctest.testmod"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\euclidean_distance.py","","euclidean_distance","Calculate the distance between the two endpoints of two vectors. A vector is defined as a list, tuple, or numpy 1D array. >>> float(euclidean_distance((0, 0), (2, 2))) 2.8284271247461903 >>> float(euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2]))) 3.4641016151377544 >>> float(euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8]))) 8.0 >>> float(euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8])) 8.0","np.sqrt, np.sum, np.asarray, np.asarray"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\euclidean_distance.py","","euclidean_distance_no_np","Calculate the distance between the two endpoints of two vectors without numpy. A vector is defined as a list, tuple, or numpy 1D array. >>> euclidean_distance_no_np((0, 0), (2, 2)) 2.8284271247461903 >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8]) 8.0","sum, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\euclidean_distance.py","","benchmark","Benchmarks","print, print, print, print, timeit, timeit, globals, globals"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\eulers_totient.py","","totient",">>> n = 10 >>> totient_calculation = totient(n) >>> for i in range(1, n): ...     print(f""{i} has {totient_calculation[i]} relative primes."") 1 has 0 relative primes. 2 has 1 relative primes. 3 has 2 relative primes. 4 has 2 relative primes. 5 has 4 relative primes. 6 has 2 relative primes. 7 has 6 relative primes. 8 has 4 relative primes. 9 has 6 relative primes.","range, range, range, range, primes.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\euler_method.py","","explicit_euler","Calculate numeric solution at each step to an ODE using Euler's Method  For reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.  Args:     ode_func (Callable):  The ordinary differential equation         as a function of x and y.     y0 (float): The initial value for y.     x0 (float): The initial value for x.     step_size (float): The increment value for x.     x_end (float): The final value of x to be calculated.  Returns:     np.ndarray: Solution of y for every step in x.  >>> # the exact solution is math.exp(x) >>> def f(x, y): ...     return y >>> y0 = 1 >>> y = explicit_euler(f, y0, 0.0, 0.01, 5) >>> float(y[-1]) 144.77277243257308","int, np.zeros, range, np.ceil, ode_func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\euler_modified.py","","euler_modified","Calculate solution at each step to an ODE using Euler's Modified Method The Euler Method is straightforward to implement, but can't give accurate solutions. So, some changes were proposed to improve accuracy.  https://en.wikipedia.org/wiki/Euler_method  Arguments: ode_func -- The ode as a function of x and y y0 -- the initial value for y x0 -- the initial value for x stepsize -- the increment value for x x_end -- the end value for x  >>> # the exact solution is math.exp(x) >>> def f1(x, y): ...     return -2*x*(y**2) >>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0) >>> float(y[-1]) 0.503338255442106 >>> import math >>> def f2(x, y): ...     return -2*y + (x**3)*math.exp(-2*x) >>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3) >>> float(y[-1]) 0.5525976431951775","int, np.zeros, range, np.ceil, ode_func, ode_func, ode_func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\extended_euclidean_algorithm.py","","extended_euclidean_algorithm","Extended Euclidean Algorithm.  Finds 2 numbers a and b such that it satisfies the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)  >>> extended_euclidean_algorithm(1, 24) (1, 0)  >>> extended_euclidean_algorithm(8, 14) (2, -1)  >>> extended_euclidean_algorithm(240, 46) (-9, 47)  >>> extended_euclidean_algorithm(1, -4) (1, 0)  >>> extended_euclidean_algorithm(-2, -4) (-1, 0)  >>> extended_euclidean_algorithm(0, -4) (0, -1)  >>> extended_euclidean_algorithm(2, 0) (1, 0)","abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\extended_euclidean_algorithm.py","","main","Call Extended Euclidean Algorithm.","int, int, print, len, print, extended_euclidean_algorithm"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\factorial.py","","factorial","Calculate the factorial of specified number (n!).  >>> import math >>> all(factorial(i) == math.factorial(i) for i in range(20)) True >>> factorial(0.1) Traceback (most recent call last):     ... ValueError: factorial() only accepts integral values >>> factorial(-1) Traceback (most recent call last):     ... ValueError: factorial() not defined for negative values >>> factorial(1) 1 >>> factorial(6) 720 >>> factorial(0) 1","range, int, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\factorial.py","","factorial_recursive","Calculate the factorial of a positive integer https://en.wikipedia.org/wiki/Factorial  >>> import math >>> all(factorial(i) == math.factorial(i) for i in range(20)) True >>> factorial(0.1) Traceback (most recent call last):     ... ValueError: factorial() only accepts integral values >>> factorial(-1) Traceback (most recent call last):     ... ValueError: factorial() not defined for negative values","isinstance, ValueError, ValueError, factorial_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\factors.py","","factors_of_a_number",">>> factors_of_a_number(1) [1] >>> factors_of_a_number(5) [1, 5] >>> factors_of_a_number(24) [1, 2, 3, 4, 6, 8, 12, 24] >>> factors_of_a_number(-24) []","facs.append, facs.append, range, facs.sort, int, facs.append, sqrt, facs.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fast_inverse_sqrt.py","","fast_inverse_sqrt","Compute the fast inverse square root of a floating-point number using the famous Quake III algorithm.  :param float number: Input number for which to calculate the inverse square root. :return float: The fast inverse square root of the input number.  Example: >>> fast_inverse_sqrt(10) 0.3156857923527257 >>> fast_inverse_sqrt(4) 0.49915357479239103 >>> fast_inverse_sqrt(4.1) 0.4932849504615651 >>> fast_inverse_sqrt(0) Traceback (most recent call last):     ... ValueError: Input must be a positive number. >>> fast_inverse_sqrt(-1) Traceback (most recent call last):     ... ValueError: Input must be a positive number. >>> from math import isclose, sqrt >>> all(isclose(fast_inverse_sqrt(i), 1 / sqrt(i), rel_tol=0.00132) ...     for i in range(50, 60)) True","ValueError, struct.unpack, struct.unpack, struct.pack, struct.pack"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fermat_little_theorem.py","","binary_exponentiation","","binary_exponentiation, binary_exponentiation"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","time_func","Times the execution of a function with parameters","time, func, time, int, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_iterative_yield","Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield >>> list(fib_iterative_yield(0)) [0] >>> tuple(fib_iterative_yield(1)) (0, 1) >>> tuple(fib_iterative_yield(5)) (0, 1, 1, 2, 3, 5) >>> tuple(fib_iterative_yield(10)) (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55) >>> tuple(fib_iterative_yield(-1)) Traceback (most recent call last):     ... ValueError: n is negative","range, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_iterative","Calculates the first n (0-indexed) Fibonacci numbers using iteration >>> fib_iterative(0) [0] >>> fib_iterative(1) [0, 1] >>> fib_iterative(5) [0, 1, 1, 2, 3, 5] >>> fib_iterative(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last):     ... ValueError: n is negative","range, ValueError, fib.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_recursive","Calculates the first n (0-indexed) Fibonacci numbers using recursion >>> fib_iterative(0) [0] >>> fib_iterative(1) [0, 1] >>> fib_iterative(5) [0, 1, 1, 2, 3, 5] >>> fib_iterative(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last):     ... ValueError: n is negative","ValueError, fib_recursive_term, ValueError, fib_recursive_term, fib_recursive_term, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_recursive_cached","Calculates the first n (0-indexed) Fibonacci numbers using recursion >>> fib_iterative(0) [0] >>> fib_iterative(1) [0, 1] >>> fib_iterative(5) [0, 1, 1, 2, 3, 5] >>> fib_iterative(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last):     ... ValueError: n is negative","ValueError, fib_recursive_term, ValueError, fib_recursive_term, fib_recursive_term, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_memoization","Calculates the first n (0-indexed) Fibonacci numbers using memoization >>> fib_memoization(0) [0] >>> fib_memoization(1) [0, 1] >>> fib_memoization(5) [0, 1, 1, 2, 3, 5] >>> fib_memoization(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_iterative(-1) Traceback (most recent call last):     ... ValueError: n is negative","ValueError, rec_fn_memoized, rec_fn_memoized, rec_fn_memoized, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_binet","Calculates the first n (0-indexed) Fibonacci numbers using a simplified form of Binet's formula: https://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding  NOTE 1: this function diverges from fib_iterative at around n = 71, likely due to compounding floating-point arithmetic errors  NOTE 2: this function doesn't accept n >= 1475 because it overflows thereafter due to the size limitations of Python floats >>> fib_binet(0) [0] >>> fib_binet(1) [0, 1] >>> fib_binet(5) [0, 1, 1, 2, 3, 5] >>> fib_binet(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> fib_binet(-1) Traceback (most recent call last):     ... ValueError: n is negative >>> fib_binet(1475) Traceback (most recent call last):     ... ValueError: n is too large","sqrt, ValueError, ValueError, round, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","matrix_pow_np","Raises a matrix to the power of 'power' using binary exponentiation.  Args:     m: Matrix as a numpy array.     power: The power to which the matrix is to be raised.  Returns:     The matrix raised to the power.  Raises:     ValueError: If power is negative.  >>> m = np.array([[1, 1], [1, 0]], dtype=int) >>> matrix_pow_np(m, 0)  # Identity matrix when raised to the power of 0 array([[1, 0],        [0, 1]])  >>> matrix_pow_np(m, 1)  # Same matrix when raised to the power of 1 array([[1, 1],        [1, 0]])  >>> matrix_pow_np(m, 5) array([[8, 5],        [5, 3]])  >>> matrix_pow_np(m, -1) Traceback (most recent call last):     ... ValueError: power is negative","np.array, ValueError, np.dot, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_matrix_np","Calculates the n-th Fibonacci number using matrix exponentiation. https://www.nayuki.io/page/fast-fibonacci-algorithms#:~:text= Summary:%20The%20two%20fast%20Fibonacci%20algorithms%20are%20matrix  Args:     n: Fibonacci sequence index  Returns:     The n-th Fibonacci number.  Raises:     ValueError: If n is negative.  >>> fib_matrix_np(0) 0 >>> fib_matrix_np(1) 1 >>> fib_matrix_np(5) 5 >>> fib_matrix_np(10) 55 >>> fib_matrix_np(-1) Traceback (most recent call last):     ... ValueError: n is negative","np.array, matrix_pow_np, int, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_recursive_term","Calculates the i-th (0-indexed) Fibonacci number using recursion >>> fib_recursive_term(0) 0 >>> fib_recursive_term(1) 1 >>> fib_recursive_term(5) 5 >>> fib_recursive_term(10) 55 >>> fib_recursive_term(-1) Traceback (most recent call last):     ... Exception: n is negative","ValueError, fib_recursive_term, fib_recursive_term"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","fib_recursive_term","Calculates the i-th (0-indexed) Fibonacci number using recursion","ValueError, fib_recursive_term, fib_recursive_term"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\fibonacci.py","","rec_fn_memoized","","rec_fn_memoized, rec_fn_memoized"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\find_max.py","","find_max_iterative",">>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]): ...     find_max_iterative(nums) == max(nums) True True True True >>> find_max_iterative([2, 4, 9, 7, 19, 94, 5]) 94 >>> find_max_iterative([]) Traceback (most recent call last):     ... ValueError: find_max_iterative() arg is an empty sequence","len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\find_max.py","","find_max_recursive","find max value in list :param nums: contains elements :param left: index of first element :param right: index of last element :return: max in nums  >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]): ...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums) True True True True >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] >>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums) True >>> find_max_recursive([], 0, 0) Traceback (most recent call last):     ... ValueError: find_max_recursive() arg is an empty sequence >>> find_max_recursive(nums, 0, len(nums)) == max(nums) Traceback (most recent call last):     ... IndexError: list index out of range >>> find_max_recursive(nums, -len(nums), -1) == max(nums) True >>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums) Traceback (most recent call last):     ... IndexError: list index out of range","find_max_recursive, find_max_recursive, len, ValueError, IndexError, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\find_min.py","","find_min_iterative","Find Minimum Number in a List :param nums: contains elements :return: min number in list  >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]): ...     find_min_iterative(nums) == min(nums) True True True True >>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56]) -56 >>> find_min_iterative([]) Traceback (most recent call last):     ... ValueError: find_min_iterative() arg is an empty sequence","len, ValueError, min"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\find_min.py","","find_min_recursive","find min value in list :param nums: contains elements :param left: index of first element :param right: index of last element :return: min in nums  >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]): ...     find_min_recursive(nums, 0, len(nums) - 1) == min(nums) True True True True >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] >>> find_min_recursive(nums, 0, len(nums) - 1) == min(nums) True >>> find_min_recursive([], 0, 0) Traceback (most recent call last):     ... ValueError: find_min_recursive() arg is an empty sequence >>> find_min_recursive(nums, 0, len(nums)) == min(nums) Traceback (most recent call last):     ... IndexError: list index out of range >>> find_min_recursive(nums, -len(nums), -1) == min(nums) True >>> find_min_recursive(nums, -len(nums) - 1, -1) == min(nums) Traceback (most recent call last):     ... IndexError: list index out of range","find_min_recursive, find_min_recursive, len, ValueError, IndexError, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\floor.py","","floor","Return the floor of x as an Integral. :param x: the number :return: the largest integer <= x. >>> import math >>> all(floor(n) == math.floor(n) for n ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000)) True","int, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\gamma.py","","gamma_iterative","Calculates the value of Gamma function of num where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).  >>> gamma_iterative(-1) Traceback (most recent call last):     ... ValueError: math domain error >>> gamma_iterative(0) Traceback (most recent call last):     ... ValueError: math domain error >>> gamma_iterative(9) 40320.0 >>> from math import gamma as math_gamma >>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001 ...     for i in range(1, 50)) True >>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001 Traceback (most recent call last):     ... ValueError: math domain error >>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001 True","ValueError, quad"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\gamma.py","","integrand","","math.pow, math.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\gamma.py","","gamma_recursive","Calculates the value of Gamma function of num where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...). Implemented using recursion Examples: >>> from math import isclose, gamma as math_gamma >>> gamma_recursive(0.5) 1.7724538509055159 >>> gamma_recursive(1) 1.0 >>> gamma_recursive(2) 1.0 >>> gamma_recursive(3.5) 3.3233509704478426 >>> gamma_recursive(171.5) 9.483367566824795e+307 >>> all(isclose(gamma_recursive(num), math_gamma(num)) ...     for num in (0.5, 2, 3.5, 171.5)) True >>> gamma_recursive(0) Traceback (most recent call last):     ... ValueError: math domain error >>> gamma_recursive(-1.1) Traceback (most recent call last):     ... ValueError: math domain error >>> gamma_recursive(-4) Traceback (most recent call last):     ... ValueError: math domain error >>> gamma_recursive(172) Traceback (most recent call last):     ... OverflowError: math range error >>> gamma_recursive(1.1) Traceback (most recent call last):     ... NotImplementedError: num must be an integer or a half-integer","ValueError, OverflowError, NotImplementedError, int, math.sqrt, gamma_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\gaussian.py","","gaussian",">>> float(gaussian(1)) 0.24197072451914337  >>> float(gaussian(24)) 3.342714441794458e-126  >>> float(gaussian(1, 4, 2)) 0.06475879783294587  >>> float(gaussian(1, 5, 3)) 0.05467002489199788  Supports NumPy Arrays Use numpy.meshgrid with this to generate gaussian blur on images. >>> import numpy as np >>> x = np.arange(15) >>> gaussian(x) array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,        1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,        5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,        2.14638374e-32, 7.99882776e-38, 1.09660656e-43])  >>> float(gaussian(15)) 5.530709549844416e-50  >>> gaussian([1,2, 'string']) Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for -: 'list' and 'float'  >>> gaussian('hello world') Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for -: 'str' and 'float'  >>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last):     ... OverflowError: (34, 'Result too large')  >>> float(gaussian(10**-326)) 0.3989422804014327  >>> float(gaussian(2523, mu=234234, sigma=3425)) 0.0","exp, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\gcd_of_n_numbers.py","","get_factors","this is a recursive function for get all factors of number >>> get_factors(45) Counter({3: 2, 5: 1}) >>> get_factors(2520) Counter({2: 3, 3: 2, 5: 1, 7: 1}) >>> get_factors(23) Counter({23: 1}) >>> get_factors(0) Traceback (most recent call last):     ... TypeError: number must be integer and greater than zero >>> get_factors(-1) Traceback (most recent call last):     ... TypeError: number must be integer and greater than zero >>> get_factors(1.5) Traceback (most recent call last):     ... TypeError: number must be integer and greater than zero  factor can be all numbers from 2 to number that we check if number % factor == 0 if it is equal to zero, we check again with number // factor else we increase factor by one","get_factors, Counter, get_factors, Counter, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\gcd_of_n_numbers.py","","get_greatest_common_divisor","get gcd of n numbers: >>> get_greatest_common_divisor(18, 45) 9 >>> get_greatest_common_divisor(23, 37) 1 >>> get_greatest_common_divisor(2520, 8350) 10 >>> get_greatest_common_divisor(-10, 20) Traceback (most recent call last):     ... Exception: numbers must be integer and greater than zero >>> get_greatest_common_divisor(1.5, 2) Traceback (most recent call last):     ... Exception: numbers must be integer and greater than zero >>> get_greatest_common_divisor(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 1 >>> get_greatest_common_divisor(""1"", 2, 3, 4, 5, 6, 7, 8, 9, 10) Traceback (most recent call last):     ... Exception: numbers must be integer and greater than zero","map, Exception, same_factors.items"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\geometric_mean.py","","compute_geometric_mean","Return the geometric mean of the argument numbers. >>> compute_geometric_mean(2,8) 4.0 >>> compute_geometric_mean('a', 4) Traceback (most recent call last):     ... TypeError: Not a Number >>> compute_geometric_mean(5, 125) 25.0 >>> compute_geometric_mean(1, 0) 0.0 >>> compute_geometric_mean(1, 5, 25, 5) 5.0 >>> compute_geometric_mean(2, -2) Traceback (most recent call last):     ... ArithmeticError: Cannot Compute Geometric Mean for these numbers. >>> compute_geometric_mean(-5, 25, 1) -5.0","float, ArithmeticError, abs, round, TypeError, len, len, isinstance, isinstance, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\germain_primes.py","","is_germain_prime","Checks if input number and 2*number + 1 are prime.  >>> is_germain_prime(3) True >>> is_germain_prime(11) True >>> is_germain_prime(4) False >>> is_germain_prime(23) True >>> is_germain_prime(13) False >>> is_germain_prime(20) False >>> is_germain_prime('abc') Traceback (most recent call last):     ... TypeError: Input value must be a positive integer. Input value: abc","TypeError, is_prime, is_prime, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\germain_primes.py","","is_safe_prime","Checks if input number and (number - 1)/2 are prime. The smallest safe prime is 5, with the Germain prime is 2.  >>> is_safe_prime(5) True >>> is_safe_prime(11) True >>> is_safe_prime(1) False >>> is_safe_prime(2) False >>> is_safe_prime(3) False >>> is_safe_prime(47) True >>> is_safe_prime('abc') Traceback (most recent call last):     ... TypeError: Input value must be a positive integer. Input value: abc","TypeError, is_prime, is_prime, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\greatest_common_divisor.py","","greatest_common_divisor","Calculate Greatest Common Divisor (GCD). >>> greatest_common_divisor(24, 40) 8 >>> greatest_common_divisor(1, 1) 1 >>> greatest_common_divisor(1, 800) 1 >>> greatest_common_divisor(11, 37) 1 >>> greatest_common_divisor(3, 5) 1 >>> greatest_common_divisor(16, 4) 4 >>> greatest_common_divisor(-3, 9) 3 >>> greatest_common_divisor(9, -3) 3 >>> greatest_common_divisor(3, -9) 3 >>> greatest_common_divisor(-3, -9) 3","abs, greatest_common_divisor"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\greatest_common_divisor.py","","gcd_by_iterative","Below method is more memory efficient because it does not create additional stack frames for recursive functions calls (as done in the above method). >>> gcd_by_iterative(24, 40) 8 >>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40) True >>> gcd_by_iterative(-3, -9) 3 >>> gcd_by_iterative(3, -9) 3 >>> gcd_by_iterative(1, -800) 1 >>> gcd_by_iterative(11, 37) 1","abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\greatest_common_divisor.py","","main","Call Greatest Common Divisor function.",".split, int, int, print, print, print, input, greatest_common_divisor, gcd_by_iterative"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\hardy_ramanujanalgo.py","","exact_prime_factor_count",">>> exact_prime_factor_count(51242183) 3","int, int, math.sqrt, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\integer_square_root.py","","integer_square_root","Returns the integer square root of a non-negative integer num. Args:     num: A non-negative integer. Returns:     The integer square root of num. Raises:     ValueError: If num is not an integer or is negative. >>> [integer_square_root(i) for i in range(18)] [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4] >>> integer_square_root(625) 25 >>> integer_square_root(2_147_483_647) 46340 >>> from math import isqrt >>> all(integer_square_root(i) == isqrt(i) for i in range(20)) True >>> integer_square_root(-1) Traceback (most recent call last):     ... ValueError: num must be non-negative integer >>> integer_square_root(1.5) Traceback (most recent call last):     ... ValueError: num must be non-negative integer >>> integer_square_root(""0"") Traceback (most recent call last):     ... ValueError: num must be non-negative integer","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\interquartile_range.py","","find_median","This is the implementation of the median. :param nums: The list of numeric nums :return: Median of the list >>> find_median(nums=([1, 2, 2, 3, 4])) 2 >>> find_median(nums=([1, 2, 2, 3, 4, 4])) 2.5 >>> find_median(nums=([-1, 2, 0, 3, 4, -4])) 1.5 >>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4])) 2.65","divmod, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\interquartile_range.py","","interquartile_range","Return the interquartile range for a list of numeric values. :param nums: The list of numeric values. :return: interquartile range  >>> interquartile_range(nums=[4, 1, 2, 3, 2]) 2.0 >>> interquartile_range(nums = [-2, -7, -10, 9, 8, 4, -67, 45]) 17.0 >>> interquartile_range(nums = [-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1]) 17.2 >>> interquartile_range(nums = [0, 0, 0, 0, 0]) 0.0 >>> interquartile_range(nums=[]) Traceback (most recent call last): ... ValueError: The list is empty. Provide a non-empty list.","nums.sort, len, divmod, find_median, sum, find_median, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\is_int_palindrome.py","","is_int_palindrome","Returns whether `num` is a palindrome or not (see for reference https://en.wikipedia.org/wiki/Palindromic_number).  >>> is_int_palindrome(-121) False >>> is_int_palindrome(0) True >>> is_int_palindrome(10) False >>> is_int_palindrome(11) True >>> is_int_palindrome(101) True >>> is_int_palindrome(120) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\is_ip_v4_address_valid.py","","is_ip_v4_address_valid","print ""Valid IP address"" If IP is valid. or print ""Invalid IP address"" If IP is invalid.  >>> is_ip_v4_address_valid(""192.168.0.23"") True  >>> is_ip_v4_address_valid(""192.256.15.8"") False  >>> is_ip_v4_address_valid(""172.100.0.8"") True  >>> is_ip_v4_address_valid(""255.256.0.256"") False  >>> is_ip_v4_address_valid(""1.2.33333333.4"") False  >>> is_ip_v4_address_valid(""1.2.-3.4"") False  >>> is_ip_v4_address_valid(""1.2.3"") False  >>> is_ip_v4_address_valid(""1.2.3.4.5"") False  >>> is_ip_v4_address_valid(""1.2.A.4"") False  >>> is_ip_v4_address_valid(""0.0.0.0"") True  >>> is_ip_v4_address_valid(""1.2.3."") False  >>> is_ip_v4_address_valid(""1.2.3.05"") False","ip.split, len, int, octet.isdigit, len, len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\is_square_free.py","","is_square_free","# doctest: +NORMALIZE_WHITESPACE This functions takes a list of prime factors as input. returns True if the factors are square free. >>> is_square_free([1, 1, 2, 3, 4]) False  These are wrong but should return some value it simply checks for repetition in the numbers. >>> is_square_free([1, 3, 4, 'sd', 0.0]) True  >>> is_square_free([1, 0.5, 2, 0.0]) True >>> is_square_free([1, 2, 2, 5]) False >>> is_square_free('asd') True >>> is_square_free(24) Traceback (most recent call last):     ... TypeError: 'int' object is not iterable","len, len, set"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\jaccard_similarity.py","","jaccard_similarity","Finds the jaccard similarity between two sets. Essentially, its intersection over union.  The alternative way to calculate this is to take union as sum of the number of items in the two sets. This will lead to jaccard similarity of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]  Parameters:     :set_a (set,list,tuple): A non-empty set/list     :set_b (set,list,tuple): A non-empty set/list     :alternativeUnion (boolean): If True, use sum of number of     items as union  Output:     (float) The jaccard similarity between the two sets.  Examples: >>> set_a = {'a', 'b', 'c', 'd', 'e'} >>> set_b = {'c', 'd', 'e', 'f', 'h', 'i'} >>> jaccard_similarity(set_a, set_b) 0.375 >>> jaccard_similarity(set_a, set_a) 1.0 >>> jaccard_similarity(set_a, set_a, True) 0.5 >>> set_a = ['a', 'b', 'c', 'd', 'e'] >>> set_b = ('c', 'd', 'e', 'f', 'h', 'i') >>> jaccard_similarity(set_a, set_b) 0.375 >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i') >>> set_b = ['a', 'b', 'c', 'd', 'e'] >>> jaccard_similarity(set_a, set_b) 0.375 >>> set_a = ('c', 'd', 'e', 'f', 'h', 'i') >>> set_b = ['a', 'b', 'c', 'd'] >>> jaccard_similarity(set_a, set_b, True) 0.2 >>> set_a = {'a', 'b'} >>> set_b = ['c', 'd'] >>> jaccard_similarity(set_a, set_b) Traceback (most recent call last):     ... ValueError: Set a and b must either both be sets or be either a list or a tuple.","ValueError, isinstance, isinstance, len, set_a.intersection, len, isinstance, isinstance, len, len, set_a.union, len, list, len, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\joint_probability_distribution.py","","joint_probability_distribution",">>> joint_distribution =  joint_probability_distribution( ...     [1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2] ... ) >>> from math import isclose >>> isclose(joint_distribution.pop((1, 8)), 0.14) True >>> joint_distribution {(1, -2): 0.21, (1, 5): 0.35, (2, -2): 0.09, (2, 5): 0.15, (2, 8): 0.06}","zip, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\joint_probability_distribution.py","","expectation",">>> from math import isclose >>> isclose(expectation([1, 2], [0.7, 0.3]), 1.3) True","sum, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\joint_probability_distribution.py","","variance",">>> from math import isclose >>> isclose(variance([1,2],[0.7,0.3]), 0.21) True","expectation, sum, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\joint_probability_distribution.py","","covariance",">>> covariance([1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2]) -2.7755575615628914e-17","expectation, expectation, sum, zip, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\joint_probability_distribution.py","","standard_deviation",">>> standard_deviation(0.21) 0.458257569495584",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\josephus_problem.py","","josephus_recursive","Solve the Josephus problem for num_people and a step_size recursively.  Args:     num_people: A positive integer representing the number of people.     step_size: A positive integer representing the step size for elimination.  Returns:     The position of the last person remaining.  Raises:     ValueError: If num_people or step_size is not a positive integer.  Examples:     >>> josephus_recursive(7, 3)     3     >>> josephus_recursive(10, 2)     4     >>> josephus_recursive(0, 2)     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.     >>> josephus_recursive(1.9, 2)     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.     >>> josephus_recursive(-2, 2)     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.     >>> josephus_recursive(7, 0)     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.     >>> josephus_recursive(7, -2)     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.     >>> josephus_recursive(1_000, 0.01)     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.     >>> josephus_recursive(""cat"", ""dog"")     Traceback (most recent call last):         ...     ValueError: num_people or step_size is not a positive integer.","ValueError, isinstance, isinstance, josephus_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\josephus_problem.py","","find_winner","Find the winner of the Josephus problem for num_people and a step_size.  Args:     num_people (int): Number of people.     step_size (int): Step size for elimination.  Returns:     int: The position of the last person remaining (1-based index).  Examples:     >>> find_winner(7, 3)     4     >>> find_winner(10, 2)     5","josephus_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\josephus_problem.py","","josephus_iterative","Solve the Josephus problem for num_people and a step_size iteratively.  Args:     num_people (int): The number of people in the circle.     step_size (int): The number of steps to take before eliminating someone.  Returns:     int: The position of the last person standing.  Examples:     >>> josephus_iterative(5, 2)     3     >>> josephus_iterative(7, 3)     4","list, range, len, circle.pop, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\juggler_sequence.py","","juggler_sequence",">>> juggler_sequence(0) Traceback (most recent call last):     ... ValueError: Input value of [number=0] must be a positive integer >>> juggler_sequence(1) [1] >>> juggler_sequence(2) [2, 1] >>> juggler_sequence(3) [3, 5, 11, 36, 6, 2, 1] >>> juggler_sequence(5) [5, 11, 36, 6, 2, 1] >>> juggler_sequence(10) [10, 3, 5, 11, 36, 6, 2, 1] >>> juggler_sequence(25) [25, 125, 1397, 52214, 228, 15, 58, 7, 18, 4, 2, 1] >>> juggler_sequence(6.0) Traceback (most recent call last):     ... TypeError: Input value of [number=6.0] must be an integer >>> juggler_sequence(-1) Traceback (most recent call last):     ... ValueError: Input value of [number=-1] must be a positive integer","isinstance, TypeError, ValueError, sequence.append, math.floor, math.floor, math.sqrt, math.sqrt, math.sqrt, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\karatsuba.py","","karatsuba",">>> karatsuba(15463, 23489) == 15463 * 23489 True >>> karatsuba(3, 9) == 3 * 9 True","max, divmod, divmod, karatsuba, karatsuba, karatsuba, len, len, len, len, str, str, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\karatsuba.py","","main","","print, karatsuba"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\kth_lexicographic_permutation.py","","kth_permutation","Finds k'th lexicographic permutation (in increasing order) of 0,1,2,...n-1 in O(n^2) time.  Examples: First permutation is always 0,1,2,...n >>> kth_permutation(0,5) [0, 1, 2, 3, 4]  The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3], [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3], [1,2,3,0], [1,3,0,2] >>> kth_permutation(10,4) [1, 3, 0, 2]","range, list, permutation.append, factorials.append, range, factorials.pop, divmod, permutation.append, elements.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\largest_of_very_large_numbers.py","","res","Reduces large number to a more manageable number >>> res(5, 7) 4.892790030352132 >>> res(0, 5) 0 >>> res(3, 0) 1 >>> res(-1, 5) Traceback (most recent call last): ... ValueError: expected a positive input","AssertionError, math.log10"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\least_common_multiple.py","","least_common_multiple_slow","Find the least common multiple of two numbers.  Learn more: https://en.wikipedia.org/wiki/Least_common_multiple  >>> least_common_multiple_slow(5, 2) 10 >>> least_common_multiple_slow(12, 76) 228",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\least_common_multiple.py","","least_common_multiple_fast","Find the least common multiple of two numbers. https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor >>> least_common_multiple_fast(5,2) 10 >>> least_common_multiple_fast(12,76) 228","greatest_common_divisor"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\least_common_multiple.py","","benchmark","","print, print, timeit, timeit"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\least_common_multiple.py","TestLeastCommonMultiple","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\least_common_multiple.py","","test_lcm_function","","enumerate, least_common_multiple_slow, least_common_multiple_fast, self.subTest"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\line_length.py","","line_length","Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases accuracy :return: a float representing the length of the curve  >>> def f(x): ...    return x >>> f""{line_length(f, 0, 1, 10):.6f}"" '1.414214'  >>> def f(x): ...    return 1 >>> f""{line_length(f, -5.5, 4.5):.6f}"" '10.000000'  >>> def f(x): ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10 >>> f""{line_length(f, 0.0, 10.0, 10000):.6f}"" '69.534930'","fnc, range, fnc, math.hypot"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\line_length.py","","f","","math.sin"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\liouville_lambda.py","","liouville_lambda","This functions takes an integer number as input. returns 1 if n has even number of prime factors and -1 otherwise. >>> liouville_lambda(10) 1 >>> liouville_lambda(11) -1 >>> liouville_lambda(0) Traceback (most recent call last):     ... ValueError: Input must be a positive integer >>> liouville_lambda(-1) Traceback (most recent call last):     ... ValueError: Input must be a positive integer >>> liouville_lambda(11.0) Traceback (most recent call last):     ... TypeError: Input value of [number=11.0] must be an integer","isinstance, TypeError, ValueError, len, prime_factors"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\lucas_lehmer_primality_test.py","","lucas_lehmer_test",">>> lucas_lehmer_test(p=7) True  >>> lucas_lehmer_test(p=11) False  # M_11 = 2^11 - 1 = 2047 = 23 * 89","range, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\lucas_series.py","","recursive_lucas_number","Returns the nth lucas number >>> recursive_lucas_number(1) 1 >>> recursive_lucas_number(20) 15127 >>> recursive_lucas_number(0) 2 >>> recursive_lucas_number(25) 167761 >>> recursive_lucas_number(-1.5) Traceback (most recent call last):     ... TypeError: recursive_lucas_number accepts only integer arguments.","isinstance, TypeError, recursive_lucas_number, recursive_lucas_number"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\lucas_series.py","","dynamic_lucas_number","Returns the nth lucas number >>> dynamic_lucas_number(1) 1 >>> dynamic_lucas_number(20) 15127 >>> dynamic_lucas_number(0) 2 >>> dynamic_lucas_number(25) 167761 >>> dynamic_lucas_number(-1.5) Traceback (most recent call last):     ... TypeError: dynamic_lucas_number accepts only integer arguments.","range, isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\maclaurin_series.py","","maclaurin_sin","Finds the maclaurin approximation of sin  :param theta: the angle to which sin is found :param accuracy: the degree of accuracy wanted minimum :return: the value of sine in radians   >>> from math import isclose, sin >>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25)) True >>> maclaurin_sin(10) -0.5440211108893691 >>> maclaurin_sin(-10) 0.5440211108893704 >>> maclaurin_sin(10, 15) -0.544021110889369 >>> maclaurin_sin(-10, 15) 0.5440211108893704 >>> maclaurin_sin(""10"") Traceback (most recent call last):     ... ValueError: maclaurin_sin() requires either an int or float for theta >>> maclaurin_sin(10, -30) Traceback (most recent call last):     ... ValueError: maclaurin_sin() requires a positive int for accuracy >>> maclaurin_sin(10, 30.5) Traceback (most recent call last):     ... ValueError: maclaurin_sin() requires a positive int for accuracy >>> maclaurin_sin(10, ""30"") Traceback (most recent call last):     ... ValueError: maclaurin_sin() requires a positive int for accuracy","float, sum, isinstance, ValueError, ValueError, isinstance, factorial, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\maclaurin_series.py","","maclaurin_cos","Finds the maclaurin approximation of cos  :param theta: the angle to which cos is found :param accuracy: the degree of accuracy wanted :return: the value of cosine in radians   >>> from math import isclose, cos >>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25)) True >>> maclaurin_cos(5) 0.2836621854632268 >>> maclaurin_cos(-5) 0.2836621854632265 >>> maclaurin_cos(10, 15) -0.8390715290764524 >>> maclaurin_cos(-10, 15) -0.8390715290764521 >>> maclaurin_cos(""10"") Traceback (most recent call last):     ... ValueError: maclaurin_cos() requires either an int or float for theta >>> maclaurin_cos(10, -30) Traceback (most recent call last):     ... ValueError: maclaurin_cos() requires a positive int for accuracy >>> maclaurin_cos(10, 30.5) Traceback (most recent call last):     ... ValueError: maclaurin_cos() requires a positive int for accuracy >>> maclaurin_cos(10, ""30"") Traceback (most recent call last):     ... ValueError: maclaurin_cos() requires a positive int for accuracy","float, sum, isinstance, ValueError, ValueError, isinstance, factorial, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\manhattan_distance.py","","manhattan_distance","Expectts two list of numbers representing two points in the same n-dimensional space  https://en.wikipedia.org/wiki/Taxicab_geometry  >>> manhattan_distance([1,1], [2,2]) 2.0 >>> manhattan_distance([1.5,1.5], [2,2]) 1.0 >>> manhattan_distance([1.5,1.5], [2.5,2]) 1.5 >>> manhattan_distance([-3, -3, -3], [0, 0, 0]) 9.0 >>> manhattan_distance([1,1], None) Traceback (most recent call last):     ... ValueError: Missing an input >>> manhattan_distance([1,1], [2, 2, 2]) Traceback (most recent call last):     ... ValueError: Both points must be in the same n-dimensional space >>> manhattan_distance([1,""one""], [2, 2, 2]) Traceback (most recent call last):     ... TypeError: Expected a list of numbers as input, found str >>> manhattan_distance(1, [2, 2, 2]) Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found int >>> manhattan_distance([1,1], ""not_a_list"") Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found str","_validate_point, _validate_point, float, len, len, ValueError, sum, abs, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\manhattan_distance.py","","_validate_point",">>> _validate_point(None) Traceback (most recent call last):      ... ValueError: Missing an input >>> _validate_point([1,""one""]) Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found str >>> _validate_point(1) Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found int >>> _validate_point(""not_a_list"") Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found str","isinstance, ValueError, TypeError, isinstance, TypeError, type, type"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\manhattan_distance.py","","manhattan_distance_one_liner","Version with one liner  >>> manhattan_distance_one_liner([1,1], [2,2]) 2.0 >>> manhattan_distance_one_liner([1.5,1.5], [2,2]) 1.0 >>> manhattan_distance_one_liner([1.5,1.5], [2.5,2]) 1.5 >>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0]) 9.0 >>> manhattan_distance_one_liner([1,1], None) Traceback (most recent call last):      ... ValueError: Missing an input >>> manhattan_distance_one_liner([1,1], [2, 2, 2]) Traceback (most recent call last):      ... ValueError: Both points must be in the same n-dimensional space >>> manhattan_distance_one_liner([1,""one""], [2, 2, 2]) Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found str >>> manhattan_distance_one_liner(1, [2, 2, 2]) Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found int >>> manhattan_distance_one_liner([1,1], ""not_a_list"") Traceback (most recent call last):      ... TypeError: Expected a list of numbers as input, found str","_validate_point, _validate_point, float, len, len, ValueError, sum, abs, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","Matrix","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","modular_exponentiation","","Matrix"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","fibonacci_with_matrix_exponentiation","Returns the nth number of the Fibonacci sequence that starts with f1 and f2 Uses the matrix exponentiation >>> fibonacci_with_matrix_exponentiation(1, 5, 6) 5 >>> fibonacci_with_matrix_exponentiation(2, 10, 11) 11 >>> fibonacci_with_matrix_exponentiation(13, 0, 1) 144 >>> fibonacci_with_matrix_exponentiation(10, 5, 9) 411 >>> fibonacci_with_matrix_exponentiation(9, 2, 3) 89","Matrix, modular_exponentiation"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","simple_fibonacci","Returns the nth number of the Fibonacci sequence that starts with f1 and f2 Uses the definition >>> simple_fibonacci(1, 5, 6) 5 >>> simple_fibonacci(2, 10, 11) 11 >>> simple_fibonacci(13, 0, 1) 144 >>> simple_fibonacci(10, 5, 9) 411 >>> simple_fibonacci(9, 2, 3) 89",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","matrix_exponentiation_time","","timeit.timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","simple_fibonacci_time","","timeit.timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","main","","matrix_exponentiation_time, simple_fibonacci_time"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","__init__","","isinstance, len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\matrix_exponentiation.py","","__mul__","","Matrix, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\max_sum_sliding_window.py","","max_sum_in_array","Returns the maximum sum of k consecutive elements >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20] >>> k = 4 >>> max_sum_in_array(arr, k) 24 >>> k = 10 >>> max_sum_in_array(arr,k) Traceback (most recent call last):     ... ValueError: Invalid Input >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2] >>> k = 4 >>> max_sum_in_array(arr, k) 27","sum, range, ValueError, max, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\minkowski_distance.py","","minkowski_distance","This function calculates the Minkowski distance for a given order between two n-dimensional points represented as lists. For the case of order = 1, the Minkowski distance degenerates to the Manhattan distance. For order = 2, the usual Euclidean distance is obtained.  https://en.wikipedia.org/wiki/Minkowski_distance  Note: due to floating point calculation errors the output of this function may be inaccurate.  >>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1) 2.0 >>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2) 8.0 >>> import numpy as np >>> bool(np.isclose(5.0, minkowski_distance([5.0], [0.0], 3))) True >>> minkowski_distance([1.0], [2.0], -1) Traceback (most recent call last):     ... ValueError: The order must be greater than or equal to 1. >>> minkowski_distance([1.0], [1.0, 2.0], 1) Traceback (most recent call last):     ... ValueError: Both points must have the same dimension.","ValueError, len, len, ValueError, sum, abs, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\mobius_function.py","","mobius","Mobius function >>> mobius(24) 0 >>> mobius(-1) 1 >>> mobius('asd') Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'str' >>> mobius(10**400) 0 >>> mobius(10**-400) 1 >>> mobius(-1424) 1 >>> mobius([1, '2', 2.0]) Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'list'","prime_factors, is_square_free, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_division.py","","modular_division","Modular Division : An efficient algorithm for dividing b by a modulo n.  GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )  Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should return an integer x such that 0xn-1, and  b/a=x(modn) (that is, b=ax(modn)).  Theorem: a has a multiplicative inverse modulo n iff gcd(a,n) = 1   This find x = b*a^(-1) mod n Uses ExtendedEuclid to find the inverse of a  >>> modular_division(4,8,5) 2  >>> modular_division(3,8,5) 1  >>> modular_division(4, 11, 5) 4","extended_gcd, greatest_common_divisor"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_division.py","","invert_modulo","This function find the inverses of a i.e., a^(-1)  >>> invert_modulo(2, 5) 3  >>> invert_modulo(8,7) 1","extended_euclid"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_division.py","","modular_division2","This function used the above inversion of a to find x = (b*a^(-1))mod n  >>> modular_division2(4,8,5) 2  >>> modular_division2(3,8,5) 1  >>> modular_division2(4, 11, 5) 4","invert_modulo"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_division.py","","extended_gcd","Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x and y, then d = gcd(a,b) >>> extended_gcd(10, 6) (2, -1, 2)  >>> extended_gcd(7, 5) (1, -2, 3)  ** extended_gcd function is used when d = gcd(a,b) is required in output","extended_gcd"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_division.py","","extended_euclid","Extended Euclid >>> extended_euclid(10, 6) (-1, 2)  >>> extended_euclid(7, 5) (-2, 3)","extended_euclid"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_division.py","","greatest_common_divisor","Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b Euclid's Algorithm  >>> greatest_common_divisor(7,5) 1  Note : In number theory, two integers a and b are said to be relatively prime,     mutually prime, or co-prime if the only positive integer (factor) that divides     both of them is 1  i.e., gcd(a,b) = 1.  >>> greatest_common_divisor(121, 11) 11",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_exponential.py","","modular_exponential",">>> modular_exponential(5, 0, 10) 1 >>> modular_exponential(2, 8, 7) 4 >>> modular_exponential(3, -2, 9) -1",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\modular_exponential.py","","main","Call Modular Exponential Function.","print, modular_exponential"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","pi_estimator","An implementation of the Monte Carlo method used to find pi. 1. Draw a 2x2 square centred at (0,0). 2. Inscribe a circle within the square. 3. For each iteration, place a dot anywhere in the square.    a. Record the number of dots within the circle. 4. After all the dots are placed, divide the dots in the circle by the total. 5. Multiply this value by 4 to get your estimate of pi. 6. Print the estimated and numpy value of pi","mean, print, print, print, sqrt, int, is_in_circle, range, abs, uniform, uniform"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","area_under_curve_estimator","An implementation of the Monte Carlo method to find area under    a single variable non-negative real-valued continuous function,    say f(x), where x lies within a continuous bounded interval,    say [min_value, max_value], where min_value and max_value are    finite numbers 1. Let x be a uniformly distributed random variable between min_value to    max_value 2. Expected value of f(x) =    (integrate f(x) from min_value to max_value)/(max_value - min_value) 3. Finding expected value of f(x):     a. Repeatedly draw x from uniform distribution     b. Evaluate f(x) at each of the drawn x values     c. Expected value = average of the function evaluations 4. Estimated value of integral = Expected value * (max_value - min_value) 5. Returns estimated value","mean, function_to_integrate, uniform, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","area_under_line_estimator_check","Checks estimation error for area_under_curve_estimator function for f(x) = x where x lies within min_value to max_value 1. Calls ""area_under_curve_estimator"" function 2. Compares with the expected value 3. Prints estimated, expected and error value","area_under_curve_estimator, print, print, print, print, print, print, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","pi_estimator_using_area_under_curve","Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi","area_under_curve_estimator, print, print, print, print, print, print, sqrt, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","is_in_circle","","sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","identity_function","Represents identity function >>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]] [-2.0, -1.0, 0.0, 1.0, 2.0]",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo.py","","function_to_integrate","Represents semi-circle with radius 2 >>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]] [0.0, 2.0, 0.0]","sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo_dice.py","Dice","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo_dice.py","","throw_dice","Return probability list of all possible sums when throwing dice.  >>> random.seed(0) >>> throw_dice(10, 1) [10.0, 0.0, 30.0, 50.0, 10.0, 0.0] >>> throw_dice(100, 1) [19.0, 17.0, 17.0, 11.0, 23.0, 13.0] >>> throw_dice(1000, 1) [18.8, 15.5, 16.3, 17.6, 14.2, 17.6] >>> throw_dice(10000, 1) [16.35, 16.89, 16.93, 16.6, 16.52, 16.71] >>> throw_dice(10000, 2) [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]","range, Dice, round, range, sum, len, dice.roll"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo_dice.py","","__init__","Initialize a six sided dice","list, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\monte_carlo_dice.py","","roll","","random.choice"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\number_of_digits.py","","num_digits","Find the number of digits in a number.  >>> num_digits(12345) 5 >>> num_digits(123) 3 >>> num_digits(0) 1 >>> num_digits(-1) 1 >>> num_digits(-123456) 6 >>> num_digits('123')  # Raises a TypeError for non-integer input Traceback (most recent call last):     ... TypeError: Input must be an integer","abs, isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\number_of_digits.py","","num_digits_fast","Find the number of digits in a number. abs() is used as logarithm for negative numbers is not defined.  >>> num_digits_fast(12345) 5 >>> num_digits_fast(123) 3 >>> num_digits_fast(0) 1 >>> num_digits_fast(-1) 1 >>> num_digits_fast(-123456) 6 >>> num_digits('123')  # Raises a TypeError for non-integer input Traceback (most recent call last):     ... TypeError: Input must be an integer","isinstance, TypeError, math.floor, math.log, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\number_of_digits.py","","num_digits_faster","Find the number of digits in a number. abs() is used for negative numbers  >>> num_digits_faster(12345) 5 >>> num_digits_faster(123) 3 >>> num_digits_faster(0) 1 >>> num_digits_faster(-1) 1 >>> num_digits_faster(-123456) 6 >>> num_digits('123')  # Raises a TypeError for non-integer input Traceback (most recent call last):     ... TypeError: Input must be an integer","len, isinstance, TypeError, str, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\number_of_digits.py","","benchmark","Benchmark multiple functions, with three different length int values.","timeit, print, print, benchmark_a_function, func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\number_of_digits.py","","benchmark_a_function","","timeit, print, func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\odd_sieve.py","","odd_sieve","Returns the prime numbers < `num`. The prime numbers are calculated using an odd sieve implementation of the Sieve of Eratosthenes algorithm (see for reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).  >>> odd_sieve(2) [] >>> odd_sieve(3) [2] >>> odd_sieve(10) [2, 3, 5, 7] >>> odd_sieve(20) [2, 3, 5, 7, 11, 13, 17, 19]","range, bytearray, int, repeat, list, sqrt, ceil, compress, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\perfect_cube.py","","perfect_cube","Check if a number is a perfect cube or not.  >>> perfect_cube(27) True >>> perfect_cube(4) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\perfect_cube.py","","perfect_cube_binary_search","Check if a number is a perfect cube or not using binary search. Time complexity : O(Log(n)) Space complexity: O(1)  >>> perfect_cube_binary_search(27) True >>> perfect_cube_binary_search(64) True >>> perfect_cube_binary_search(4) False >>> perfect_cube_binary_search(""a"") Traceback (most recent call last):     ... TypeError: perfect_cube_binary_search() only accepts integers >>> perfect_cube_binary_search(0.1) Traceback (most recent call last):     ... TypeError: perfect_cube_binary_search() only accepts integers","isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\perfect_number.py","","perfect","Check if a number is a perfect number.  A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding itself).  Args:     number: The number to be checked.  Returns:     True if the number is a perfect number otherwise, False. Start from 1 because dividing by 0 will raise ZeroDivisionError. A number at most can be divisible by the half of the number except the number itself. For example, 6 is at most can be divisible by 3 except by 6 itself. Examples: >>> perfect(27) False >>> perfect(28) True >>> perfect(29) False >>> perfect(6) True >>> perfect(12) False >>> perfect(496) True >>> perfect(8128) True >>> perfect(0) False >>> perfect(-1) False >>> perfect(33550336)  # Large perfect number True >>> perfect(33550337)  # Just above a large perfect number False >>> perfect(1)  # Edge case: 1 is not a perfect number False >>> perfect(""123"")  # String representation of a number Traceback (most recent call last): ... ValueError: number must be an integer >>> perfect(12.34) Traceback (most recent call last):   ... ValueError: number must be an integer >>> perfect(""Hello"") Traceback (most recent call last):   ... ValueError: number must be an integer","isinstance, ValueError, sum, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\perfect_square.py","","perfect_square","Check if a number is perfect square number or not :param num: the number to be checked :return: True if number is square number, otherwise False  >>> perfect_square(9) True >>> perfect_square(16) True >>> perfect_square(1) True >>> perfect_square(0) True >>> perfect_square(10) False","math.sqrt, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\perfect_square.py","","perfect_square_binary_search","Check if a number is perfect square using binary search. Time complexity : O(Log(n)) Space complexity: O(1)  >>> perfect_square_binary_search(9) True >>> perfect_square_binary_search(16) True >>> perfect_square_binary_search(1) True >>> perfect_square_binary_search(0) True >>> perfect_square_binary_search(10) False >>> perfect_square_binary_search(-1) False >>> perfect_square_binary_search(1.1) False >>> perfect_square_binary_search(""a"") Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'str' >>> perfect_square_binary_search(None) Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'NoneType' >>> perfect_square_binary_search([]) Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'list'",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\persistence.py","","multiplicative_persistence","Return the persistence of a given number.  https://en.wikipedia.org/wiki/Persistence_of_a_number  >>> multiplicative_persistence(217) 2 >>> multiplicative_persistence(-1) Traceback (most recent call last):     ... ValueError: multiplicative_persistence() does not accept negative values >>> multiplicative_persistence(""long number"") Traceback (most recent call last):     ... ValueError: multiplicative_persistence() only accepts integral values","str, isinstance, ValueError, ValueError, len, range, str, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\persistence.py","","additive_persistence","Return the persistence of a given number.  https://en.wikipedia.org/wiki/Persistence_of_a_number  >>> additive_persistence(199) 3 >>> additive_persistence(-1) Traceback (most recent call last):     ... ValueError: additive_persistence() does not accept negative values >>> additive_persistence(""long number"") Traceback (most recent call last):     ... ValueError: additive_persistence() only accepts integral values","str, isinstance, ValueError, ValueError, len, range, str, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_generator.py","","calculate_pi","https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80 Leibniz Formula for Pi  The Leibniz formula is the special case arctan(1) = pi / 4. Leibniz's formula converges extremely slowly: it exhibits sublinear convergence.  Convergence (https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Convergence)  We cannot try to prove against an interrupted, uncompleted generation. https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Unusual_behaviour The errors can in fact be predicted, but those calculations also approach infinity for accuracy.  Our output will be a string so that we can definitely store all digits.  >>> import math >>> float(calculate_pi(15)) == math.pi True  Since we cannot predict errors or interrupt any infinite alternating series generation since they approach infinity, or interrupt any alternating series, we'll need math.isclose()  >>> math.isclose(float(calculate_pi(50)), math.pi) True >>> math.isclose(float(calculate_pi(100)), math.pi) True  Since math.pi contains only 16 digits, here are some tests with known values:  >>> calculate_pi(50) '3.14159265358979323846264338327950288419716939937510' >>> calculate_pi(80) '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'","str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_generator.py","","main","","print, doctest.testmod, calculate_pi"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_monte_carlo_estimation.py","Point","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_monte_carlo_estimation.py","","estimate_pi","Generates an estimate of the mathematical constant PI. See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview  The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:      P[U in unit circle] = 1/4 PI  and therefore      PI = 4 * P[U in unit circle]  We can get an estimate of the probability P[U in unit circle]. See https://en.wikipedia.org/wiki/Empirical_probability by:      1. Draw a point uniformly from the unit square.     2. Repeat the first step n times and count the number of points in the unit         circle, which is called m.     3. An estimate of P[U in unit circle] is m/n","range, ValueError, Point.random_unit_square, random_point.is_in_unit_circle"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_monte_carlo_estimation.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_monte_carlo_estimation.py","","is_in_unit_circle","True, if the point lies in the unit circle False, otherwise",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pi_monte_carlo_estimation.py","","random_unit_square","Generates a point randomly drawn from the unit square [0, 1) x [0, 1).","cls, random.random, random.random"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\points_are_collinear_3d.py","","create_vector","Pass two points to get the vector from them in the form (x, y, z).  >>> create_vector((0, 0, 0), (1, 1, 1)) (1, 1, 1) >>> create_vector((45, 70, 24), (47, 32, 1)) (2, -38, -23) >>> create_vector((-14, -1, -8), (-7, 6, 4)) (7, 7, 12)",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\points_are_collinear_3d.py","","get_3d_vectors_cross","Get the cross of the two vectors AB and AC.  I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.  Read More:     https://en.wikipedia.org/wiki/Cross_product     https://en.wikipedia.org/wiki/Determinant  >>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2)) (-55, 22, 11) >>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1)) (0, 0, 0) >>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12)) (-36, -48, 27) >>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33)) (-123.2594, 277.15110000000004, 129.11260000000001)",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\points_are_collinear_3d.py","","is_zero_vector","Check if vector is equal to (0, 0, 0) or not.  Since the algorithm is very accurate, we will never get a zero vector, so we need to round the vector axis, because we want a result that is either True or False. In other applications, we can return a float that represents the collinearity ratio.  >>> is_zero_vector((0, 0, 0), accuracy=10) True >>> is_zero_vector((15, 74, 32), accuracy=10) False >>> is_zero_vector((-15, -74, -32), accuracy=10) False","tuple, round"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\points_are_collinear_3d.py","","are_collinear","Check if three points are collinear or not.  1- Create two vectors AB and AC. 2- Get the cross vector of the two vectors. 3- Calculate the length of the cross vector. 4- If the length is zero then the points are collinear, else they are not.  The use of the accuracy parameter is explained in is_zero_vector docstring.  >>> are_collinear((4.802293498137402, 3.536233125455244, 0), ...               (-2.186788107953106, -9.24561398001649, 7.141509524846482), ...               (1.530169574640268, -2.447927606600034, 3.343487096469054)) True >>> are_collinear((-6, -2, 6), ...               (6.200213806439997, -4.930157614926678, -4.482371908289856), ...               (-4.085171149525941, -2.459889509029438, 4.354787180795383)) True >>> are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666), ...               (-3.682816335934376, 5.753788986533145, 9.490993909044244), ...               (1.962903518985307, 3.741415730125627, 7)) False >>> are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993), ...               (-3.546599383667157, -4.630005261513976, 3.208784032924246), ...               (-2.564606140206386, 3.937845170672183, 7)) False","create_vector, create_vector, is_zero_vector, get_3d_vectors_cross"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pollard_rho.py","","pollard_rho","Use Pollard's Rho algorithm to return a nontrivial factor of ``num``. The returned factor may be composite and require further factorization. If the algorithm will return None if it fails to find a factor within the specified number of attempts or within the specified number of steps. If ``num`` is prime, this algorithm is guaranteed to return None. https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm  >>> pollard_rho(18446744073709551617) 274177 >>> pollard_rho(97546105601219326301) 9876543191 >>> pollard_rho(100) 2 >>> pollard_rho(17) >>> pollard_rho(17**3) 17 >>> pollard_rho(17**3, attempts=1) >>> pollard_rho(3*5*7) 21 >>> pollard_rho(1) Traceback (most recent call last):     ... ValueError: The input value cannot be less than 2","range, ValueError, rand_fn, rand_fn, rand_fn, gcd, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pollard_rho.py","","rand_fn","Returns a pseudorandom value modulo ``modulus`` based on the input ``value`` and attempt-specific ``step`` size.  >>> rand_fn(0, 0, 0) Traceback (most recent call last):     ... ZeroDivisionError: integer division or modulo by zero >>> rand_fn(1, 2, 3) 0 >>> rand_fn(0, 10, 7) 3 >>> rand_fn(1234, 1, 17) 16","pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomial_evaluation.py","","evaluate_poly","Evaluate a polynomial f(x) at specified point x and return the value.  Arguments: poly -- the coefficients of a polynomial as an iterable in order of         ascending degree x -- the point at which to evaluate the polynomial  >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0) 79800.0","sum, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomial_evaluation.py","","horner","Evaluate a polynomial at specified point using Horner's method.  In terms of computational complexity, Horner's method is an efficient method of evaluating a polynomial. It avoids the use of expensive exponentiation, and instead uses only multiplication and addition to evaluate the polynomial in O(n), where n is the degree of the polynomial.  https://en.wikipedia.org/wiki/Horner's_method  Arguments: poly -- the coefficients of a polynomial as an iterable in order of         ascending degree x -- the point at which to evaluate the polynomial  >>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0) 79800.0","reversed"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\power_using_recursion.py","","power","Calculate the power of a base raised to an exponent.  >>> power(3, 4) 81 >>> power(2, 0) 1 >>> all(power(base, exponent) == pow(base, exponent) ...     for base in range(-10, 10) for exponent in range(10)) True >>> power('a', 1) 'a' >>> power('a', 2) Traceback (most recent call last):     ... TypeError: can't multiply sequence by non-int of type 'str' >>> power('a', 'b') Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for -: 'str' and 'int' >>> power(2, -1) Traceback (most recent call last):     ... RecursionError: maximum recursion depth exceeded >>> power(0, 0) 1 >>> power(0, 1) 0 >>> power(5,6) 15625 >>> power(23, 12) 21914624432020321","power"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","is_prime","input: positive integer 'number' returns true if 'number' is prime otherwise false.  >>> is_prime(3) True >>> is_prime(10) False >>> is_prime(97) True >>> is_prime(9991) False >>> is_prime(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been an int and positive >>> is_prime(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int and positive","range, isinstance, isinstance, round, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","sieve_er","input: positive integer 'N' > 2 returns a list of prime numbers from 2 up to N.  This function implements the algorithm called sieve of erathostenes.  >>> sieve_er(8) [2, 3, 5, 7] >>> sieve_er(-1) Traceback (most recent call last):     ... AssertionError: 'N' must been an int and > 2 >>> sieve_er(""test"") Traceback (most recent call last):     ... AssertionError: 'N' must been an int and > 2","list, range, isinstance, isinstance, range, len, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","get_prime_numbers","input: positive integer 'N' > 2 returns a list of prime numbers from 2 up to N (inclusive) This function is more efficient as function 'sieveEr(...)'  >>> get_prime_numbers(8) [2, 3, 5, 7] >>> get_prime_numbers(-1) Traceback (most recent call last):     ... AssertionError: 'N' must been an int and > 2 >>> get_prime_numbers(""test"") Traceback (most recent call last):     ... AssertionError: 'N' must been an int and > 2","range, isinstance, isinstance, is_prime, ans.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","prime_factorization","input: positive integer 'number' returns a list of the prime number factors of 'number'  >>> prime_factorization(0) [0] >>> prime_factorization(8) [2, 2, 2] >>> prime_factorization(287) [7, 41] >>> prime_factorization(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 0 >>> prime_factorization(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 0","isinstance, isinstance, ans.append, is_prime, ans.append, is_prime, ans.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","greatest_prime_factor","input: positive integer 'number' >= 0 returns the greatest prime number factor of 'number'  >>> greatest_prime_factor(0) 0 >>> greatest_prime_factor(8) 2 >>> greatest_prime_factor(287) 41 >>> greatest_prime_factor(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 0 >>> greatest_prime_factor(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 0","prime_factorization, max, isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","smallest_prime_factor","input: integer 'number' >= 0 returns the smallest prime number factor of 'number'  >>> smallest_prime_factor(0) 0 >>> smallest_prime_factor(8) 2 >>> smallest_prime_factor(287) 7 >>> smallest_prime_factor(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 0 >>> smallest_prime_factor(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 0","prime_factorization, min, isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","is_even","input: integer 'number' returns true if 'number' is even, otherwise false.  >>> is_even(0) True >>> is_even(8) True >>> is_even(287) False >>> is_even(-1) False >>> is_even(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int","isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","is_odd","input: integer 'number' returns true if 'number' is odd, otherwise false.  >>> is_odd(0) False >>> is_odd(8) False >>> is_odd(287) True >>> is_odd(-1) True >>> is_odd(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int","isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","goldbach","Goldbach's assumption input: a even positive integer 'number' > 2 returns a list of two prime numbers whose sum is equal to 'number'  >>> goldbach(8) [3, 5] >>> goldbach(824) [3, 821] >>> goldbach(0) Traceback (most recent call last):     ... AssertionError: 'number' must been an int, even and > 2 >>> goldbach(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been an int, even and > 2 >>> goldbach(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int, even and > 2","get_prime_numbers, len, isinstance, is_even, isinstance, is_prime, is_prime, len, ans.append, ans.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","kg_v","Least common multiple input: two positive integer 'number1' and 'number2' returns the least common multiple of 'number1' and 'number2'  >>> kg_v(8,10) 40 >>> kg_v(824,67) 55208 >>> kg_v(1, 10) 10 >>> kg_v(0) Traceback (most recent call last):     ... TypeError: kg_v() missing 1 required positional argument: 'number2' >>> kg_v(10,-1) Traceback (most recent call last):     ... AssertionError: 'number1' and 'number2' must been positive integer. >>> kg_v(""test"",""test2"") Traceback (most recent call last):     ... AssertionError: 'number1' and 'number2' must been positive integer.","isinstance, isinstance, prime_factorization, prime_factorization, isinstance, max, done.append, prime_fac_2.count, range, done.append, prime_fac_1.count, prime_fac_2.count, range, prime_fac_1.count, range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","get_prime","Gets the n-th prime number. input: positive integer 'n' >= 0 returns the n-th prime number, beginning at index 0  >>> get_prime(0) 2 >>> get_prime(8) 23 >>> get_prime(824) 6337 >>> get_prime(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been a positive int >>> get_prime(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been a positive int","isinstance, isinstance, is_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","get_primes_between","input: prime numbers 'pNumber1' and 'pNumber2'         pNumber1 < pNumber2 returns a list of all prime numbers between 'pNumber1' (exclusive)         and 'pNumber2' (exclusive)  >>> get_primes_between(3, 67) [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61] >>> get_primes_between(0) Traceback (most recent call last):     ... TypeError: get_primes_between() missing 1 required positional argument: 'p_number_2' >>> get_primes_between(0, 1) Traceback (most recent call last):     ... AssertionError: The arguments must been prime numbers and 'pNumber1' < 'pNumber2' >>> get_primes_between(-1, 3) Traceback (most recent call last):     ... AssertionError: 'number' must been an int and positive >>> get_primes_between(""test"",""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int and positive","is_prime, is_prime, is_prime, ans.append, isinstance, is_prime, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","get_divisors","input: positive integer 'n' >= 1 returns all divisors of n (inclusive 1 and 'n')  >>> get_divisors(8) [1, 2, 4, 8] >>> get_divisors(824) [1, 2, 4, 8, 103, 206, 412, 824] >>> get_divisors(-1) Traceback (most recent call last):     ... AssertionError: 'n' must been int and >= 1 >>> get_divisors(""test"") Traceback (most recent call last):     ... AssertionError: 'n' must been int and >= 1","range, isinstance, ans.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","is_perfect_number","input: positive integer 'number' > 1 returns true if 'number' is a perfect number otherwise false.  >>> is_perfect_number(28) True >>> is_perfect_number(824) False >>> is_perfect_number(-1) Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 1 >>> is_perfect_number(""test"") Traceback (most recent call last):     ... AssertionError: 'number' must been an int and >= 1","get_divisors, isinstance, isinstance, sum, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","simplify_fraction","input: two integer 'numerator' and 'denominator' assumes: 'denominator' != 0 returns: a tuple with simplify numerator and denominator.  >>> simplify_fraction(10, 20) (1, 2) >>> simplify_fraction(10, -1) (10, -1) >>> simplify_fraction(""test"",""test"") Traceback (most recent call last):     ... AssertionError: The arguments must been from type int and 'denominator' != 0","gcd_by_iterative, isinstance, isinstance, abs, abs, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","factorial","input: positive integer 'n' returns the factorial of 'n' (n!)  >>> factorial(0) 1 >>> factorial(20) 2432902008176640000 >>> factorial(-1) Traceback (most recent call last):     ... AssertionError: 'n' must been a int and >= 0 >>> factorial(""test"") Traceback (most recent call last):     ... AssertionError: 'n' must been a int and >= 0","range, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\primelib.py","","fib","input: positive integer 'n' returns the n-th fibonacci term , indexing by 0  >>> fib(0) 1 >>> fib(5) 8 >>> fib(20) 10946 >>> fib(99) 354224848179261915075 >>> fib(-1) Traceback (most recent call last): ... AssertionError: 'n' must been an int and >= 0 >>> fib(""test"") Traceback (most recent call last): ... AssertionError: 'n' must been an int and >= 0","range, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_check.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False >>> is_prime(16.1) Traceback (most recent call last):     ... ValueError: is_prime() only accepts positive integers >>> is_prime(-4) Traceback (most recent call last):     ... ValueError: is_prime() only accepts positive integers","range, ValueError, int, isinstance, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_check.py","Test","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_check.py","","test_primes","","is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_check.py","","test_not_primes","","pytest.raises, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_factors.py","","prime_factors","Returns prime factors of n as a list.  >>> prime_factors(0) [] >>> prime_factors(100) [2, 2, 5, 5] >>> prime_factors(2560) [2, 2, 2, 2, 2, 2, 2, 2, 2, 5] >>> prime_factors(10**-2) [] >>> prime_factors(0.02) [] >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE >>> x == [2]*241 + [5]*241 True >>> prime_factors(10**-354) [] >>> prime_factors('hello') Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'str' >>> prime_factors([1,2,'hello']) Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'list'","factors.append, factors.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_factors.py","","unique_prime_factors","Returns unique prime factors of n as a list.  >>> unique_prime_factors(0) [] >>> unique_prime_factors(100) [2, 5] >>> unique_prime_factors(2560) [2, 5] >>> unique_prime_factors(10**-2) [] >>> unique_prime_factors(0.02) [] >>> unique_prime_factors(10**241) [2, 5] >>> unique_prime_factors(10**-354) [] >>> unique_prime_factors('hello') Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'str' >>> unique_prime_factors([1,2,'hello']) Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'int' and 'list'","factors.append, factors.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_numbers.py","","slow_primes","Return a list of all primes numbers up to max. >>> list(slow_primes(0)) [] >>> list(slow_primes(-1)) [] >>> list(slow_primes(-10)) [] >>> list(slow_primes(25)) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> list(slow_primes(11)) [2, 3, 5, 7, 11] >>> list(slow_primes(33)) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] >>> list(slow_primes(1000))[-1] 997","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_numbers.py","","primes","Return a list of all primes numbers up to max. >>> list(primes(0)) [] >>> list(primes(-1)) [] >>> list(primes(-10)) [] >>> list(primes(25)) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> list(primes(11)) [2, 3, 5, 7, 11] >>> list(primes(33)) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] >>> list(primes(1000))[-1] 997","range, range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_numbers.py","","fast_primes","Return a list of all primes numbers up to max. >>> list(fast_primes(0)) [] >>> list(fast_primes(-1)) [] >>> list(fast_primes(-10)) [] >>> list(fast_primes(25)) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> list(fast_primes(11)) [2, 3, 5, 7, 11] >>> list(fast_primes(33)) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] >>> list(fast_primes(1000))[-1] 997","range, range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_numbers.py","","benchmark","Let's benchmark our functions side-by-side...","print, print, print, timeit, timeit, timeit"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\prime_sieve_eratosthenes.py","","prime_sieve_eratosthenes","Print the prime numbers up to n  >>> prime_sieve_eratosthenes(10) [2, 3, 5, 7] >>> prime_sieve_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> prime_sieve_eratosthenes(2) [2] >>> prime_sieve_eratosthenes(1) [] >>> prime_sieve_eratosthenes(-1) Traceback (most recent call last): ... ValueError: Input must be a positive integer","ValueError, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\print_multiplication_table.py","","multiplication_table","Prints the multiplication table of a given number till the given number of terms  >>> print(multiplication_table(3, 5)) 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15  >>> print(multiplication_table(-4, 6)) -4 * 1 = -4 -4 * 2 = -8 -4 * 3 = -12 -4 * 4 = -16 -4 * 5 = -20 -4 * 6 = -24",".join, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pythagoras.py","Point","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pythagoras.py","","distance",">>> point1 = Point(2, -1, 7) >>> point2 = Point(1, -3, 5) >>> print(f""Distance from {point1} to {point2} is {distance(point1, point2)}"") Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0","math.sqrt, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pythagoras.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\pythagoras.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\qr_decomposition.py","","qr_householder","Return a QR-decomposition of the matrix A using Householder reflection.  The QR-decomposition decomposes the matrix A of shape (m, n) into an orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of shape (m, n).  Note that the matrix A does not have to be square.  This method of decomposing A uses the Householder reflection, which is numerically stable and of complexity O(n^3).  https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections  Arguments: A -- a numpy.ndarray of shape (m, n)  Note: several optimizations can be made for numeric efficiency, but this is intended to demonstrate how it would be represented in a mathematics textbook.  In cases where efficiency is particularly important, an optimized version from BLAS should be used.  >>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float) >>> Q, R = qr_householder(A)  >>> # check that the decomposition is correct >>> np.allclose(Q@R, A) True  >>> # check that Q is orthogonal >>> np.allclose(Q@Q.T, np.eye(A.shape[0])) True >>> np.allclose(Q.T@Q, np.eye(A.shape[0])) True  >>> # check that R is upper triangular >>> np.allclose(np.triu(R), R) True","min, np.eye, a.copy, range, np.zeros_like, np.linalg.norm, np.linalg.norm, np.block, np.eye, np.sign, np.eye, np.zeros, np.zeros"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\quadratic_equations_complex_numbers.py","","quadratic_roots","Given the numerical coefficients a, b and c, calculates the roots for any quadratic equation of the form ax^2 + bx + c  >>> quadratic_roots(a=1, b=3, c=-4) (1.0, -4.0) >>> quadratic_roots(5, 6, 1) (-0.2, -1.0) >>> quadratic_roots(1, -6, 25) ((3+4j), (3-4j))","ValueError, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\quadratic_equations_complex_numbers.py","","main","","quadratic_roots, print"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\radians.py","","radians","Converts the given angle from degrees to radians https://en.wikipedia.org/wiki/Radian  >>> radians(180) 3.141592653589793 >>> radians(92) 1.6057029118347832 >>> radians(274) 4.782202150464463 >>> radians(109.82) 1.9167205845401725  >>> from math import radians as math_radians >>> all(abs(radians(i) - math_radians(i)) <= 1e-8 for i in range(-2, 361)) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\radix2_fft.py","FFT","","Fast Polynomial Multiplication using radix-2 fast Fourier Transform.  Reference: https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case  For polynomials of degree m and n the algorithms has complexity O(n*logn + m*logm)  The main part of the algorithm is split in two parts:     1) __DFT: We compute the discrete fourier transform (DFT) of A and B using a     bottom-up dynamic approach -     2) __multiply: Once we obtain the DFT of A*B, we can similarly     invert it to obtain A*B  The class FFT takes two polynomials A and B with complex coefficients as arguments; The two polynomials should be represented as a sequence of coefficients starting from the free term. Thus, for instance x + 2*x^3 could be represented as [0,1,0,2] or (0,1,0,2). The constructor adds some zeros at the end so that the polynomials have the same length which is a power of 2 at least the length of their product.  Example:  Create two polynomials as sequences >>> A = [0, 1, 0, 2]  # x+2x^3 >>> B = (2, 3, 4, 0)  # 2+3x+4x^2  Create an FFT object with them >>> x = FFT(A, B)  Print product >>> x.product  # 2x + 3x^2 + 8x^3 + 6x^4 + 8x^5 [(-0-0j), (2+0j), (3-0j), (8-0j), (6+0j), (8+0j)]  __str__ test >>> print(x) A = 0*x^0 + 1*x^1 + 0*x^2 + 2*x^3 B = 2*x^0 + 3*x^1 + 4*x^2 A*B = (-0-0j)*x^0 + (2+0j)*x^1 + (3-0j)*x^2 + (8-0j)*x^3 + (6+0j)*x^4 + (8+0j)*x^5",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\radix2_fft.py","","__init__","","len, len, int, complex, self.__multiply, list, list, self.polyA.pop, self.polyB.pop, len, self.polyA.append, len, self.polyB.append, mpmath.root, np.ceil, np.log2, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\radix2_fft.py","","__dft","","len, range, range, range, range, range, .append, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\radix2_fft.py","","__multiply","","self.__dft, self.__dft, len, range, complex, inverce_c.pop, range, round, round, range, range, .append, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\radix2_fft.py","","__str__","",".join, .join, .join, enumerate, enumerate, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\remove_digit.py","","remove_digit","returns the biggest possible result that can be achieved by removing one digit from the given number  >>> remove_digit(152) 52 >>> remove_digit(6385) 685 >>> remove_digit(-11) 1 >>> remove_digit(2222222) 222222 >>> remove_digit(""2222222"") Traceback (most recent call last): TypeError: only integers accepted as input >>> remove_digit(""string input"") Traceback (most recent call last): TypeError: only integers accepted as input","isinstance, TypeError, str, range, max, abs, list, len, .pop, range, int, len, .join, list"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\segmented_sieve.py","","sieve","Segmented Sieve.  Examples: >>> sieve(8) [2, 3, 5, 7]  >>> sieve(27) [2, 3, 5, 7, 11, 13, 17, 19, 23]  >>> sieve(0) Traceback (most recent call last):     ... ValueError: Number 0 must instead be a positive integer  >>> sieve(-1) Traceback (most recent call last):     ... ValueError: Number -1 must instead be a positive integer  >>> sieve(22.2) Traceback (most recent call last):     ... ValueError: Number 22.2 must instead be a positive integer","int, min, isinstance, ValueError, math.sqrt, range, min, in_prime.append, range, range, len, math.floor, prime.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sieve_of_eratosthenes.py","","prime_sieve","Returns a list with all prime numbers up to n.  >>> prime_sieve(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> prime_sieve(25) [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> prime_sieve(10) [2, 3, 5, 7] >>> prime_sieve(9) [2, 3, 5, 7] >>> prime_sieve(2) [2] >>> prime_sieve(1) []","int, range, ValueError, math.sqrt, prime.append, range, prime.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sigmoid.py","","sigmoid","Implements the sigmoid function  Parameters:     vector (np.array): A  numpy array of shape (1,n)     consisting of real values  Returns:     sigmoid_vec (np.array): The input numpy array, after applying     sigmoid.  Examples: >>> sigmoid(np.array([-1.0, 1.0, 2.0])) array([0.26894142, 0.73105858, 0.88079708])  >>> sigmoid(np.array([0.0])) array([0.5])","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\signum.py","","signum","Applies signum function on the number  Custom test cases: >>> signum(-10) -1 >>> signum(10) 1 >>> signum(0) 0 >>> signum(-20.5) -1 >>> signum(20.5) 1 >>> signum(-1e-6) -1 >>> signum(1e-6) 1 >>> signum(""Hello"") Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'str' and 'int' >>> signum([]) Traceback (most recent call last):     ... TypeError: '<' not supported between instances of 'list' and 'int'",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\signum.py","","test_signum","Tests the signum function >>> test_signum()","signum, signum, signum, signum, signum, signum, signum, signum, signum"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\simultaneous_linear_equation_solver.py","","simplify",">>> simplify([[1, 2, 3], [4, 5, 6]]) [[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]] >>> simplify([[5, 2, 5], [5, 1, 10]]) [[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]","current_set.copy, enumerate, enumerate, range, final_set.append, len, simplify, range, resultant.insert, final_set.append, len, temp_row.append, current_first_column.append, next_iteration.append, len, .insert"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\simultaneous_linear_equation_solver.py","","solve_simultaneous",">>> solve_simultaneous([[1, 2, 3],[4, 5, 6]]) [-1.0, 2.0] >>> solve_simultaneous([[0, -3, 1, 7],[3, 2, -1, 11],[5, 1, -2, 12]]) [6.4, 1.2, 10.6] >>> solve_simultaneous([]) Traceback (most recent call last):     ... IndexError: solve_simultaneous() requires n lists of length n+1 >>> solve_simultaneous([[1, 2, 3],[1, 2]]) Traceback (most recent call last):     ... IndexError: solve_simultaneous() requires n lists of length n+1 >>> solve_simultaneous([[1, 2, 3],[""a"", 7, 8]]) Traceback (most recent call last):     ... ValueError: solve_simultaneous() requires lists of integers >>> solve_simultaneous([[0, 2, 3],[4, 0, 6]]) Traceback (most recent call last):     ... ValueError: solve_simultaneous() requires at least 1 full equation","any, equations.copy, any, data_set.copy, simplify, len, IndexError, len, IndexError, any, len, data_set.copy, enumerate, data_set.insert, enumerate, solutions.append, final.append, ValueError, ValueError, solutions.append, row.copy, temp_row.pop, len, solutions.append, float, len, data_set.pop, solutions.append, round, isinstance, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sin.py","","sin","Implement sin function.  >>> sin(0.0) 0.0 >>> sin(90.0) 1.0 >>> sin(180.0) 0.0 >>> sin(270.0) -1.0 >>> sin(0.68) 0.0118679603 >>> sin(1.97) 0.0343762121 >>> sin(64.0) 0.8987940463 >>> sin(9999.0) -0.9876883406 >>> sin(-689.0) 0.5150380749 >>> sin(89.7) 0.9999862922","radians, range, round, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sock_merchant.py","","sock_merchant",">>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20]) 3 >>> sock_merchant([1, 1, 3, 3]) 2","sum, .values, Counter"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\softmax.py","","softmax","Implements the softmax function  Parameters:     vector (np.array,list,tuple): A  numpy array of shape (1,n)     consisting of real values or a similar list,tuple   Returns:     softmax_vec (np.array): The input numpy array  after applying     softmax.  The softmax vector adds up to one. We need to ceil to mitigate for precision >>> float(np.ceil(np.sum(softmax([1,2,3,4])))) 1.0  >>> vec = np.array([5,5]) >>> softmax(vec) array([0.5, 0.5])  >>> softmax([0]) array([1.])","np.exp, np.sum"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\solovay_strassen_primality_test.py","","jacobi_symbol","Calculate the Jacobi symbol. The Jacobi symbol is a generalization of the Legendre symbol, which can be used to simplify computations involving quadratic residues. The Jacobi symbol is used in primality tests, like the Solovay-Strassen test, because it helps determine if an integer is a quadratic residue modulo a given modulus, providing valuable information about the number's potential primality or compositeness.  Parameters:     random_a: A randomly chosen integer from 2 to n-2 (inclusive)     number: The number that is tested for primality  Returns:     jacobi_symbol: The Jacobi symbol is a mathematical function     used to determine whether an integer is a quadratic residue modulo     another integer (usually prime) or not.  >>> jacobi_symbol(2, 13) -1 >>> jacobi_symbol(5, 19) 1 >>> jacobi_symbol(7, 14) 0",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\solovay_strassen_primality_test.py","","solovay_strassen","Check whether the input number is prime or not using the Solovay-Strassen Primality test  Parameters:     number: The number that is tested for primality     iterations: The number of times that the test is run     which effects the accuracy  Returns:     result: True if number is probably prime and false     if not  >>> random.seed(10) >>> solovay_strassen(13, 5) True >>> solovay_strassen(9, 10) False >>> solovay_strassen(17, 15) True","range, random.randint, jacobi_symbol, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\spearman_rank_correlation_coefficient.py","","assign_ranks","Assigns ranks to elements in the array.  :param data: List of floats. :return: List of ints representing the ranks.  Example: >>> assign_ranks([3.2, 1.5, 4.0, 2.7, 5.1]) [3, 1, 4, 2, 5]  >>> assign_ranks([10.5, 8.1, 12.4, 9.3, 11.0]) [3, 1, 5, 2, 4]","sorted, enumerate, len, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\spearman_rank_correlation_coefficient.py","","calculate_spearman_rank_correlation","Calculates Spearman's rank correlation coefficient.  :param variable_1: List of floats representing the first variable. :param variable_2: List of floats representing the second variable. :return: Spearman's rank correlation coefficient.  Example Usage:  >>> x = [1, 2, 3, 4, 5] >>> y = [5, 4, 3, 2, 1] >>> calculate_spearman_rank_correlation(x, y) -1.0  >>> x = [1, 2, 3, 4, 5] >>> y = [2, 4, 6, 8, 10] >>> calculate_spearman_rank_correlation(x, y) 1.0  >>> x = [1, 2, 3, 4, 5] >>> y = [5, 1, 2, 9, 5] >>> calculate_spearman_rank_correlation(x, y) 0.6","len, assign_ranks, assign_ranks, sum, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sumset.py","","sumset",":param first set: a set of numbers :param second set: a set of numbers :return: the nth number in Sylvester's sequence  >>> sumset({1, 2, 3}, {4, 5, 6}) {5, 6, 7, 8, 9}  >>> sumset({1, 2, 3}, {4, 5, 6, 7}) {5, 6, 7, 8, 9, 10}  >>> sumset({1, 2, 3, 4}, 3) Traceback (most recent call last): ... AssertionError: The input value of [set_b=3] is not a set","isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_arithmetic_series.py","","sum_of_series","Find the sum of n terms in an arithmetic progression.  >>> sum_of_series(1, 1, 10) 55.0 >>> sum_of_series(1, 10, 100) 49600.0",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_arithmetic_series.py","","main","","print, sum_of_series"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_digits.py","","sum_of_digits","Find the sum of digits of a number. >>> sum_of_digits(12345) 15 >>> sum_of_digits(123) 6 >>> sum_of_digits(-123) 6 >>> sum_of_digits(0) 0","abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_digits.py","","sum_of_digits_recursion","Find the sum of digits of a number using recursion >>> sum_of_digits_recursion(12345) 15 >>> sum_of_digits_recursion(123) 6 >>> sum_of_digits_recursion(-123) 6 >>> sum_of_digits_recursion(0) 0","abs, sum_of_digits"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_digits.py","","sum_of_digits_compact","Find the sum of digits of a number >>> sum_of_digits_compact(12345) 15 >>> sum_of_digits_compact(123) 6 >>> sum_of_digits_compact(-123) 6 >>> sum_of_digits_compact(0) 0","sum, int, str, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_digits.py","","benchmark","Benchmark multiple functions, with three different length int values.","timeit, print, print, benchmark_a_function, func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_digits.py","","benchmark_a_function","","timeit, print, func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_geometric_progression.py","","sum_of_geometric_progression",""" Return the sum of n terms in a geometric progression. >>> sum_of_geometric_progression(1, 2, 10) 1023.0 >>> sum_of_geometric_progression(1, 10, 5) 11111.0 >>> sum_of_geometric_progression(0, 2, 10) 0.0 >>> sum_of_geometric_progression(1, 0, 10) 1.0 >>> sum_of_geometric_progression(1, 2, 0) -0.0 >>> sum_of_geometric_progression(-1, 2, 10) -1023.0 >>> sum_of_geometric_progression(1, -2, 10) -341.0 >>> sum_of_geometric_progression(1, 2, -10) -0.9990234375",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sum_of_harmonic_series.py","","sum_of_harmonic_progression","https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)  Find the sum of n terms in an harmonic progression.  The calculation starts with the first_term and loops adding the common difference of Arithmetic Progression by which the given Harmonic Progression is linked.  >>> sum_of_harmonic_progression(1 / 2, 2, 2) 0.75 >>> sum_of_harmonic_progression(1 / 5, 5, 5) 0.45666666666666667","range, sum, arithmetic_progression.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\sylvester_sequence.py","","sylvester",":param number: nth number to calculate in the sequence :return: the nth number in Sylvester's sequence  >>> sylvester(8) 113423713055421844361000443  >>> sylvester(-1) Traceback (most recent call last):     ... ValueError: The input value of [n=-1] has to be > 0  >>> sylvester(8.0) Traceback (most recent call last):     ... AssertionError: The input value of [n=8.0] is not an integer","isinstance, ValueError, sylvester"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\tanh.py","","tangent_hyperbolic","Implements the tanh function      Parameters:         vector: np.ndarray      Returns:         tanh (np.array): The input numpy array after applying tanh.      mathematically (e^x - e^(-x))/(e^x + e^(-x)) can be written as (2/(1+e^(-2x))-1  Examples:     >>> tangent_hyperbolic(np.array([1,5,6,-0.67]))     array([ 0.76159416,  0.9999092 ,  0.99998771, -0.58497988])      >>> tangent_hyperbolic(np.array([8,10,2,-0.98,13]))     array([ 0.99999977,  1.        ,  0.96402758, -0.7530659 ,  1.        ])","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\test_factorial.py","","test_zero","","pytest.mark.parametrize, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\test_factorial.py","","test_positive_integers","","pytest.mark.parametrize, function, function, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\test_factorial.py","","test_large_number","","pytest.mark.parametrize, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\test_factorial.py","","test_negative_number","","pytest.mark.parametrize, pytest.raises, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\test_factorial.py","","test_float_number","","pytest.mark.parametrize, pytest.raises, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\three_sum.py","","three_sum","Find all unique triplets in a sorted array of integers that sum up to zero.  Args:     nums: A sorted list of integers.  Returns:     A list of lists containing unique triplets that sum up to zero.  >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4]) []","nums.sort, range, len, len, ans.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\trapezoidal_rule.py","","trapezoidal_rule","Implements the extended trapezoidal rule for numerical integration. The function f(x) is provided below.  :param boundary: List containing the lower and upper bounds of integration [a, b] :param steps: The number of steps (intervals) used in the approximation :return: The numerical approximation of the integral  >>> abs(trapezoidal_rule([0, 1], 10) - 0.33333) < 0.01 True >>> abs(trapezoidal_rule([0, 1], 100) - 0.33333) < 0.01 True >>> abs(trapezoidal_rule([0, 2], 1000) - 2.66667) < 0.01 True >>> abs(trapezoidal_rule([1, 2], 1000) - 2.33333) < 0.01 True","make_points, f, f, f"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\trapezoidal_rule.py","","make_points","Generates points between a and b with step size h for trapezoidal integration.  :param a: The lower bound of integration :param b: The upper bound of integration :param h: The step size :yield: The next x-value in the range (a, b)  >>> list(make_points(0, 1, 0.1))    # doctest: +NORMALIZE_WHITESPACE [0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999,     0.8999999999999999] >>> list(make_points(0, 10, 2.5)) [2.5, 5.0, 7.5] >>> list(make_points(0, 10, 2)) [2, 4, 6, 8] >>> list(make_points(1, 21, 5)) [6, 11, 16] >>> list(make_points(1, 5, 2)) [3] >>> list(make_points(1, 4, 3)) []",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\trapezoidal_rule.py","","f","This is the function to integrate, f(x) = (x - 0)^2 = x^2.  :param x: The input value :return: The value of f(x)  >>> f(0) 0 >>> f(1) 1 >>> f(0.5) 0.25",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\trapezoidal_rule.py","","main","Main function to test the trapezoidal rule. :a: Lower bound of integration :b: Upper bound of integration :steps: define number of steps or resolution :boundary: define boundary of integration  >>> main() y = 0.3349999999999999","trapezoidal_rule, print"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\triplet_sum.py","","make_dataset","","randint, randint, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\triplet_sum.py","","triplet_sum1","Returns a triplet in the array with sum equal to target, else (0, 0, 0). >>> triplet_sum1([13, 29, 7, 23, 5], 35) (5, 7, 23) >>> triplet_sum1([37, 9, 19, 50, 44], 65) (9, 19, 37) >>> arr = [6, 47, 27, 1, 15] >>> target = 11 >>> triplet_sum1(arr, target) (0, 0, 0)","permutations, sum, tuple, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\triplet_sum.py","","triplet_sum2","Returns a triplet in the array with sum equal to target, else (0, 0, 0). >>> triplet_sum2([13, 29, 7, 23, 5], 35) (5, 7, 23) >>> triplet_sum2([37, 9, 19, 50, 44], 65) (9, 19, 37) >>> arr = [6, 47, 27, 1, 15] >>> target = 11 >>> triplet_sum2(arr, target) (0, 0, 0)","arr.sort, len, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\triplet_sum.py","","solution_times","","repeat, repeat, min, min"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\twin_prime.py","","twin_prime","# doctest: +NORMALIZE_WHITESPACE This functions takes an integer number as input. returns n+2 if n and n+2 are prime numbers and -1 otherwise. >>> twin_prime(3) 5 >>> twin_prime(4) -1 >>> twin_prime(5) 7 >>> twin_prime(17) 19 >>> twin_prime(0) -1 >>> twin_prime(6.0) Traceback (most recent call last):     ... TypeError: Input value of [number=6.0] must be an integer","isinstance, TypeError, is_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\two_pointer.py","","two_pointer",">>> two_pointer([2, 7, 11, 15], 9) [0, 1] >>> two_pointer([2, 7, 11, 15], 17) [0, 3] >>> two_pointer([2, 7, 11, 15], 18) [1, 2] >>> two_pointer([2, 7, 11, 15], 26) [2, 3] >>> two_pointer([1, 3, 3], 6) [1, 2] >>> two_pointer([2, 7, 11, 15], 8) [] >>> two_pointer([3 * i for i in range(10)], 19) [] >>> two_pointer([1, 2, 3], 6) []","len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\two_sum.py","","two_sum",">>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([15, 2, 11, 7], 13) [1, 2] >>> two_sum([2, 7, 11, 15], 17) [0, 3] >>> two_sum([7, 15, 11, 2], 18) [0, 2] >>> two_sum([2, 7, 11, 15], 26) [2, 3] >>> two_sum([2, 7, 11, 15], 8) [] >>> two_sum([3 * i for i in range(10)], 19) []","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_cube","Calculate the Volume of a Cube.  >>> vol_cube(1) 1.0 >>> vol_cube(3) 27.0 >>> vol_cube(0) 0.0 >>> vol_cube(1.6) 4.096000000000001 >>> vol_cube(-1) Traceback (most recent call last):     ... ValueError: vol_cube() only accepts non-negative values","pow, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_spherical_cap","Calculate the volume of the spherical cap.  >>> vol_spherical_cap(1, 2) 5.235987755982988 >>> vol_spherical_cap(1.6, 2.6) 16.621119532592402 >>> vol_spherical_cap(0, 0) 0.0 >>> vol_spherical_cap(-1, 2) Traceback (most recent call last):     ... ValueError: vol_spherical_cap() only accepts non-negative values >>> vol_spherical_cap(1, -2) Traceback (most recent call last):     ... ValueError: vol_spherical_cap() only accepts non-negative values","ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_spheres_intersect","Calculate the volume of the intersection of two spheres.  The intersection is composed by two spherical caps and therefore its volume is the sum of the volumes of the spherical caps. First, it calculates the heights :math:`(h_1, h_2)` of the spherical caps, then the two volumes and it returns the sum. The height formulas are  .. math::     h_1 = \frac{(radius_1 - radius_2 + centers\_distance)                 \cdot (radius_1 + radius_2 - centers\_distance)}                {2 \cdot centers\_distance}      h_2 = \frac{(radius_2 - radius_1 + centers\_distance)                 \cdot (radius_2 + radius_1 - centers\_distance)}                {2 \cdot centers\_distance}  if `centers_distance` is 0 then it returns the volume of the smallers sphere  :return: ``vol_spherical_cap`` (:math:`h_1`, :math:`radius_2`)          + ``vol_spherical_cap`` (:math:`h_2`, :math:`radius_1`)  >>> vol_spheres_intersect(2, 2, 1) 21.205750411731103 >>> vol_spheres_intersect(2.6, 2.6, 1.6) 40.71504079052372 >>> vol_spheres_intersect(0, 0, 0) 0.0 >>> vol_spheres_intersect(-2, 2, 1) Traceback (most recent call last):     ... ValueError: vol_spheres_intersect() only accepts non-negative values >>> vol_spheres_intersect(2, -2, 1) Traceback (most recent call last):     ... ValueError: vol_spheres_intersect() only accepts non-negative values >>> vol_spheres_intersect(2, 2, -1) Traceback (most recent call last):     ... ValueError: vol_spheres_intersect() only accepts non-negative values","ValueError, vol_sphere, vol_spherical_cap, vol_spherical_cap, min"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_spheres_union","Calculate the volume of the union of two spheres that possibly intersect.  It is the sum of sphere :math:`A` and sphere :math:`B` minus their intersection. First, it calculates the volumes :math:`(v_1, v_2)` of the spheres, then the volume of the intersection :math:`i` and it returns the sum :math:`v_1 + v_2 - i`. If `centers_distance` is 0 then it returns the volume of the larger sphere  :return: ``vol_sphere`` (:math:`radius_1`) + ``vol_sphere`` (:math:`radius_2`)          - ``vol_spheres_intersect``          (:math:`radius_1`, :math:`radius_2`, :math:`centers\_distance`)  >>> vol_spheres_union(2, 2, 1) 45.814892864851146 >>> vol_spheres_union(1.56, 2.2, 1.4) 48.77802773671288 >>> vol_spheres_union(0, 2, 1) Traceback (most recent call last):     ... ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius >>> vol_spheres_union('1.56', '2.2', '1.4') Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'str' and 'int' >>> vol_spheres_union(1, None, 1) Traceback (most recent call last):     ... TypeError: '<=' not supported between instances of 'NoneType' and 'int'","ValueError, vol_sphere, vol_spheres_intersect, max, vol_sphere, vol_sphere"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_cuboid","Calculate the Volume of a Cuboid.  :return: multiple of `width`, `length` and `height`  >>> vol_cuboid(1, 1, 1) 1.0 >>> vol_cuboid(1, 2, 3) 6.0 >>> vol_cuboid(1.6, 2.6, 3.6) 14.976 >>> vol_cuboid(0, 0, 0) 0.0 >>> vol_cuboid(-1, 2, 3) Traceback (most recent call last):     ... ValueError: vol_cuboid() only accepts non-negative values >>> vol_cuboid(1, -2, 3) Traceback (most recent call last):     ... ValueError: vol_cuboid() only accepts non-negative values >>> vol_cuboid(1, 2, -3) Traceback (most recent call last):     ... ValueError: vol_cuboid() only accepts non-negative values","float, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_cone","| Calculate the Volume of a Cone. | Wikipedia reference: https://en.wikipedia.org/wiki/Cone  :return: :math:`\frac{1}{3} \cdot area\_of\_base \cdot height`  >>> vol_cone(10, 3) 10.0 >>> vol_cone(1, 1) 0.3333333333333333 >>> vol_cone(1.6, 1.6) 0.8533333333333335 >>> vol_cone(0, 0) 0.0 >>> vol_cone(-1, 1) Traceback (most recent call last):     ... ValueError: vol_cone() only accepts non-negative values >>> vol_cone(1, -1) Traceback (most recent call last):     ... ValueError: vol_cone() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_right_circ_cone","| Calculate the Volume of a Right Circular Cone. | Wikipedia reference: https://en.wikipedia.org/wiki/Cone  :return: :math:`\frac{1}{3} \cdot \pi \cdot radius^2 \cdot height`  >>> vol_right_circ_cone(2, 3) 12.566370614359172 >>> vol_right_circ_cone(0, 0) 0.0 >>> vol_right_circ_cone(1.6, 1.6) 4.289321169701265 >>> vol_right_circ_cone(-1, 1) Traceback (most recent call last):     ... ValueError: vol_right_circ_cone() only accepts non-negative values >>> vol_right_circ_cone(1, -1) Traceback (most recent call last):     ... ValueError: vol_right_circ_cone() only accepts non-negative values","ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_prism","| Calculate the Volume of a Prism. | Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)  :return: :math:`V = B \cdot h`  >>> vol_prism(10, 2) 20.0 >>> vol_prism(11, 1) 11.0 >>> vol_prism(1.6, 1.6) 2.5600000000000005 >>> vol_prism(0, 0) 0.0 >>> vol_prism(-1, 1) Traceback (most recent call last):     ... ValueError: vol_prism() only accepts non-negative values >>> vol_prism(1, -1) Traceback (most recent call last):     ... ValueError: vol_prism() only accepts non-negative values","float, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_pyramid","| Calculate the Volume of a Pyramid. | Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)  :return: :math:`\frac{1}{3} \cdot B \cdot h`  >>> vol_pyramid(10, 3) 10.0 >>> vol_pyramid(1.5, 3) 1.5 >>> vol_pyramid(1.6, 1.6) 0.8533333333333335 >>> vol_pyramid(0, 0) 0.0 >>> vol_pyramid(-1, 1) Traceback (most recent call last):     ... ValueError: vol_pyramid() only accepts non-negative values >>> vol_pyramid(1, -1) Traceback (most recent call last):     ... ValueError: vol_pyramid() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_sphere","| Calculate the Volume of a Sphere. | Wikipedia reference: https://en.wikipedia.org/wiki/Sphere  :return: :math:`\frac{4}{3} \cdot \pi \cdot r^3`  >>> vol_sphere(5) 523.5987755982989 >>> vol_sphere(1) 4.1887902047863905 >>> vol_sphere(1.6) 17.15728467880506 >>> vol_sphere(0) 0.0 >>> vol_sphere(-1) Traceback (most recent call last):     ... ValueError: vol_sphere() only accepts non-negative values","ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_hemisphere","| Calculate the volume of a hemisphere | Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere | Other references: https://www.cuemath.com/geometry/hemisphere  :return: :math:`\frac{2}{3} \cdot \pi \cdot radius^3`  >>> vol_hemisphere(1) 2.0943951023931953 >>> vol_hemisphere(7) 718.377520120866 >>> vol_hemisphere(1.6) 8.57864233940253 >>> vol_hemisphere(0) 0.0 >>> vol_hemisphere(-1) Traceback (most recent call last):     ... ValueError: vol_hemisphere() only accepts non-negative values","ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_circular_cylinder","| Calculate the Volume of a Circular Cylinder. | Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder  :return: :math:`\pi \cdot radius^2 \cdot height`  >>> vol_circular_cylinder(1, 1) 3.141592653589793 >>> vol_circular_cylinder(4, 3) 150.79644737231007 >>> vol_circular_cylinder(1.6, 1.6) 12.867963509103795 >>> vol_circular_cylinder(0, 0) 0.0 >>> vol_circular_cylinder(-1, 1) Traceback (most recent call last):     ... ValueError: vol_circular_cylinder() only accepts non-negative values >>> vol_circular_cylinder(1, -1) Traceback (most recent call last):     ... ValueError: vol_circular_cylinder() only accepts non-negative values","ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_hollow_circular_cylinder","Calculate the Volume of a Hollow Circular Cylinder.  >>> vol_hollow_circular_cylinder(1, 2, 3) 28.274333882308138 >>> vol_hollow_circular_cylinder(1.6, 2.6, 3.6) 47.50088092227767 >>> vol_hollow_circular_cylinder(-1, 2, 3) Traceback (most recent call last):     ... ValueError: vol_hollow_circular_cylinder() only accepts non-negative values >>> vol_hollow_circular_cylinder(1, -2, 3) Traceback (most recent call last):     ... ValueError: vol_hollow_circular_cylinder() only accepts non-negative values >>> vol_hollow_circular_cylinder(1, 2, -3) Traceback (most recent call last):     ... ValueError: vol_hollow_circular_cylinder() only accepts non-negative values >>> vol_hollow_circular_cylinder(2, 1, 3) Traceback (most recent call last):     ... ValueError: outer_radius must be greater than inner_radius >>> vol_hollow_circular_cylinder(0, 0, 0) Traceback (most recent call last):     ... ValueError: outer_radius must be greater than inner_radius","ValueError, ValueError, pow, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_conical_frustum","| Calculate the Volume of a Conical Frustum. | Wikipedia reference: https://en.wikipedia.org/wiki/Frustum  >>> vol_conical_frustum(45, 7, 28) 48490.482608158454 >>> vol_conical_frustum(1, 1, 2) 7.330382858376184 >>> vol_conical_frustum(1.6, 2.6, 3.6) 48.7240076620753 >>> vol_conical_frustum(0, 0, 0) 0.0 >>> vol_conical_frustum(-2, 2, 1) Traceback (most recent call last):     ... ValueError: vol_conical_frustum() only accepts non-negative values >>> vol_conical_frustum(2, -2, 1) Traceback (most recent call last):     ... ValueError: vol_conical_frustum() only accepts non-negative values >>> vol_conical_frustum(2, 2, -1) Traceback (most recent call last):     ... ValueError: vol_conical_frustum() only accepts non-negative values","ValueError, pow, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_torus","| Calculate the Volume of a Torus. | Wikipedia reference: https://en.wikipedia.org/wiki/Torus  :return: :math:`2 \pi^2 \cdot torus\_radius \cdot tube\_radius^2`  >>> vol_torus(1, 1) 19.739208802178716 >>> vol_torus(4, 3) 710.6115168784338 >>> vol_torus(3, 4) 947.4820225045784 >>> vol_torus(1.6, 1.6) 80.85179925372404 >>> vol_torus(0, 0) 0.0 >>> vol_torus(-1, 1) Traceback (most recent call last):     ... ValueError: vol_torus() only accepts non-negative values >>> vol_torus(1, -1) Traceback (most recent call last):     ... ValueError: vol_torus() only accepts non-negative values","ValueError, pow, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","vol_icosahedron","| Calculate the Volume of an Icosahedron. | Wikipedia reference: https://en.wikipedia.org/wiki/Regular_icosahedron  >>> from math import isclose >>> isclose(vol_icosahedron(2.5), 34.088984228514256) True >>> isclose(vol_icosahedron(10), 2181.694990624912374) True >>> isclose(vol_icosahedron(5), 272.711873828114047) True >>> isclose(vol_icosahedron(3.49), 92.740688412033628) True >>> vol_icosahedron(0) 0.0 >>> vol_icosahedron(-1) Traceback (most recent call last):     ... ValueError: vol_icosahedron() only accepts non-negative values >>> vol_icosahedron(-0.2) Traceback (most recent call last):     ... ValueError: vol_icosahedron() only accepts non-negative values","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\volume.py","","main","Print the Results of Various Volume Calculations.","print, print, print, print, print, print, print, print, print, print, print, print, print, print, print, print, print, vol_cube, vol_cuboid, vol_cone, vol_right_circ_cone, vol_prism, vol_pyramid, vol_sphere, vol_hemisphere, vol_circular_cylinder, vol_torus, vol_conical_frustum, vol_spherical_cap, vol_spheres_intersect, vol_spheres_union, vol_hollow_circular_cylinder, vol_icosahedron"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\zellers_congruence.py","","zeller","| Zellers Congruence Algorithm | Find the day of the week for nearly any Gregorian or Julian calendar date  >>> zeller('01-31-2010') 'Your date 01-31-2010, is a Sunday!'  Validate out of range month:  >>> zeller('13-31-2010') Traceback (most recent call last):     ... ValueError: Month must be between 1 - 12 >>> zeller('.2-31-2010') Traceback (most recent call last):     ... ValueError: invalid literal for int() with base 10: '.2'  Validate out of range date:  >>> zeller('01-33-2010') Traceback (most recent call last):     ... ValueError: Date must be between 1 - 31 >>> zeller('01-.4-2010') Traceback (most recent call last):     ... ValueError: invalid literal for int() with base 10: '.4'  Validate second separator:  >>> zeller('01-31*2010') Traceback (most recent call last):     ... ValueError: Date separator must be '-' or '/'  Validate first separator:  >>> zeller('01^31-2010') Traceback (most recent call last):     ... ValueError: Date separator must be '-' or '/'  Validate out of range year:  >>> zeller('01-31-8999') Traceback (most recent call last):     ... ValueError: Year out of range. There has to be some sort of limit...right?  Test null input:  >>> zeller() Traceback (most recent call last):     ... TypeError: zeller() missing 1 required positional argument: 'date_input'  Test length of `date_input`:  >>> zeller('') Traceback (most recent call last):     ... ValueError: Must be 10 characters long >>> zeller('01-31-19082939') Traceback (most recent call last):     ... ValueError: Must be 10 characters long","int, int, int, datetime.date, int, int, int, int, int, int, int, int, round, ValueError, ValueError, ValueError, ValueError, ValueError, ValueError, int, int, int, AssertionError, len, str, str, dt_ck.weekday, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\adams_bashforth.py","AdamsBashforth","","args: func: An ordinary differential equation (ODE) as function of x and y. x_initials: List containing initial required values of x. y_initials: List containing initial required values of y. step_size: The increment value of x. x_final: The final value of x.  Returns: Solution of y at each nodal point  >>> def f(x, y): ...     return x + y >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0.2, 1], 0.2, 1)  # doctest: +ELLIPSIS AdamsBashforth(func=..., x_initials=[0, 0.2, 0.4], y_initials=[0, 0.2, 1], step...) >>> AdamsBashforth(f, [0, 0.2, 1], [0, 0, 0.04], 0.2, 1).step_2() Traceback (most recent call last):     ... ValueError: The final value of x must be greater than the initial values of x.  >>> AdamsBashforth(f, [0, 0.2, 0.3], [0, 0, 0.04], 0.2, 1).step_3() Traceback (most recent call last):     ... ValueError: x-values must be equally spaced according to step size.  >>> AdamsBashforth(f,[0,0.2,0.4,0.6,0.8],[0,0,0.04,0.128,0.307],-0.2,1).step_5() Traceback (most recent call last):     ... ValueError: Step size must be positive.",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\adams_bashforth.py","","__post_init__","","ValueError, ValueError, all, ValueError, round, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\adams_bashforth.py","","step_2",">>> def f(x, y): ...     return x >>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_2() array([0.  , 0.  , 0.06, 0.16, 0.3 , 0.48])  >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_2() Traceback (most recent call last):     ... ValueError: Insufficient initial points information.","int, np.zeros, range, ValueError, len, len, self.func, self.func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\adams_bashforth.py","","step_3",">>> def f(x, y): ...     return x + y >>> y = AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_3() >>> float(y[3]) 0.15533333333333332  >>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_3() Traceback (most recent call last):     ... ValueError: Insufficient initial points information.","int, np.zeros, range, ValueError, len, len, self.func, self.func, self.func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\adams_bashforth.py","","step_4",">>> def f(x,y): ...     return x + y >>> y = AdamsBashforth( ...    f, [0, 0.2, 0.4, 0.6], [0, 0, 0.04, 0.128], 0.2, 1).step_4() >>> float(y[4]) 0.30699999999999994 >>> float(y[5]) 0.5771083333333333  >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_4() Traceback (most recent call last):     ... ValueError: Insufficient initial points information.","int, np.zeros, range, ValueError, len, len, self.func, self.func, self.func, self.func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\adams_bashforth.py","","step_5",">>> def f(x,y): ...     return x + y >>> y = AdamsBashforth( ...     f, [0, 0.2, 0.4, 0.6, 0.8], [0, 0.02140, 0.02140, 0.22211, 0.42536], ...     0.2, 1).step_5() >>> float(y[-1]) 0.05436839444444452  >>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_5() Traceback (most recent call last):     ... ValueError: Insufficient initial points information.","int, np.zeros, range, ValueError, len, len, self.func, self.func, self.func, self.func, self.func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\bisection.py","","bisection","finds where function becomes 0 in [a,b] using bolzano >>> bisection(lambda x: x ** 3 - 1, -5, 5) 1.0000000149011612 >>> bisection(lambda x: x ** 3 - 1, 2, 1000) Traceback (most recent call last):     ... ValueError: could not find root in given interval. >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2) 1.0 >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4) 3.0 >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000) Traceback (most recent call last):     ... ValueError: could not find root in given interval.","function, function, ValueError, function, function, abs, function, function, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\bisection.py","","f","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\bisection_2.py","","equation",">>> equation(5) -15 >>> equation(0) 10 >>> equation(-5) -15 >>> equation(0.1) 9.99 >>> equation(-0.1) 9.99",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\bisection_2.py","","bisection",">>> bisection(-2, 5) 3.1611328125 >>> bisection(0, 6) 3.158203125 >>> bisection(2, 3) Traceback (most recent call last):     ... ValueError: Wrong space!","ValueError, equation, equation, equation, equation, equation"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\integration_by_simpson_approx.py","","f","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\integration_by_simpson_approx.py","","simpson_integration","Args:     function : the function which's integration is desired     a : the lower limit of integration     b : upper limit of integration     precision : precision of the result,error required default is 4  Returns:     result : the value of the approximated integration of function in range a to b  Raises:     AssertionError: function is not callable     AssertionError: a is not float or integer     AssertionError: function should return float or integer     AssertionError: b is not float or integer     AssertionError: precision is not positive integer  >>> simpson_integration(lambda x : x*x,1,2,3) 2.333  >>> simpson_integration(lambda x : x*x,'wrong_input',2,3) Traceback (most recent call last):     ... AssertionError: a should be float or integer your input : wrong_input  >>> simpson_integration(lambda x : x*x,1,'wrong_input',3) Traceback (most recent call last):     ... AssertionError: b should be float or integer your input : wrong_input  >>> simpson_integration(lambda x : x*x,1,2,'wrong_input') Traceback (most recent call last):     ... AssertionError: precision should be positive integer your input : wrong_input >>> simpson_integration('wrong_input',2,3,4) Traceback (most recent call last):     ... AssertionError: the function(object) passed should be callable your input : ...  >>> simpson_integration(lambda x : x*x,3.45,3.2,1) -2.8  >>> simpson_integration(lambda x : x*x,3.45,3.2,0) Traceback (most recent call last):     ... AssertionError: precision should be positive integer your input : 0  >>> simpson_integration(lambda x : x*x,3.45,3.2,-1) Traceback (most recent call last):     ... AssertionError: precision should be positive integer your input : -1","callable, isinstance, isinstance, isinstance, range, round, function, isinstance, function, function, type, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\intersection.py","","intersection","function is the f we want to find its root x0 and x1 are two random starting points >>> intersection(lambda x: x ** 3 - 1, -5, 5) 0.9999999999954654 >>> intersection(lambda x: x ** 3 - 1, 5, 5) Traceback (most recent call last):     ... ZeroDivisionError: float division by zero, could not find root >>> intersection(lambda x: x ** 3 - 1, 100, 200) 1.0000000000003888 >>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2) 0.9999999998088019 >>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4) 2.9999999998088023 >>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000) 3.0000000001786042 >>> intersection(math.sin, -math.pi, math.pi) 0.0 >>> intersection(math.cos, -math.pi, math.pi) Traceback (most recent call last):     ... ZeroDivisionError: float division by zero, could not find root","ZeroDivisionError, abs, function, function, function, function, function"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\intersection.py","","f","function is f(x) = x^3 - 2x - 5 >>> f(2) -1.0","math.pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\nevilles_method.py","","neville_interpolate","Interpolate and evaluate a polynomial using Neville's method.    Arguments:        x_points, y_points: Iterables of x and corresponding y points through         which the polynomial passes.        x0: The value of x to evaluate the polynomial for.    Return Value: A list of the approximated value and the Neville iterations        table respectively. >>> import pprint >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0] 10.0 >>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1]) [[0, 6, 0, 0, 0],  [0, 7, 0, 0, 0],  [0, 8, 104.0, 0, 0],  [0, 9, 104.0, 104.0, 0],  [0, 11, 104.0, 104.0, 104.0]] >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0] 104.0 >>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '') Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for -: 'str' and 'int'","len, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\newton_forward_interpolation.py","","ucal",">>> ucal(1, 2) 0 >>> ucal(1.1, 2) 0.11000000000000011 >>> ucal(1.2, 2) 0.23999999999999994","range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\newton_forward_interpolation.py","","main","","int, range, range, print, list, print, range, int, range, range, print, input, y.append, range, map, float, input, range, .append, .split, input, math.factorial, ucal, input"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\newton_raphson.py","","calc_derivative","Approximate the derivative of a function f(x) at a point x using the finite difference method  >>> import math >>> tolerance = 1e-5 >>> derivative = calc_derivative(lambda x: x**2, 2) >>> math.isclose(derivative, 4, abs_tol=tolerance) True >>> derivative = calc_derivative(math.sin, 0) >>> math.isclose(derivative, 1, abs_tol=tolerance) True","f, f"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\newton_raphson.py","","newton_raphson","Find a root of the given function f using the Newton-Raphson method.  :param f: A real-valued single-variable function :param x0: Initial guess :param max_iter: Maximum number of iterations :param step: Step size of x, used to approximate f'(x) :param max_error: Maximum approximation error :param log_steps: bool denoting whether to log intermediate steps  :return: A tuple containing the approximation, the error, and the intermediate     steps. If log_steps is False, then an empty list is returned for the third     element of the tuple.  :raises ZeroDivisionError: The derivative approaches 0. :raises ArithmeticError: No solution exists, or the solution isn't found before the     iteration limit is reached.  >>> import math >>> tolerance = 1e-15 >>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance) >>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance) True >>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance) >>> math.isclose(root, math.e, abs_tol=tolerance) True >>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance) >>> math.isclose(root, 0, abs_tol=tolerance) True >>> newton_raphson(math.cos, 0) Traceback (most recent call last): ... ZeroDivisionError: No converging solution found, zero derivative >>> newton_raphson(lambda x: x**2 + 1, 2) Traceback (most recent call last): ... ArithmeticError: No converging solution found, iteration limit reached","range, ArithmeticError, calc_derivative, abs, steps.append, f, f_derivative, ZeroDivisionError, f, f_derivative"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\newton_raphson.py","","f_derivative","","calc_derivative"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\newton_raphson.py","","func","","exp, tanh"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\numerical_integration.py","","trapezoidal_area","Treats curve as a collection of linear lines and sums the area of the trapezium shape they form :param fnc: a function which defines a curve :param x_start: left end point to indicate the start of line segment :param x_end: right end point to indicate end of line segment :param steps: an accuracy gauge; more steps increases the accuracy :return: a float representing the length of the curve  >>> def f(x): ...    return 5 >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000) '10.000'  >>> def f(x): ...    return 9*x**2 >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000) '192.0000'  >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000) '384.0000'","fnc, range, fnc, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\numerical_integration.py","","f","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\proper_fractions.py","","proper_fractions","this algorithm returns a list of proper fractions, in the range between 0 and 1, which can be formed with the given denominator https://en.wikipedia.org/wiki/Fraction#Proper_and_improper_fractions  >>> proper_fractions(10) ['1/10', '3/10', '7/10', '9/10'] >>> proper_fractions(5) ['1/5', '2/5', '3/5', '4/5'] >>> proper_fractions(-15) Traceback (most recent call last):     ... ValueError: The Denominator Cannot be less than 0 >>> proper_fractions(0) [] >>> proper_fractions(1.2) Traceback (most recent call last):     ... ValueError: The Denominator must be an integer","ValueError, isinstance, ValueError, range, gcd"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\runge_kutta.py","","runge_kutta","Calculate the numeric solution at each step to the ODE f(x, y) using RK4  https://en.wikipedia.org/wiki/Runge-Kutta_methods  Arguments: f -- The ode as a function of x and y y0 -- the initial value for y x0 -- the initial value for x h -- the stepsize x_end -- the end value for x  >>> # the exact solution is math.exp(x) >>> def f(x, y): ...     return y >>> y0 = 1 >>> y = runge_kutta(f, y0, 0.0, 0.01, 5) >>> float(y[-1]) 148.41315904125113","int, np.zeros, range, np.ceil, f, f, f, f"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\runge_kutta_fehlberg_45.py","","runge_kutta_fehlberg_45","Solve an Ordinary Differential Equations using Runge-Kutta-Fehlberg Method (rkf45) of order 5.  https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method  args: func: An ordinary differential equation (ODE) as function of x and y. x_initial: The initial value of x. y_initial: The initial value of y. step_size: The increment value of x. x_final: The final value of x.  Returns:     Solution of y at each nodal point  # exact value of y[1] is tan(0.2) = 0.2027100937470787 >>> def f(x, y): ...     return 1 + y**2 >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, 1) >>> float(y[1]) 0.2027100937470787 >>> def f(x,y): ...     return x >>> y = runge_kutta_fehlberg_45(f, -1, 0, 0.2, 0) >>> float(y[1]) -0.18000000000000002 >>> y = runge_kutta_fehlberg_45(5, 0, 0, 0.1, 1) Traceback (most recent call last):     ... TypeError: 'int' object is not callable >>> def f(x, y): ...     return x + y >>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, -1) Traceback (most recent call last):     ... ValueError: The final value of x must be greater than initial value of x. >>> def f(x, y): ...     return x >>> y = runge_kutta_fehlberg_45(f, -1, 0, -0.2, 0) Traceback (most recent call last):     ... ValueError: Step size must be positive.","int, np.zeros, np.zeros, range, ValueError, ValueError, func, func, func, func, func, func"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\runge_kutta_gills.py","","runge_kutta_gills","Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.  args: func: An ordinary differential equation (ODE) as function of x and y. x_initial: The initial value of x. y_initial: The initial value of y. step_size: The increment value of x. x_final: The final value of x.  Returns:     Solution of y at each nodal point  >>> def f(x, y): ...     return (x-y)/2 >>> y = runge_kutta_gills(f, 0, 3, 0.2, 5) >>> float(y[-1]) 3.4104259225717537  >>> def f(x,y): ...     return x >>> y = runge_kutta_gills(f, -1, 0, 0.2, 0) >>> y array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])  >>> def f(x, y): ...     return x + y >>> y = runge_kutta_gills(f, 0, 0, 0.2, -1) Traceback (most recent call last):     ... ValueError: The final value of x must be greater than initial value of x.  >>> def f(x, y): ...     return x >>> y = runge_kutta_gills(f, -1, 0, -0.2, 0) Traceback (most recent call last):     ... ValueError: Step size must be positive.","int, np.zeros, range, ValueError, ValueError, func, func, func, func, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\secant_method.py","","f",">>> f(5) 39.98652410600183","exp"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\secant_method.py","","secant_method",">>> secant_method(1, 3, 2) 0.2139409276214589","range, f, f, f"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\simpson_rule.py","","method_2","Calculate the definite integral of a function using Simpson's Rule. :param boundary: A list containing the lower and upper bounds of integration. :param steps: The number of steps or resolution for the integration. :return: The approximate integral value.  >>> round(method_2([0, 2, 4], 10), 10) 2.6666666667 >>> round(method_2([2, 0], 10), 10) -0.2666666667 >>> round(method_2([-2, -1], 10), 10) 2.172 >>> round(method_2([0, 1], 10), 10) 0.3333333333 >>> round(method_2([0, 2], 10), 10) 2.6666666667 >>> round(method_2([0, 2], 100), 10) 2.5621226667 >>> round(method_2([0, 1], 1000), 10) 0.3320026653 >>> round(method_2([0, 2], 0), 10) Traceback (most recent call last):     ... ZeroDivisionError: Number of steps must be greater than zero >>> round(method_2([0, 2], -10), 10) Traceback (most recent call last):     ... ZeroDivisionError: Number of steps must be greater than zero","make_points, ZeroDivisionError, f, f, f"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\simpson_rule.py","","make_points","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\simpson_rule.py","","f","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\simpson_rule.py","","main","","method_2, print"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\square_root.py","","fx","","math.pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\square_root.py","","fx_derivative","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\square_root.py","","get_initial_point","","math.pow"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\square_root.py","","square_root_iterative","Square root approximated using Newton's method. https://en.wikipedia.org/wiki/Newton%27s_method  >>> all(abs(square_root_iterative(i) - math.sqrt(i)) <= 1e-14 for i in range(500)) True  >>> square_root_iterative(-1) Traceback (most recent call last):     ... ValueError: math domain error  >>> square_root_iterative(4) 2.0  >>> square_root_iterative(3.2) 1.788854381999832  >>> square_root_iterative(140) 11.832159566199232","get_initial_point, range, ValueError, abs, fx, fx_derivative"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\numerical_analysis\weierstrass_method.py","","weierstrass_method","Approximates all complex roots of a polynomial using the Weierstrass (Durand-Kerner) method. Args:     polynomial: A function that takes a NumPy array of complex numbers and returns                 the polynomial values at those points.     degree: Degree of the polynomial (number of roots to find). Must be  1.     roots:  Optional initial guess as a NumPy array of complex numbers.             Must have length equal to 'degree'.             If None, perturbed complex roots of unity are used.     max_iter: Number of iterations to perform (default: 100).  Returns:     np.ndarray: Array of approximated complex roots.  Raises:     ValueError: If degree < 1, or if initial roots length doesn't match the degree.  Note:     - Root updates are clipped to prevent numerical overflow.  Example:     >>> import numpy as np     >>> def check(poly, degree, expected):     ...     roots = weierstrass_method(poly, degree)     ...     return np.allclose(np.sort(roots), np.sort(expected))      >>> check(     ...     lambda x: x**2 - 1,     ...     2,     ...     np.array([-1, 1]))     True      >>> check(     ...     lambda x: x**3 - 4.5*x**2 + 5.75*x - 1.875,     ...     3,     ...     np.array([1.5, 0.5, 2.5])     ... )     True  See Also:     https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method","range, ValueError, np.random.default_rng, np.array, np.asarray, np.array, np.fill_diagonal, np.prod, .astype, np.clip, ValueError, polynomial, np.exp, range, rng.random"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","Polynomial","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__init__","The coefficients should be in order of degree, from smallest to largest. >>> p = Polynomial(2, [1, 2, 3]) >>> p = Polynomial(2, [1, 2, 3, 4]) Traceback (most recent call last): ... ValueError: The number of coefficients should be equal to the degree + 1.","list, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__add__","Polynomial addition >>> p = Polynomial(2, [1, 2, 3]) >>> q = Polynomial(2, [1, 2, 3]) >>> p + q 6x^2 + 4x + 2","range, Polynomial, range, Polynomial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__sub__","Polynomial subtraction >>> p = Polynomial(2, [1, 2, 4]) >>> q = Polynomial(2, [1, 2, 3]) >>> p - q 1x^2","Polynomial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__neg__","Polynomial negation >>> p = Polynomial(2, [1, 2, 3]) >>> -p  - 3x^2 - 2x - 1","Polynomial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__mul__","Polynomial multiplication >>> p = Polynomial(2, [1, 2, 3]) >>> q = Polynomial(2, [1, 2, 3]) >>> p * q 9x^4 + 12x^3 + 10x^2 + 4x + 1","range, Polynomial, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","evaluate","Evaluates the polynomial at x. >>> p = Polynomial(2, [1, 2, 3]) >>> p.evaluate(2) 17","range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__str__",">>> p = Polynomial(2, [1, 2, 3]) >>> print(p) 3x^2 + 2x + 1","range, str, abs, str, str, abs, str, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__repr__",">>> p = Polynomial(2, [1, 2, 3]) >>> p 3x^2 + 2x + 1","self.__str__"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","derivative","Returns the derivative of the polynomial. >>> p = Polynomial(2, [1, 2, 3]) >>> p.derivative() 6x + 2","range, Polynomial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","integral","Returns the integral of the polynomial. >>> p = Polynomial(2, [1, 2, 3]) >>> p.integral() 1.0x^3 + 1.0x^2 + 1.0x","range, Polynomial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__eq__","Checks if two polynomials are equal. >>> p = Polynomial(2, [1, 2, 3]) >>> q = Polynomial(2, [1, 2, 3]) >>> p == q True","range, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\polynomials\single_indeterminate_operations.py","","__ne__","Checks if two polynomials are not equal. >>> p = Polynomial(2, [1, 2, 3]) >>> q = Polynomial(2, [1, 2, 3]) >>> p != q False","self.__eq__"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\arithmetic.py","","is_arithmetic_series","checking whether the input series is arithmetic series or not >>> is_arithmetic_series([2, 4, 6]) True >>> is_arithmetic_series([3, 6, 12, 24]) False >>> is_arithmetic_series([1, 2, 3]) True >>> is_arithmetic_series(4) Traceback (most recent call last):     ... ValueError: Input series is not valid, valid series - [2, 4, 6] >>> is_arithmetic_series([]) Traceback (most recent call last):     ... ValueError: Input list must be a non empty list","range, isinstance, ValueError, len, ValueError, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\arithmetic.py","","arithmetic_mean","return the arithmetic mean of series  >>> arithmetic_mean([2, 4, 6]) 4.0 >>> arithmetic_mean([3, 6, 9, 12]) 7.5 >>> arithmetic_mean(4) Traceback (most recent call last):     ... ValueError: Input series is not valid, valid series - [2, 4, 6] >>> arithmetic_mean([4, 8, 1]) 4.333333333333333 >>> arithmetic_mean([1, 2, 3]) 2.0 >>> arithmetic_mean([]) Traceback (most recent call last):     ... ValueError: Input list must be a non empty list","isinstance, ValueError, len, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\geometric.py","","is_geometric_series","checking whether the input series is geometric series or not >>> is_geometric_series([2, 4, 8]) True >>> is_geometric_series([3, 6, 12, 24]) True >>> is_geometric_series([1, 2, 3]) False >>> is_geometric_series([0, 0, 3]) False >>> is_geometric_series([]) Traceback (most recent call last):     ... ValueError: Input list must be a non empty list >>> is_geometric_series(4) Traceback (most recent call last):     ... ValueError: Input series is not valid, valid series - [2, 4, 8]","isinstance, ValueError, len, ValueError, len, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\geometric.py","","geometric_mean","return the geometric mean of series  >>> geometric_mean([2, 4, 8]) 3.9999999999999996 >>> geometric_mean([3, 6, 12, 24]) 8.48528137423857 >>> geometric_mean([4, 8, 16]) 7.999999999999999 >>> geometric_mean(4) Traceback (most recent call last):     ... ValueError: Input series is not valid, valid series - [2, 4, 8] >>> geometric_mean([1, 2, 3]) 1.8171205928321397 >>> geometric_mean([0, 2, 3]) 0.0 >>> geometric_mean([]) Traceback (most recent call last):     ... ValueError: Input list must be a non empty list","pow, isinstance, ValueError, len, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\geometric_series.py","","geometric_series","Pure Python implementation of Geometric Series algorithm  :param nth_term: The last term (nth term of Geometric Series) :param start_term_a : The first term of Geometric Series :param common_ratio_r : The common ratio between all the terms :return: The Geometric Series starting from first term a and multiple of common     ration with first term with increase in power till last term (nth term) Examples: >>> geometric_series(4, 2, 2) [2, 4.0, 8.0, 16.0] >>> geometric_series(4.0, 2.0, 2.0) [2.0, 4.0, 8.0, 16.0] >>> geometric_series(4.1, 2.1, 2.1) [2.1, 4.41, 9.261000000000001, 19.448100000000004] >>> geometric_series(4, 2, -2) [2, -4.0, 8.0, -16.0] >>> geometric_series(4, -2, 2) [-2, -4.0, -8.0, -16.0] >>> geometric_series(-4, 2, 2) [] >>> geometric_series(0, 100, 500) [] >>> geometric_series(1, 1, 1) [1] >>> geometric_series(0, 0, 0) []","range, all, int, series.append, series.append, pow, float, float"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\harmonic.py","","is_harmonic_series","checking whether the input series is arithmetic series or not >>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3]) True >>> is_harmonic_series([ 1, 2/3, 2/5, 1/3]) False >>> is_harmonic_series([1, 2, 3]) False >>> is_harmonic_series([1/2, 1/3, 1/4]) True >>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25]) True >>> is_harmonic_series(4) Traceback (most recent call last):     ... ValueError: Input series is not valid, valid series - [1, 2/3, 2] >>> is_harmonic_series([]) Traceback (most recent call last):     ... ValueError: Input list must be a non empty list >>> is_harmonic_series([0]) Traceback (most recent call last):     ... ValueError: Input series cannot have 0 as an element >>> is_harmonic_series([1,2,0,6]) Traceback (most recent call last):     ... ValueError: Input series cannot have 0 as an element","len, range, range, isinstance, ValueError, len, ValueError, rec_series.append, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\harmonic.py","","harmonic_mean","return the harmonic mean of series  >>> harmonic_mean([1, 4, 4]) 2.0 >>> harmonic_mean([3, 6, 9, 12]) 5.759999999999999 >>> harmonic_mean(4) Traceback (most recent call last):     ... ValueError: Input series is not valid, valid series - [2, 4, 6] >>> harmonic_mean([1, 2, 3]) 1.6363636363636365 >>> harmonic_mean([]) Traceback (most recent call last):     ... ValueError: Input list must be a non empty list","isinstance, ValueError, len, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\harmonic_series.py","","harmonic_series","Pure Python implementation of Harmonic Series algorithm  :param n_term: The last (nth) term of Harmonic Series :return: The Harmonic Series starting from 1 to last (nth) term  Examples: >>> harmonic_series(5) ['1', '1/2', '1/3', '1/4', '1/5'] >>> harmonic_series(5.0) ['1', '1/2', '1/3', '1/4', '1/5'] >>> harmonic_series(5.1) ['1', '1/2', '1/3', '1/4', '1/5'] >>> harmonic_series(-5) [] >>> harmonic_series(0) [] >>> harmonic_series(1) ['1']","range, int, series.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\hexagonal_numbers.py","","hexagonal_numbers",":param len: max number of elements :type len: int :return: Hexagonal numbers as a list  Tests: >>> hexagonal_numbers(10) [0, 1, 6, 15, 28, 45, 66, 91, 120, 153] >>> hexagonal_numbers(5) [0, 1, 6, 15, 28] >>> hexagonal_numbers(0) Traceback (most recent call last):   ... ValueError: Length must be a positive integer.","ValueError, isinstance, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\series\p_series.py","","p_series","Pure Python implementation of P-Series algorithm :return: The P-Series starting from 1 to last (nth) term Examples: >>> p_series(5, 2) ['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25'] >>> p_series(-5, 2) [] >>> p_series(5, -2) ['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04'] >>> p_series("""", 1000) [''] >>> p_series(0, 0) [] >>> p_series(1, 1) ['1']","int, int, range, int, series.append, pow, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\armstrong_numbers.py","","armstrong_number","Return True if n is an Armstrong number or False if it is not.  >>> all(armstrong_number(n) for n in PASSING) True >>> any(armstrong_number(n) for n in FAILING) False","len, str, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\armstrong_numbers.py","","pluperfect_number","Return True if n is a pluperfect number or False if it is not  >>> all(pluperfect_number(n) for n in PASSING) True >>> any(pluperfect_number(n) for n in FAILING) False","zip, divmod, range, isinstance, len"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\armstrong_numbers.py","","narcissistic_number","Return True if n is a narcissistic number or False if it is not.  >>> all(narcissistic_number(n) for n in PASSING) True >>> any(narcissistic_number(n) for n in FAILING) False","len, str, sum, isinstance, int, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\armstrong_numbers.py","","main","Request that user input an integer and tell them if it is Armstrong number.","int, print, print, print, .strip, input, armstrong_number, narcissistic_number, pluperfect_number"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\automorphic_number.py","","is_automorphic_number","# doctest: +NORMALIZE_WHITESPACE This functions takes an integer number as input. returns True if the number is automorphic. >>> is_automorphic_number(-1) False >>> is_automorphic_number(0) True >>> is_automorphic_number(5) True >>> is_automorphic_number(6) True >>> is_automorphic_number(7) False >>> is_automorphic_number(25) True >>> is_automorphic_number(259918212890625) True >>> is_automorphic_number(259918212890636) False >>> is_automorphic_number(740081787109376) True >>> is_automorphic_number(5.0) Traceback (most recent call last):     ... TypeError: Input value of [number=5.0] must be an integer","isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\bell_numbers.py","","bell_numbers","Calculate Bell numbers for the sets of lengths from 0 to max_set_length. In other words, calculate first (max_set_length + 1) Bell numbers.  Args:     max_set_length (int): The maximum length of the sets for which     Bell numbers are calculated.  Returns:     list: A list of Bell numbers for sets of lengths from 0 to max_set_length.  Examples: >>> bell_numbers(-2) Traceback (most recent call last):     ... ValueError: max_set_length must be non-negative >>> bell_numbers(0) [1] >>> bell_numbers(1) [1, 1] >>> bell_numbers(5) [1, 1, 2, 5, 15, 52]","range, ValueError, range, _binomial_coefficient"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\bell_numbers.py","","_binomial_coefficient","Calculate the binomial coefficient C(total_elements, elements_to_choose)  Args:     total_elements (int): The total number of elements.     elements_to_choose (int): The number of elements to choose.  Returns:     int: The binomial coefficient C(total_elements, elements_to_choose).  Examples: >>> _binomial_coefficient(5, 2) 10 >>> _binomial_coefficient(6, 3) 20","min, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\carmichael_number.py","","power","Examples: >>> power(2, 15, 3) 2 >>> power(5, 1, 30) 5","power"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\carmichael_number.py","","is_carmichael_number","Examples: >>> is_carmichael_number(4) False >>> is_carmichael_number(561) True >>> is_carmichael_number(562) False >>> is_carmichael_number(900) False >>> is_carmichael_number(1105) True >>> is_carmichael_number(8911) True >>> is_carmichael_number(5.1) Traceback (most recent call last):      ... ValueError: Number 5.1 must instead be a positive integer  >>> is_carmichael_number(-7) Traceback (most recent call last):      ... ValueError: Number -7 must instead be a positive integer  >>> is_carmichael_number(0) Traceback (most recent call last):      ... ValueError: Number 0 must instead be a positive integer","all, ValueError, isinstance, power, range, greatest_common_divisor"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\catalan_number.py","","catalan",":param number: nth catalan number to calculate :return: the nth catalan number Note: A catalan number is only defined for positive integers  >>> catalan(5) 14 >>> catalan(0) Traceback (most recent call last):     ... ValueError: Input value of [number=0] must be > 0 >>> catalan(-1) Traceback (most recent call last):     ... ValueError: Input value of [number=-1] must be > 0 >>> catalan(5.0) Traceback (most recent call last):     ... TypeError: Input value of [number=5.0] must be an integer","range, isinstance, TypeError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\hamming_numbers.py","","hamming","This function creates an ordered list of n length as requested, and afterwards returns the last value of the list. It must be given a positive integer.  :param n_element: The number of elements on the list :return: The nth element of the list  >>> hamming(-5) Traceback (most recent call last):     ... ValueError: n_element should be a positive number >>> hamming(5) [1, 2, 3, 4, 5] >>> hamming(10) [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] >>> hamming(15) [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]","int, ValueError, hamming_list.append, min"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\happy_number.py","","is_happy_number","A happy number is a number which eventually reaches 1 when replaced by the sum of the square of each digit.  :param number: The number to check for happiness. :return: True if the number is a happy number, False otherwise.  >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(23) True >>> is_happy_number(1) True >>> is_happy_number(0) Traceback (most recent call last):     ... ValueError: number=0 must be a positive integer >>> is_happy_number(-19) Traceback (most recent call last):     ... ValueError: number=-19 must be a positive integer >>> is_happy_number(19.1) Traceback (most recent call last):     ... ValueError: number=19.1 must be a positive integer >>> is_happy_number(""happy"") Traceback (most recent call last):     ... ValueError: number='happy' must be a positive integer","set, ValueError, seen.add, sum, isinstance, int, str"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\harshad_numbers.py","","int_to_base","Convert a given positive decimal integer to base 'base'. Where 'base' ranges from 2 to 36.  Examples: >>> int_to_base(0, 21) '0' >>> int_to_base(23, 2) '10111' >>> int_to_base(58, 5) '213' >>> int_to_base(167, 16) 'A7' >>> # bases below 2 and beyond 36 will error >>> int_to_base(98, 1) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive >>> int_to_base(98, 37) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive >>> int_to_base(-99, 16) Traceback (most recent call last):     ... ValueError: number must be a positive integer","ValueError, ValueError, divmod"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\harshad_numbers.py","","sum_of_digits","Calculate the sum of digit values in a positive integer converted to the given 'base'. Where 'base' ranges from 2 to 36.  Examples: >>> sum_of_digits(103, 12) '13' >>> sum_of_digits(1275, 4) '30' >>> sum_of_digits(6645, 2) '1001' >>> # bases below 2 and beyond 36 will error >>> sum_of_digits(543, 1) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive >>> sum_of_digits(543, 37) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive","int_to_base, sum, int_to_base, ValueError, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\harshad_numbers.py","","harshad_numbers_in_base","Finds all Harshad numbers smaller than num in base 'base'. Where 'base' ranges from 2 to 36.  Examples: >>> harshad_numbers_in_base(15, 2) ['1', '10', '100', '110', '1000', '1010', '1100'] >>> harshad_numbers_in_base(12, 34) ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B'] >>> harshad_numbers_in_base(12, 4) ['1', '2', '3', '10', '12', '20', '21'] >>> # bases below 2 and beyond 36 will error >>> harshad_numbers_in_base(234, 37) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive >>> harshad_numbers_in_base(234, 1) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive >>> harshad_numbers_in_base(-12, 6) []","ValueError, int_to_base, range, int, sum_of_digits"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\harshad_numbers.py","","is_harshad_number_in_base","Determines whether n in base 'base' is a harshad number. Where 'base' ranges from 2 to 36.  Examples: >>> is_harshad_number_in_base(18, 10) True >>> is_harshad_number_in_base(21, 10) True >>> is_harshad_number_in_base(-21, 5) False >>> # bases below 2 and beyond 36 will error >>> is_harshad_number_in_base(45, 37) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive >>> is_harshad_number_in_base(45, 1) Traceback (most recent call last):     ... ValueError: 'base' must be between 2 and 36 inclusive","int_to_base, sum_of_digits, ValueError, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\hexagonal_number.py","","hexagonal",":param number: nth hexagonal number to calculate :return: the nth hexagonal number Note: A hexagonal number is only defined for positive integers >>> hexagonal(4) 28 >>> hexagonal(11) 231 >>> hexagonal(22) 946 >>> hexagonal(0) Traceback (most recent call last):     ... ValueError: Input must be a positive integer >>> hexagonal(-1) Traceback (most recent call last):     ... ValueError: Input must be a positive integer >>> hexagonal(11.0) Traceback (most recent call last):     ... TypeError: Input value of [number=11.0] must be an integer","isinstance, TypeError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\krishnamurthy_number.py","","factorial",">>> factorial(3) 6 >>> factorial(0) 1 >>> factorial(5) 120","factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\krishnamurthy_number.py","","krishnamurthy",">>> krishnamurthy(145) True >>> krishnamurthy(240) False >>> krishnamurthy(1) True","divmod, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\perfect_number.py","","perfect","Check if a number is a perfect number.  A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding itself).  Args:     number: The number to be checked.  Returns:     True if the number is a perfect number, False otherwise.  Start from 1 because dividing by 0 will raise ZeroDivisionError. A number at most can be divisible by the half of the number except the number itself. For example, 6 is at most can be divisible by 3 except by 6 itself.  Examples: >>> perfect(27) False >>> perfect(28) True >>> perfect(29) False >>> perfect(6) True >>> perfect(12) False >>> perfect(496) True >>> perfect(8128) True >>> perfect(0) False >>> perfect(-1) False >>> perfect(12.34) Traceback (most recent call last):   ... ValueError: number must be an integer >>> perfect(""Hello"") Traceback (most recent call last):   ... ValueError: number must be an integer","isinstance, ValueError, sum, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\polygonal_numbers.py","","polygonal_num","Returns the `num`th `sides`-gonal number. It is assumed that `num` >= 0 and `sides` >= 3 (see for reference https://en.wikipedia.org/wiki/Polygonal_number).  >>> polygonal_num(0, 3) 0 >>> polygonal_num(3, 3) 6 >>> polygonal_num(5, 4) 25 >>> polygonal_num(2, 5) 5 >>> polygonal_num(-1, 0) Traceback (most recent call last):     ... ValueError: Invalid input: num must be >= 0 and sides must be >= 3. >>> polygonal_num(0, 2) Traceback (most recent call last):     ... ValueError: Invalid input: num must be >= 0 and sides must be >= 3.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\pronic_number.py","","is_pronic","# doctest: +NORMALIZE_WHITESPACE This functions takes an integer number as input. returns True if the number is pronic. >>> is_pronic(-1) False >>> is_pronic(0) True >>> is_pronic(2) True >>> is_pronic(5) False >>> is_pronic(6) True >>> is_pronic(8) False >>> is_pronic(30) True >>> is_pronic(32) False >>> is_pronic(2147441940) True >>> is_pronic(9223372033963249500) True >>> is_pronic(6.0) Traceback (most recent call last):     ... TypeError: Input value of [number=6.0] must be an integer","int, isinstance, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\proth_number.py","","proth",":param number: nth number to calculate in the sequence :return: the nth number in Proth number Note: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3 >>> proth(6) 25 >>> proth(0) Traceback (most recent call last):     ... ValueError: Input value of [number=0] must be > 0 >>> proth(-1) Traceback (most recent call last):     ... ValueError: Input value of [number=-1] must be > 0 >>> proth(6.0) Traceback (most recent call last):     ... TypeError: Input value of [number=6.0] must be an integer","isinstance, TypeError, ValueError, range, int, range, math.log, proth_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\proth_number.py","","is_proth_number",":param number: positive integer number :return: true if number is a Proth number, false otherwise >>> is_proth_number(1) False >>> is_proth_number(2) False >>> is_proth_number(3) True >>> is_proth_number(4) False >>> is_proth_number(5) True >>> is_proth_number(34) False >>> is_proth_number(-1) Traceback (most recent call last):     ... ValueError: Input value of [number=-1] must be > 0 >>> is_proth_number(6.0) Traceback (most recent call last):     ... TypeError: Input value of [number=6.0] must be an integer","isinstance, TypeError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\triangular_numbers.py","","triangular_number","Generate the triangular number at the specified position.  Args:     position (int): The position of the triangular number to generate.  Returns:     int: The triangular number at the specified position.  Raises:     ValueError: If `position` is negative.  Examples: >>> triangular_number(1) 1 >>> triangular_number(3) 6 >>> triangular_number(-1) Traceback (most recent call last):     ... ValueError: param `position` must be non-negative","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\ugly_numbers.py","","ugly_numbers","Returns the nth ugly number. >>> ugly_numbers(100) 1536 >>> ugly_numbers(0) 1 >>> ugly_numbers(20) 36 >>> ugly_numbers(-5) 1 >>> ugly_numbers(-5.5) Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer","range, min, ugly_nums.append"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\weird_number.py","","factors",">>> factors(12) [1, 2, 3, 4, 6] >>> factors(1) [1] >>> factors(100) [1, 2, 4, 5, 10, 20, 25, 50]  # >>> factors(-12) # [1, 2, 3, 4, 6]","range, sorted, int, values.append, sqrt, int, values.append, int"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\weird_number.py","","abundant",">>> abundant(0) True >>> abundant(1) False >>> abundant(12) True >>> abundant(13) False >>> abundant(20) True  # >>> abundant(-12) # True","sum, factors"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\weird_number.py","","semi_perfect",">>> semi_perfect(0) True >>> semi_perfect(1) True >>> semi_perfect(12) True >>> semi_perfect(13) False  # >>> semi_perfect(-12) # True","factors, len, range, range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\maths\special_numbers\weird_number.py","","weird",">>> weird(0) False >>> weird(70) True >>> weird(77) False","abundant, semi_perfect"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\binary_search_matrix.py","","binary_search","This function carries out Binary search on a 1d array and return -1 if it do not exist array: A 1d sorted array value : the value meant to be searched >>> matrix = [1, 4, 7, 11, 15] >>> binary_search(matrix, 0, len(matrix) - 1, 1) 0 >>> binary_search(matrix, 0, len(matrix) - 1, 23) -1","int, binary_search, binary_search"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\binary_search_matrix.py","","mat_bin_search","This function loops over a 2d matrix and calls binarySearch on the selected 1d array and returns [-1, -1] is it do not exist value : value meant to be searched matrix = a sorted 2d matrix >>> matrix = [[1, 4, 7, 11, 15], ...           [2, 5, 8, 12, 19], ...           [3, 6, 9, 16, 22], ...           [10, 13, 14, 17, 24], ...           [18, 21, 23, 26, 30]] >>> target = 1 >>> mat_bin_search(target, matrix) [0, 0] >>> target = 34 >>> mat_bin_search(target, matrix) [-1, -1]","binary_search, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_islands_in_matrix.py","Matrix","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_islands_in_matrix.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_islands_in_matrix.py","","is_safe","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_islands_in_matrix.py","","diffs","","range, self.is_safe, self.diffs"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_islands_in_matrix.py","","count_islands","","range, range, range, range, self.diffs"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","generate_large_matrix",">>> generate_large_matrix() # doctest: +ELLIPSIS [[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]","list, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","validate_grid","Validate that the rows and columns of the grid is sorted in decreasing order. >>> for grid in test_grids: ...     validate_grid(grid)","all, all, sorted, list, sorted, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","find_negative_index","Find the smallest negative index  >>> find_negative_index([0,0,0,0]) 4 >>> find_negative_index([4,3,2,-1]) 3 >>> find_negative_index([1,0,-1,-10]) 2 >>> find_negative_index([0,0,0,-1]) 3 >>> find_negative_index([11,8,7,-3,-5,-9]) 3 >>> find_negative_index([-1,-1,-2,-3]) 0 >>> find_negative_index([5,1,0]) 3 >>> find_negative_index([-5,-5,-5]) 0 >>> find_negative_index([0]) 1 >>> find_negative_index([]) 0","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","count_negatives_binary_search","An O(m logn) solution that uses binary search in order to find the boundary between positive and negative numbers  >>> [count_negatives_binary_search(grid) for grid in test_grids] [8, 0, 0, 3, 1498500]","len, range, len, find_negative_index, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","count_negatives_brute_force","This solution is O(n^2) because it iterates through every column and row.  >>> [count_negatives_brute_force(grid) for grid in test_grids] [8, 0, 0, 3, 1498500]","len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","count_negatives_brute_force_with_break","Similar to the brute force solution above but uses break in order to reduce the number of iterations.  >>> [count_negatives_brute_force_with_break(grid) for grid in test_grids] [8, 0, 0, 3, 1498500]","enumerate, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_negative_numbers_in_sorted_matrix.py","","benchmark","Benchmark our functions next to each other","print, timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\count_paths.py","","depth_first_search","Recursive Backtracking Depth First Search Algorithm  Starting from top left of a matrix, count the number of paths that can reach the bottom right of a matrix. 1 represents a block (inaccessible) 0 represents a valid space (accessible)  0  0  0  0 1  1  0  0 0  0  0  1 0  1  0  0 >>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]] >>> depth_first_search(grid, 0, 0, set()) 2  0  0  0  0  0 0  1  1  1  0 0  1  1  1  0 0  0  0  0  0 >>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]] >>> depth_first_search(grid, 0, 0, set()) 2","visit.add, depth_first_search, depth_first_search, depth_first_search, depth_first_search, visit.remove, len, len, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\cramers_rule_2x2.py","","cramers_rule_2x2","Solves the system of linear equation in 2 variables. :param: equation1: list of 3 numbers :param: equation2: list of 3 numbers :return: String of result input format : [a1, b1, d1], [a2, b2, d2] determinant = [[a1, b1], [a2, b2]] determinant_x = [[d1, b1], [d2, b2]] determinant_y = [[a1, d1], [a2, d2]]  >>> cramers_rule_2x2([2, 3, 0], [5, 1, 0]) (0.0, 0.0) >>> cramers_rule_2x2([0, 4, 50], [2, 0, 26]) (13.0, 12.5) >>> cramers_rule_2x2([11, 2, 30], [1, 0, 4]) (4.0, -7.0) >>> cramers_rule_2x2([4, 7, 1], [1, 2, 0]) (2.0, -1.0)  >>> cramers_rule_2x2([1, 2, 3], [2, 4, 6]) Traceback (most recent call last):     ... ValueError: Infinite solutions. (Consistent system) >>> cramers_rule_2x2([1, 2, 3], [2, 4, 7]) Traceback (most recent call last):     ... ValueError: No solution. (Inconsistent system) >>> cramers_rule_2x2([1, 2, 3], [11, 22]) Traceback (most recent call last):     ... ValueError: Please enter a valid equation. >>> cramers_rule_2x2([0, 1, 6], [0, 0, 3]) Traceback (most recent call last):     ... ValueError: No solution. (Inconsistent system) >>> cramers_rule_2x2([0, 0, 6], [0, 0, 3]) Traceback (most recent call last):     ... ValueError: Both a & b of two equations can't be zero. >>> cramers_rule_2x2([1, 2, 3], [1, 2, 3]) Traceback (most recent call last):     ... ValueError: Infinite solutions. (Consistent system) >>> cramers_rule_2x2([0, 4, 50], [0, 3, 99]) Traceback (most recent call last):     ... ValueError: No solution. (Inconsistent system)","ValueError, ValueError, len, len, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\inverse_of_matrix.py","","inverse_of_matrix","A matrix multiplied with its inverse gives the identity matrix. This function finds the inverse of a 2x2 and 3x3 matrix. If the determinant of a matrix is 0, its inverse does not exist.  Sources for fixing inaccurate float arithmetic: https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python https://docs.python.org/3/library/decimal.html  Doctests for 2x2 >>> inverse_of_matrix([[2, 5], [2, 0]]) [[0.0, 0.5], [0.2, -0.2]] >>> inverse_of_matrix([[2.5, 5], [1, 2]]) Traceback (most recent call last):     ... ValueError: This matrix has no inverse. >>> inverse_of_matrix([[12, -16], [-9, 0]]) [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]] >>> inverse_of_matrix([[12, 3], [16, 8]]) [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]] >>> inverse_of_matrix([[10, 5], [3, 2.5]]) [[0.25, -0.5], [-0.3, 1.0]]  Doctests for 3x3 >>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]]) [[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]] >>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]]) Traceback (most recent call last):     ... ValueError: This matrix has no inverse.  >>> inverse_of_matrix([[],[]]) Traceback (most recent call last):     ... ValueError: Please provide a matrix of size 2x2 or 3x3.  >>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]]) Traceback (most recent call last):     ... ValueError: Please provide a matrix of size 2x2 or 3x3.  >>> inverse_of_matrix([[1, 2, 1], [0,3, 4]]) Traceback (most recent call last):     ... ValueError: Please provide a matrix of size 2x2 or 3x3.  >>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]]) Traceback (most recent call last):     ... ValueError: This matrix has no inverse.  >>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]","ValueError, float, len, len, len, ValueError, float, array, range, array, range, len, len, len, len, ValueError, range, range, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, float, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, float, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\largest_square_area_in_matrix.py","","largest_square_area_in_matrix_top_down_approch","Function updates the largest_square_area[0], if recursive call found square with maximum area.  We aren't using dp_array here, so the time complexity would be exponential.  >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]]) 2 >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]]) 0","update_area_of_max_square, update_area_of_max_square, update_area_of_max_square, update_area_of_max_square, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\largest_square_area_in_matrix.py","","largest_square_area_in_matrix_top_down_approch_with_dp","Function updates the largest_square_area[0], if recursive call found square with maximum area.  We are using dp_array here, so the time complexity would be O(N^2).  >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]]) 2 >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]]) 0","update_area_of_max_square_using_dp_array, update_area_of_max_square_using_dp_array, update_area_of_max_square_using_dp_array, update_area_of_max_square_using_dp_array, max, range, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\largest_square_area_in_matrix.py","","largest_square_area_in_matrix_bottom_up","Function updates the largest_square_area, using bottom up approach.  >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]]) 2 >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]]) 0","range, range, range, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\largest_square_area_in_matrix.py","","largest_square_area_in_matrix_bottom_up_space_optimization","Function updates the largest_square_area, using bottom up approach. with space optimization.  >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]]) 2 >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]]) 0","range, range, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\largest_square_area_in_matrix.py","","update_area_of_max_square","","update_area_of_max_square, update_area_of_max_square, update_area_of_max_square, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\largest_square_area_in_matrix.py","","update_area_of_max_square_using_dp_array","","update_area_of_max_square_using_dp_array, update_area_of_max_square_using_dp_array, update_area_of_max_square_using_dp_array, max, min"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","validate_matrix_size",">>> validate_matrix_size(-1) Traceback (most recent call last):     ... ValueError: Matrix size must be a positive integer.","ValueError, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","validate_matrix_content","Validates that the number of elements in the matrix matches the given size.  >>> validate_matrix_content(['aaaa', 'aaaa', 'aaaa', 'aaaa'], 3) Traceback (most recent call last):     ... ValueError: The matrix dont match with size. >>> validate_matrix_content(['aa%', 'aaa', 'aaa'], 3) Traceback (most recent call last):     ... ValueError: Matrix rows can only contain letters and numbers. >>> validate_matrix_content(['aaa', 'aaa', 'aaaa'], 3) Traceback (most recent call last):     ... ValueError: Each row in the matrix must have exactly 3 characters.","print, len, ValueError, len, ValueError, all, ValueError, char.isalnum"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","validate_moves",">>> validate_moves([(1, 2), (-1, 0)], 3) Traceback (most recent call last):     ... ValueError: Move is out of bounds for a matrix.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","parse_moves",">>> parse_moves(""0 1, 1 1"") [(0, 1), (1, 1)] >>> parse_moves(""0 1, 1 1, 2"") Traceback (most recent call last):     ... ValueError: Each move must have exactly two numbers. >>> parse_moves(""0 1, 1 1, 2 4 5 6"") Traceback (most recent call last):     ... ValueError: Each move must have exactly two numbers.","input_str.split, .split, map, moves.append, len, ValueError, pair.strip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","find_repeat","Finds all connected elements of the same type from a given position.  >>> find_repeat([['A', 'B', 'A'], ['A', 'B', 'A'], ['A', 'A', 'A']], 0, 0, 3) {(1, 2), (2, 1), (0, 0), (2, 0), (0, 2), (2, 2), (1, 0)} >>> find_repeat([['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']], 1, 1, 3) set()","set, set, dfs, visited.add, repeated.add, dfs, dfs, dfs, dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","increment_score","Calculates the score for a move based on the number of elements removed.  >>> increment_score(3) 6 >>> increment_score(0) 0","int"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","move_x","Simulates gravity in a specific column.  >>> move_x([['-', 'A'], ['-', '-'], ['-', 'C']], 1, 2) [['-', '-'], ['-', 'A'], ['-', 'C']]","range, range, new_list.append, new_list.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","move_y","Shifts all columns leftward when an entire column becomes empty.  >>> move_y([['-', 'A'], ['-', '-'], ['-', 'C']], 2) [['A', '-'], ['-', '-'], ['-', 'C']]","range, all, range, range, empty_columns.append, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","play","Processes a single move, updating the matrix and calculating the score.  >>> play([['R', 'G'], ['R', 'G']], 0, 0, 2) ([['G', '-'], ['G', '-']], 3)","find_repeat, len, range, move_y, increment_score, move_x, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","process_game","Processes the game logic for the given matrix and moves.  Args:     size (int): Size of the game board.     matrix (List[str]): Initial game matrix.     moves (List[Tuple[int, int]]): List of moves as (x, y) coordinates.  Returns:     int: The total score obtained. >>> process_game(3, ['aaa', 'bbb', 'ccc'], [(0, 0)]) 6","list, play"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_based_game.py","","dfs","","visited.add, repeated.add, dfs, dfs, dfs, dfs"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","Matrix","","Matrix object generated from a 2D array where each element is an array representing a row. Rows can contain type int or float. Common operations and information available. >>> rows = [ ...     [1, 2, 3], ...     [4, 5, 6], ...     [7, 8, 9] ... ] >>> matrix = Matrix(rows) >>> print(matrix) [[1. 2. 3.]  [4. 5. 6.]  [7. 8. 9.]]  Matrix rows and columns are available as 2D arrays >>> matrix.rows [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> matrix.columns() [[1, 4, 7], [2, 5, 8], [3, 6, 9]]  Order is returned as a tuple >>> matrix.order (3, 3)  Squareness and invertability are represented as bool >>> matrix.is_square True >>> matrix.is_invertable() False  Identity, Minors, Cofactors and Adjugate are returned as Matrices.  Inverse can be a Matrix or Nonetype >>> print(matrix.identity()) [[1. 0. 0.]  [0. 1. 0.]  [0. 0. 1.]] >>> print(matrix.minors()) [[-3. -6. -3.]  [-6. -12. -6.]  [-3. -6. -3.]] >>> print(matrix.cofactors()) [[-3. 6. -3.]  [6. -12. 6.]  [-3. 6. -3.]] >>>  # won't be apparent due to the nature of the cofactor matrix >>> print(matrix.adjugate()) [[-3. 6. -3.]  [6. -12. 6.]  [-3. 6. -3.]] >>> matrix.inverse() Traceback (most recent call last):     ... TypeError: Only matrices with a non-zero determinant have an inverse  Determinant is an int, float, or Nonetype >>> matrix.determinant() 0  Negation, scalar multiplication, addition, subtraction, multiplication and exponentiation are available and all return a Matrix >>> print(-matrix) [[-1. -2. -3.]  [-4. -5. -6.]  [-7. -8. -9.]] >>> matrix2 = matrix * 3 >>> print(matrix2) [[3. 6. 9.]  [12. 15. 18.]  [21. 24. 27.]] >>> print(matrix + matrix2) [[4. 8. 12.]  [16. 20. 24.]  [28. 32. 36.]] >>> print(matrix - matrix2) [[-2. -4. -6.]  [-8. -10. -12.]  [-14. -16. -18.]] >>> print(matrix ** 3) [[468. 576. 684.]  [1062. 1305. 1548.]  [1656. 2034. 2412.]]  Matrices can also be modified >>> matrix.add_row([10, 11, 12]) >>> print(matrix) [[1. 2. 3.]  [4. 5. 6.]  [7. 8. 9.]  [10. 11. 12.]] >>> matrix2.add_column([8, 16, 32]) >>> print(matrix2) [[3. 6. 9. 8.]  [12. 15. 18. 16.]  [21. 24. 27. 32.]] >>> print(matrix *  matrix2) [[90. 108. 126. 136.]  [198. 243. 288. 304.]  [306. 378. 450. 472.]  [414. 513. 612. 640.]]",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__init__","","TypeError, len, len, len, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","columns","","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","num_rows","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","num_columns","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","order","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","is_square","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","identity","","Matrix, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","determinant","","int, int, sum, range, self.cofactors"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","is_invertable","","bool, self.determinant"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","get_minor","",".determinant, range, Matrix, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","get_cofactor","","self.get_minor, self.get_minor"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","minors","","Matrix, self.get_minor, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","cofactors","","Matrix, range, range, self.minors, self.minors, self.minors, self.minors"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","adjugate","","Matrix, range, range, self.cofactors"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","inverse","","self.determinant, TypeError, self.adjugate"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__repr__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__str__","",".join, .join, str, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","add_row","","TypeError, isinstance, len, ValueError, self.rows.append, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","add_column","","TypeError, isinstance, len, ValueError, isinstance, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__eq__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__ne__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__neg__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__add__","","Matrix, ValueError, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__sub__","","Matrix, ValueError, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__mul__","","isinstance, Matrix, isinstance, Matrix, TypeError, ValueError, int, Matrix.dot_product, other.columns"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","__pow__","","range, isinstance, TypeError, ValueError, self.identity, self.is_invertable, ValueError, self.inverse"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_class.py","","dot_product","","sum, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_equalization.py","","array_equalization","This algorithm equalizes all elements of the input vector to a common value, by making the minimal number of ""updates"" under the constraint of a step size (step_size).  >>> array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4) 4 >>> array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2) 5 >>> array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5) 0 >>> array_equalization([22, 22, 22, 33, 33, 33], 2) 2 >>> array_equalization([1, 2, 3], 0) Traceback (most recent call last): ValueError: Step size must be positive and non-zero. >>> array_equalization([1, 2, 3], -1) Traceback (most recent call last): ValueError: Step size must be positive and non-zero. >>> array_equalization([1, 2, 3], 0.5) Traceback (most recent call last): ValueError: Step size must be an integer. >>> array_equalization([1, 2, 3], maxsize) 1","set, ValueError, isinstance, ValueError, min, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_multiplication_recursion.py","","is_square",">>> is_square([]) True >>> is_square(matrix_1_to_4) True >>> is_square(matrix_5_to_9_high) False","len, all, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_multiplication_recursion.py","","matrix_multiply",">>> matrix_multiply(matrix_1_to_4, matrix_5_to_8) [[19, 22], [43, 50]]","sum, zip, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_multiplication_recursion.py","","matrix_multiply_recursive",":param matrix_a: A square Matrix. :param matrix_b: Another square Matrix with the same dimensions as matrix_a. :return: Result of matrix_a * matrix_b. :raises ValueError: If the matrices cannot be multiplied.  >>> matrix_multiply_recursive([], []) [] >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8) [[19, 22], [43, 50]] >>> matrix_multiply_recursive(matrix_count_up, matrix_unordered) [[37, 61, 74, 61], [105, 165, 166, 129], [173, 269, 258, 197], [241, 373, 350, 265]] >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_wide) Traceback (most recent call last):     ... ValueError: Invalid matrix dimensions >>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_high) Traceback (most recent call last):     ... ValueError: Invalid matrix dimensions >>> matrix_multiply_recursive(matrix_1_to_4, matrix_count_up) Traceback (most recent call last):     ... ValueError: Invalid matrix dimensions","multiply, all, ValueError, multiply, len, range, len, len, multiply, len, multiply, is_square, is_square, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_multiplication_recursion.py","","multiply",":param matrix_a: A square Matrix. :param matrix_b: Another square Matrix with the same dimensions as matrix_a. :param result: Result matrix :param i: Index used for iteration during multiplication. :param j: Index used for iteration during multiplication. :param k: Index used for iteration during multiplication. >>> 0 > 1  # Doctests in inner functions are never run True","multiply, len, len, multiply, len, multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","add",">>> add([[1,2],[3,4]],[[2,3],[4,5]]) [[3, 5], [7, 9]] >>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]]) [[3.2, 5.4], [7, 9]] >>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]]) [[7, 14], [12, 16]] >>> add([3], [4, 5]) Traceback (most recent call last):   ... TypeError: Expected a matrix, got int/list instead","all, TypeError, _check_not_integer, _verify_matrix_sizes, sum, zip, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","subtract",">>> subtract([[1,2],[3,4]],[[2,3],[4,5]]) [[-1, -1], [-1, -1]] >>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]]) [[-1, -0.5], [-1, -1.5]] >>> subtract([3], [4, 5]) Traceback (most recent call last):   ... TypeError: Expected a matrix, got int/list instead","TypeError, _check_not_integer, _check_not_integer, _verify_matrix_sizes, zip, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","scalar_multiply",">>> scalar_multiply([[1,2],[3,4]],5) [[5, 10], [15, 20]] >>> scalar_multiply([[1.4,2.3],[3,4]],5) [[7.0, 11.5], [15, 20]]",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","multiply",">>> multiply([[1,2],[3,4]],[[5,5],[7,5]]) [[19, 15], [43, 35]] >>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]]) [[22.5, 17.5], [46.5, 37.5]] >>> multiply([[1, 2, 3]], [[2], [3], [4]]) [[20]]","_check_not_integer, _check_not_integer, _verify_matrix_sizes, ValueError, sum, zip, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","identity",":param n: dimension for nxn matrix :type n: int :return: Identity matrix of shape [n, n] >>> identity(3) [[1, 0, 0], [0, 1, 0], [0, 0, 1]]","int, int, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","transpose",">>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS <map object at ... >>> transpose([[1,2],[3,4]], return_map=False) [[1, 3], [2, 4]] >>> transpose([1, [2, 3]]) Traceback (most recent call last):   ... TypeError: Expected a matrix, got int/list instead","_check_not_integer, TypeError, map, list, zip, map, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","minor",">>> minor([[1, 2], [3, 4]], 1, 1) [[1]]",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","determinant",">>> determinant([[1, 2], [3, 4]]) -2 >>> determinant([[1.5, 2.5], [3, 4]]) -1.5","sum, len, enumerate, determinant, minor"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","inverse",">>> inverse([[1, 2], [3, 4]]) [[-2.0, 1.0], [1.5, -0.5]] >>> inverse([[1, 1], [1, 1]])","determinant, list, scalar_multiply, transpose, determinant, range, range, minor, range, len, enumerate, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","_check_not_integer","","isinstance, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","_shape","","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","_verify_matrix_sizes","","_shape, _shape, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\matrix_operation.py","","main","","print, print, print, print, print, print, add, multiply, identity, minor, determinant, inverse"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\max_area_of_island.py","","is_safe","Checking whether coordinate (row, col) is valid or not.  >>> is_safe(0, 0, 5, 5) True >>> is_safe(-1,-1, 5, 5) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\max_area_of_island.py","","depth_first_search","Returns the current area of the island  >>> depth_first_search(0, 0, set(), matrix) 0","len, len, is_safe, seen.add, depth_first_search, depth_first_search, depth_first_search, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\max_area_of_island.py","","find_max_area","Finds the area of all islands and returns the maximum area.  >>> find_max_area(matrix) 6","set, enumerate, enumerate, max, depth_first_search"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\median_matrix.py","","median","Calculate the median of a sorted matrix.  Args:     matrix: A 2D matrix of integers.  Returns:     The median value of the matrix.  Examples:     >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]     >>> median(matrix)     5      >>> matrix = [[1, 2, 3], [4, 5, 6]]     >>> median(matrix)     3","sorted, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\nth_fibonacci_using_matrix_exponentiation.py","","multiply","","len, range, range, matrix_c.append, range, list_1.append"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\nth_fibonacci_using_matrix_exponentiation.py","","identity","","int, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\nth_fibonacci_using_matrix_exponentiation.py","","nth_fibonacci_matrix",">>> nth_fibonacci_matrix(100) 354224848179261915075 >>> nth_fibonacci_matrix(-100) -100","identity, multiply, int, multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\nth_fibonacci_using_matrix_exponentiation.py","","nth_fibonacci_bruteforce",">>> nth_fibonacci_bruteforce(100) 354224848179261915075 >>> nth_fibonacci_bruteforce(-100) -100","range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\nth_fibonacci_using_matrix_exponentiation.py","","main","",".split, int, print, .join, nth_fibonacci_matrix, nth_fibonacci_bruteforce"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","print_pascal_triangle","Print Pascal's triangle for different number of rows >>> print_pascal_triangle(5)     1    1 1   1 2 1  1 3 3 1 1 4 6 4 1","generate_pascal_triangle, range, range, range, print, print, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","generate_pascal_triangle","Create Pascal's triangle for different number of rows >>> generate_pascal_triangle(0) [] >>> generate_pascal_triangle(1) [[1]] >>> generate_pascal_triangle(2) [[1], [1, 1]] >>> generate_pascal_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascal_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascal_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascal_triangle(-5) Traceback (most recent call last):     ... ValueError: The input value of 'num_rows' should be greater than or equal to 0 >>> generate_pascal_triangle(7.89) Traceback (most recent call last):     ... TypeError: The input value of 'num_rows' should be 'int'","range, isinstance, TypeError, populate_current_row, triangle.append, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","populate_current_row",">>> triangle = [[1]] >>> populate_current_row(triangle, 1) [1, 1]","range, calculate_current_element"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","calculate_current_element",">>> triangle = [[1], [1, 1]] >>> current_row = [1, -1, 1] >>> calculate_current_element(triangle, current_row, 2, 1) >>> current_row [1, 2, 1]",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","generate_pascal_triangle_optimized","This function returns a matrix representing the corresponding pascal's triangle according to the given input of number of rows of Pascal's triangle to be generated. It reduces the operations done to generate a row by half by eliminating redundant calculations.  :param num_rows: Integer specifying the number of rows in the Pascal's triangle :return: 2-D List (matrix) representing the Pascal's triangle  Return the Pascal's triangle of given rows >>> generate_pascal_triangle_optimized(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascal_triangle_optimized(1) [[1]] >>> generate_pascal_triangle_optimized(0) [] >>> generate_pascal_triangle_optimized(-5) Traceback (most recent call last):     ... ValueError: The input value of 'num_rows' should be greater than or equal to 0 >>> generate_pascal_triangle_optimized(7.89) Traceback (most recent call last):     ... TypeError: The input value of 'num_rows' should be 'int'","range, isinstance, TypeError, sum, row_second_half.reverse, result.append, ValueError, divmod, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","benchmark","Benchmark multiple functions, with three different length int values.","range, timeit, print, print, benchmark_a_function"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\pascal_triangle.py","","benchmark_a_function","","timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","make_matrix",">>> make_matrix() [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] >>> make_matrix(1) [[1]] >>> make_matrix(-2) [[1, 2], [3, 4]] >>> make_matrix(3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> make_matrix() == make_matrix(4) True","abs, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","rotate_90",">>> rotate_90(make_matrix()) [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]] >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix())) True","reverse_row, transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","rotate_180",">>> rotate_180(make_matrix()) [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]] >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix())) True","reverse_row, reverse_column"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","rotate_270",">>> rotate_270(make_matrix()) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix())) True","reverse_column, transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","transpose","","list, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","reverse_row","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","reverse_column","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\rotate_matrix.py","","print_matrix","","print"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\searching_in_sorted_matrix.py","","search_in_a_sorted_matrix",">>> search_in_a_sorted_matrix( ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5) Key 5 found at row- 1 column- 2 >>> search_in_a_sorted_matrix( ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21) Key 21 not found >>> search_in_a_sorted_matrix( ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1) Key 2.1 found at row- 1 column- 1 >>> search_in_a_sorted_matrix( ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2) Key 2.2 not found","print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\searching_in_sorted_matrix.py","","main","","int, print, search_in_a_sorted_matrix, input, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","Matrix","","<class Matrix> Matrix structure.",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__init__","<method Matrix.__init__> Initialize matrix with given size and default value. Example: >>> a = Matrix(2, 3, 1) >>> a Matrix consist of 2 rows and 3 columns [1, 1, 1] [1, 1, 1]","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__str__","<method Matrix.__str__> Return string representation of this matrix.",".join, .join, max, single_line, len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__repr__","","str"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","validate_indices","<method Matrix.validate_indicies> Check if given indices are valid to pick element from matrix. Example: >>> a = Matrix(2, 6, 0) >>> a.validate_indices((2, 7)) False >>> a.validate_indices((0, 0)) True","isinstance, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__getitem__","<method Matrix.__getitem__> Return array[row][column] where loc = (row, column). Example: >>> a = Matrix(3, 2, 7) >>> a[1, 0] 7","self.validate_indices"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__setitem__","<method Matrix.__setitem__> Set array[row][column] = value where loc = (row, column). Example: >>> a = Matrix(2, 3, 1) >>> a[1, 2] = 51 >>> a Matrix consist of 2 rows and 3 columns [ 1,  1,  1] [ 1,  1, 51]","self.validate_indices"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__add__","<method Matrix.__add__> Return self + another. Example: >>> a = Matrix(2, 1, -4) >>> b = Matrix(2, 1, 3) >>> a+b Matrix consist of 2 rows and 1 columns [-1] [-1]","isinstance, Matrix, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__neg__","<method Matrix.__neg__> Return -self. Example: >>> a = Matrix(2, 2, 3) >>> a[0, 1] = a[1, 0] = -2 >>> -a Matrix consist of 2 rows and 2 columns [-3,  2] [ 2, -3]","Matrix, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__sub__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","__mul__","<method Matrix.__mul__> Return self * another. Example: >>> a = Matrix(2, 3, 1) >>> a[0,2] = a[1,2] = 3 >>> a * -2 Matrix consist of 2 rows and 3 columns [-2, -2, -6] [-2, -2, -6]","isinstance, Matrix, range, isinstance, range, Matrix, range, TypeError, range, range, type"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","transpose","<method Matrix.transpose> Return self^T. Example: >>> a = Matrix(2, 3) >>> for r in range(2): ...     for c in range(3): ...             a[r,c] = r*c ... >>> a.transpose() Matrix consist of 3 rows and 2 columns [0, 0] [0, 1] [0, 2]","Matrix, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","sherman_morrison","<method Matrix.sherman_morrison> Apply Sherman-Morrison formula in O(n^2). To learn this formula, please look this: https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula This method returns (A + uv^T)^(-1) where A^(-1) is self. Returns None if it's impossible to calculate. Warning: This method doesn't check if self is invertible.     Make sure self is invertible before execute this method. Example: >>> ainv = Matrix(3, 3, 0) >>> for i in range(3): ainv[i,i] = 1 ... >>> u = Matrix(3, 1, 0) >>> u[0,0], u[1,0], u[2,0] = 1, 2, -3 >>> v = Matrix(3, 1, 0) >>> v[0,0], v[1,0], v[2,0] = 4, -2, 5 >>> ainv.sherman_morrison(u, v) Matrix consist of 3 rows and 3 columns [  1.2857142857142856, -0.14285714285714285,   0.3571428571428571] [  0.5714285714285714,   0.7142857142857143,   0.7142857142857142] [ -0.8571428571428571,  0.42857142857142855,  -0.0714285714285714]","isinstance, isinstance, v.transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","test1","","Matrix, range, print, Matrix, Matrix, print, print, print, print, ainv.sherman_morrison, v.transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","test2","","doctest.testmod"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\sherman_morrison.py","","single_line","",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\spiral_print.py","","check_matrix","","list, isinstance, isinstance, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\spiral_print.py","","spiral_print_clockwise",">>> spiral_print_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) 1 2 3 4 8 12 11 10 9 5 6 7","check_matrix, len, isinstance, range, range, range, print, len, list, len, print, print, range, print, len, spiral_print_clockwise, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\spiral_print.py","","spiral_traversal",">>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]  Example: matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] Algorithm:     Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the             output of [step 2])     Step 2. Now perform matrix's Transpose operation (Change rows to column             and vice versa) and reverse the resultant matrix.     Step 3. Pass the output of [2nd step], to same recursive function till             base case hits. Dry Run: Stage 1. [1, 2, 3, 4] +   spiral_traversal([     [8, 12], [7, 11], [6, 10], [5, 9]]  ]) Stage 2. [1, 2, 3, 4, 8, 12] + spiral_traversal([     [11, 10, 9], [7, 6, 5] ]) Stage 3. [1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([     [5], [6], [7] ]) Stage 4. [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([     [5], [6], [7] ]) Stage 5. [1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]]) Stage 6. [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])","list, spiral_traversal, matrix.pop, list, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\validate_sudoku_board.py","","is_valid_sudoku_board","This function validates (but does not solve) a sudoku board. The board may be valid but unsolvable.  >>> is_valid_sudoku_board([ ...  [""5"",""3"",""."",""."",""7"",""."",""."",""."","".""] ... ,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""] ... ,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""] ... ,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""] ... ,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""] ... ,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""] ... ,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""] ... ,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""] ... ,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""] ... ]) True >>> is_valid_sudoku_board([ ...  [""8"",""3"",""."",""."",""7"",""."",""."",""."","".""] ... ,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""] ... ,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""] ... ,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""] ... ,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""] ... ,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""] ... ,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""] ... ,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""] ... ,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""] ... ]) False >>> is_valid_sudoku_board([ ...  [""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9""] ... ,[""4"",""5"",""6"",""7"",""8"",""9"",""1"",""2"",""3""] ... ,[""7"",""8"",""9"",""1"",""2"",""3"",""4"",""5"",""6""] ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""] ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""] ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""] ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""] ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""] ... ,[""."",""."",""."",""."",""."",""."",""."",""."","".""] ... ]) True >>> is_valid_sudoku_board([ ...  [""1"",""2"",""3"",""."",""."",""."",""."",""."","".""] ... ,[""4"",""5"",""6"",""."",""."",""."",""."",""."","".""] ... ,[""7"",""8"",""9"",""."",""."",""."",""."",""."","".""] ... ,[""."",""."",""."",""4"",""5"",""6"",""."",""."","".""] ... ,[""."",""."",""."",""7"",""8"",""9"",""."",""."","".""] ... ,[""."",""."",""."",""1"",""2"",""3"",""."",""."","".""] ... ,[""."",""."",""."",""."",""."",""."",""7"",""8"",""9""] ... ,[""."",""."",""."",""."",""."",""."",""1"",""2"",""3""] ... ,[""."",""."",""."",""."",""."",""."",""4"",""5"",""6""] ... ]) True >>> is_valid_sudoku_board([ ...  [""1"",""2"",""3"",""."",""."",""."",""5"",""6"",""4""] ... ,[""4"",""5"",""6"",""."",""."",""."",""8"",""9"",""7""] ... ,[""7"",""8"",""9"",""."",""."",""."",""2"",""3"",""1""] ... ,[""."",""."",""."",""4"",""5"",""6"",""."",""."","".""] ... ,[""."",""."",""."",""7"",""8"",""9"",""."",""."","".""] ... ,[""."",""."",""."",""1"",""2"",""3"",""."",""."","".""] ... ,[""3"",""1"",""2"",""."",""."",""."",""7"",""8"",""9""] ... ,[""6"",""4"",""5"",""."",""."",""."",""1"",""2"",""3""] ... ,[""9"",""7"",""8"",""."",""."",""."",""4"",""5"",""6""] ... ]) True >>> is_valid_sudoku_board([ ...  [""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9""] ... ,[""2"",""."",""."",""."",""."",""."",""."",""."",""8""] ... ,[""3"",""."",""."",""."",""."",""."",""."",""."",""7""] ... ,[""4"",""."",""."",""."",""."",""."",""."",""."",""6""] ... ,[""5"",""."",""."",""."",""."",""."",""."",""."",""5""] ... ,[""6"",""."",""."",""."",""."",""."",""."",""."",""4""] ... ,[""7"",""."",""."",""."",""."",""."",""."",""."",""3""] ... ,[""8"",""."",""."",""."",""."",""."",""."",""."",""2""] ... ,[""9"",""8"",""7"",""6"",""5"",""4"",""3"",""2"",""1""] ... ]) False >>> is_valid_sudoku_board([ ...  [""1"",""2"",""3"",""8"",""9"",""7"",""5"",""6"",""4""] ... ,[""4"",""5"",""6"",""2"",""3"",""1"",""8"",""9"",""7""] ... ,[""7"",""8"",""9"",""5"",""6"",""4"",""2"",""3"",""1""] ... ,[""2"",""3"",""1"",""4"",""5"",""6"",""9"",""7"",""8""] ... ,[""5"",""6"",""4"",""7"",""8"",""9"",""3"",""1"",""2""] ... ,[""8"",""9"",""7"",""1"",""2"",""3"",""6"",""4"",""5""] ... ,[""3"",""1"",""2"",""6"",""4"",""5"",""7"",""8"",""9""] ... ,[""6"",""4"",""5"",""9"",""7"",""8"",""1"",""2"",""3""] ... ,[""9"",""7"",""8"",""3"",""1"",""2"",""4"",""5"",""6""] ... ]) True >>> is_valid_sudoku_board([[""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""]]) Traceback (most recent call last):     ... ValueError: Sudoku boards must be 9x9 squares. >>> is_valid_sudoku_board( ...        [[""1""], [""2""], [""3""], [""4""], [""5""], [""6""], [""7""], [""8""], [""9""]] ...  ) Traceback (most recent call last):     ... ValueError: Sudoku boards must be 9x9 squares.","defaultdict, defaultdict, defaultdict, range, any, ValueError, range, len, .add, .add, .add, len"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\tests\test_matrix_operation.py","","test_addition","","pytest.mark.parametrize, logger.info, pytest.raises, matop.add, logger.info, .tolist, matop.add, logger.info, np.array, np.array, np.array, np.array, pytest.raises, matop.add, np.array, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\tests\test_matrix_operation.py","","test_subtraction","","pytest.mark.parametrize, logger.info, pytest.raises, matop.subtract, logger.info, .tolist, matop.subtract, logger.info, np.array, np.array, np.array, np.array, pytest.raises, matop.subtract, np.array, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\tests\test_matrix_operation.py","","test_multiplication","","pytest.mark.parametrize, logger.info, pytest.raises, matop.add, logger.info, .tolist, matop.multiply, logger.info, np.array, np.array, np.array, np.array, pytest.raises, matop.subtract, np.matmul"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\tests\test_matrix_operation.py","","test_scalar_multiply","",".tolist, matop.scalar_multiply, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\tests\test_matrix_operation.py","","test_identity","",".tolist, matop.identity, np.identity"
"C:/Users/Joseph Dania/Desktop/python_repo\matrix\tests\test_matrix_operation.py","","test_transpose","","pytest.mark.parametrize, logger.info, .tolist, matop.transpose, np.array, pytest.raises, matop.transpose, np.transpose"
"C:/Users/Joseph Dania/Desktop/python_repo\networking_flow\ford_fulkerson.py","","breadth_first_search","This function returns True if there is a node that has not iterated.  Args:     graph: Adjacency matrix of graph     source: Source     sink: Sink     parents: Parent list  Returns:     True if there is a node that has not iterated.  >>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1]) True >>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1]) Traceback (most recent call last):     ... IndexError: list index out of range","queue.append, len, queue.pop, enumerate, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\networking_flow\ford_fulkerson.py","","ford_fulkerson","This function returns the maximum flow from source to sink in the given graph.  CAUTION: This function changes the given graph.  Args:     graph: Adjacency matrix of graph     source: Source     sink: Sink  Returns:     Maximum flow  >>> test_graph = [ ...     [0, 16, 13, 0, 0, 0], ...     [0, 0, 10, 12, 0, 0], ...     [0, 4, 0, 0, 14, 0], ...     [0, 0, 9, 0, 0, 20], ...     [0, 0, 0, 7, 0, 4], ...     [0, 0, 0, 0, 0, 0], ... ] >>> ford_fulkerson(test_graph, 0, 5) 23","breadth_first_search, len, int, min"
"C:/Users/Joseph Dania/Desktop/python_repo\networking_flow\minimum_cut.py","","bfs","","len, queue.pop, range, len, queue.append"
"C:/Users/Joseph Dania/Desktop/python_repo\networking_flow\minimum_cut.py","","mincut","This array is filled by BFS and to store path >>> mincut(test_graph, source=0, sink=5) [(1, 3), (4, 3), (4, 5)]","bfs, range, len, float, len, range, min, len, res.append"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","sigmoid","","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","DenseLayer","","Layers of BP neural network",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","BPNN","","Back Propagation Neural Network model",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","example","","np.random.default_rng, rng.normal, np.asarray, BPNN, model.build, model.summary, model.train, model.add_layer, DenseLayer"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","__init__","common connected layer of bp network :param units: numbers of neural units :param activation: activation function :param learning_rate: learning rate for paras :param is_input_layer: whether it is input layer or not",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","initializer","","np.random.default_rng, np.asmatrix, rng.normal, np.asmatrix, rng.normal"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","cal_gradient","","np.dot, np.diag, np.diag"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","forward_propagation","","self.activation, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","back_propagation","","self.cal_gradient, np.asmatrix, np.asmatrix, np.dot, np.dot, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","__init__","","plt.figure, self.fig_loss.add_subplot"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","add_layer","","self.layers.append"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","build","","enumerate, layer.initializer"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","summary","","enumerate, print, print, print, np.shape, np.shape"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","train","","self.ax_loss.hlines, np.shape, range, range, self.train_mse.append, self.plot_loss, self.cal_loss, print, np.asmatrix, np.asmatrix, layer.forward_propagation, layer.back_propagation"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","cal_loss","","np.sum, np.power"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\back_propagation_neural_network.py","","plot_loss","","self.ax_loss.plot, plt.ion, plt.xlabel, plt.ylabel, plt.show, plt.pause, self.ax_loss.lines.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","CNN","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","__init__",":param conv1_get: [a,c,d], size, number, step of convolution kernel :param size_p1: pooling size :param bp_num1: units number of flatten layer :param bp_num2: units number of hidden layer :param bp_num3: units number of output layer :param rate_w: rate of weight learning :param rate_t: rate of threshold learning","np.random.default_rng, np.asmatrix, np.asmatrix, np.asmatrix, range, rng.random, rng.random, rng.random, rng.random, rng.random, rng.random"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","save_model","","print, open, pickle.dump"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","read_model","","model_dic.get, conv_get.append, model_dic.get, model_dic.get, model_dic.get, model_dic.get, model_dic.get, model_dic.get, CNN, model_dic.get, model_dic.get, model_dic.get, model_dic.get, model_dic.get, model_dic.get, open, pickle.load, model_dic.get"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","sig","","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","do_round","","round"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","convolute","","range, int, range, np.asarray, np.shape, range, range, .reshape, data_featuremap.append, focus1_list.extend, data_focus.append, len, featuremap.append, self.Expand_Mat, np.sum, self.sig, np.asmatrix, np.multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","pooling","","len, int, range, len, range, .reshape, featuremap_pooled.append, range, np.asmatrix, map_pooled.append, np.average, map_pooled.append, np.max"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","_expand","","range, np.asarray, len, np.shape, .reshape, data_expanded.extend, .tolist, data_listed.getA"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","_expand_mat","","np.asarray, np.shape, data_mat.reshape"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","_calculate_gradient_from_pool","calculate the gradient from the data slice of pool layer pd_pool: list of matrix out_map: the shape of data slice(size_map*size_map) return: pd_all: list of matrix, [num, size_map, size_map]","range, np.ones, range, np.multiply, pd_all.append, range, np.multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","train","","print, print, print, print, print, print, range, all_mse.append, plt.plot, plt.plot, plt.xlabel, plt.ylabel, plt.grid, plt.show, draw_error, np.shape, np.shape, len, np.asmatrix, np.asarray, self.convolute, self.pooling, np.shape, self._expand, self.sig, self.sig, np.multiply, np.multiply, np.dot, .tolist, self._calculate_gradient_from_pool, range, np.sum, np.dot, np.dot, np.multiply, np.dot, np.multiply, self._expand_mat, abs, range, pd_conv1_pooled.T.getA, np.dot, delta_w.reshape, int, np.sum"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","predict","","print, print, range, np.asarray, len, np.asmatrix, self.convolute, self.pooling, self._expand, self.sig, self.sig, produce_out.extend, list, np.shape, .tolist, map, bp_out3.getA"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","convolution","","np.asmatrix, self.convolute, self.pooling"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\convolution_neural_network.py","","draw_error","","plt.plot, plt.plot, plt.xlabel, plt.ylabel, plt.grid, plt.show, range, int"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","_Datasets","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","_read32","",".newbyteorder, np.frombuffer, np.dtype, bytestream.read"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","_extract_images","Extract the images into a 4D uint8 numpy array [index, y, x, depth].  Args:   f: A file object that can be passed into a gzip reader.  Returns:   data: A 4D uint8 numpy array [index, y, x, depth].  Raises:   ValueError: If the bytestream does not start with 2051.","deprecated, print, gzip.GzipFile, _read32, _read32, _read32, _read32, bytestream.read, np.frombuffer, data.reshape, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","_dense_to_one_hot","Convert class labels from scalars to one-hot vectors.","deprecated, np.zeros, np.arange, labels_dense.ravel"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","_extract_labels","Extract the labels into a 1D uint8 numpy array [index].  Args:   f: A file object that can be passed into a gzip reader.   one_hot: Does one hot encoding for the result.   num_classes: Number of classes for the one hot encoding.  Returns:   labels: a 1D uint8 numpy array.  Raises:   ValueError: If the bystream doesn't start with 2049.","deprecated, print, gzip.GzipFile, _read32, _read32, bytestream.read, np.frombuffer, ValueError, _dense_to_one_hot"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","_DataSet","","Container class for a _DataSet (deprecated).  THIS CLASS IS DEPRECATED.",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","_maybe_download","Download the data from source url, unless it's already here.  Args:     filename: string, name of the file in the directory.     work_directory: string, path to working directory.     source_url: url to download from if file doesn't exist.  Returns:     Path to resulting file.","deprecated, os.path.join, gfile.Exists, gfile.MakeDirs, gfile.Exists, urllib.request.urlretrieve, print, gfile.GFile, f.size"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","read_data_sets","","deprecated, _maybe_download, _maybe_download, _maybe_download, _maybe_download, _DataSet, _DataSet, _DataSet, _Datasets, fake, fake, fake, _Datasets, gfile.Open, _extract_images, gfile.Open, _extract_labels, gfile.Open, _extract_images, gfile.Open, _extract_labels, ValueError, _DataSet, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","__init__","Construct a _DataSet.  one_hot arg is used only if fake_data is true.  `dtype` can be either `uint8` to leave the input as `[0, 255]`, or `float32` to rescale into `[0, 1]`.  Seed arg provides for convenient deterministic testing.  Args:   images: The images   labels: The labels   fake_data: Ignore inages and labels, use fake data.   one_hot: Bool, return the labels as one hot vectors (if True) or ints (if     False).   dtype: Output image dtype. One of [uint8, float32]. `uint8` output has     range [0,255]. float32 output has range [0,1].   reshape: Bool. If True returned images are returned flattened to vectors.   seed: The random seed to use.","deprecated, random_seed.get_seed, np.random.default_rng, dtypes.as_dtype, TypeError, images.reshape, images.astype, np.multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","images","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","labels","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","num_examples","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","epochs_completed","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","next_batch","Return the next `batch_size` examples from this data set.","np.arange, self._rng.shuffle, np.arange, self._rng.shuffle, np.concatenate, np.concatenate, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\input_data.py","","fake","","_DataSet"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\simple_neural_network.py","","sigmoid_function","Return the sigmoid function of a float.  >>> sigmoid_function(3.5) 0.9706877692486436 >>> sigmoid_function(3.5, True) -8.75","math.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\simple_neural_network.py","","forward_propagation","Return the value found after the forward propagation training.  >>> res = forward_propagation(32, 450_000)  # Was 10_000_000 >>> res > 31 and res < 33 True  >>> res = forward_propagation(32, 1000) >>> res > 31 and res < 33 False","float, range, sigmoid_function, sigmoid_function, random.randint"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","TwoHiddenLayerNeuralNetwork","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","sigmoid","Applies sigmoid activation function.  return normalized values  >>> sigmoid(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64)) array([[0.73105858, 0.5       , 0.88079708],        [0.73105858, 0.5       , 0.5       ]])","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","sigmoid_derivative","Provides the derivative value of the sigmoid function.  returns derivative of the sigmoid value  >>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64)) array([[ 0.,  0., -2.],        [ 0.,  0.,  0.]])",""
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","example","Example for ""how to use the neural network class and use the respected methods for the desired output"". Calls the TwoHiddenLayerNeuralNetwork class and provides the fixed input output values to the model. Model is trained for a fixed amount of iterations then the predict method is called. In this example the output is divided into 2 classes i.e. binary classification, the two classes are represented by '0' and '1'.  >>> example() in (0, 1) True","np.array, np.array, TwoHiddenLayerNeuralNetwork, neural_network.train, neural_network.predict, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","__init__","This function initializes the TwoHiddenLayerNeuralNetwork class with random weights for every layer and initializes predicted output with zeroes.  input_array : input values for training the neural network (i.e training data) . output_array : expected output values of the given inputs.","np.random.default_rng, rng.random, rng.random, rng.random, np.zeros"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","feedforward","The information moves in only one direction i.e. forward from the input nodes, through the two hidden nodes and to the output nodes. There are no cycles or loops in the network.  Return layer_between_second_hidden_layer_and_output     (i.e the last layer of the neural network).  >>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float) >>> output_val = np.array(([0], [0], [0]), dtype=float) >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val) >>> res = nn.feedforward() >>> array_sum = np.sum(res) >>> bool(np.isnan(array_sum)) False","sigmoid, sigmoid, sigmoid, np.dot, np.dot, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","back_propagation","Function for fine-tuning the weights of the neural net based on the error rate obtained in the previous epoch (i.e., iteration). Updation is done using derivative of sogmoid activation function.  >>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float) >>> output_val = np.array(([0], [0], [0]), dtype=float) >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val) >>> res = nn.feedforward() >>> nn.back_propagation() >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights >>> bool((res == updated_weights).all()) False","np.dot, np.dot, np.dot, sigmoid_derivative, np.dot, sigmoid_derivative, np.dot, sigmoid_derivative, sigmoid_derivative, np.dot, sigmoid_derivative, sigmoid_derivative"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","train","Performs the feedforwarding and back propagation process for the given number of iterations. Every iteration will update the weights of neural network.  output : real output values,required for calculating loss. iterations : number of times the weights are to be updated. give_loss : boolean value, If True then prints loss for each iteration,             If False then nothing is printed  >>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float) >>> output_val = np.array(([0], [1], [1]), dtype=float) >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val) >>> first_iteration_weights = nn.feedforward() >>> nn.back_propagation() >>> updated_weights = nn.second_hidden_layer_and_output_layer_weights >>> bool((first_iteration_weights == updated_weights).all()) False","range, self.feedforward, self.back_propagation, np.mean, print, np.square, self.feedforward"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\two_hidden_layers_neural_network.py","","predict","Predict's the output for the given input values using the trained neural network.  The output value given by the model ranges in-between 0 and 1. The predict function returns 1 if the model value is greater than the threshold value else returns 0, as the real output values are in binary.  >>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float) >>> output_val = np.array(([0], [1], [1]), dtype=float) >>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val) >>> nn.train(output_val, 1000, False) >>> nn.predict([0, 1, 0]) in (0, 1) True","sigmoid, sigmoid, sigmoid, int, np.dot, np.dot, np.dot"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\binary_step.py","","binary_step","Implements the binary step function  Parameters:     vector (ndarray): A vector that consists of numeric values  Returns:     vector (ndarray): Input vector after applying binary step function  >>> vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3]) >>> binary_step(vector) array([0, 1, 1, 1, 0, 1])","np.where"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\exponential_linear_unit.py","","exponential_linear_unit","Implements the ELU activation function.      Parameters:          vector: the array containing input of elu activation          alpha: hyper-parameter      return:      elu (np.array): The input numpy array after applying elu.       Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0  Examples: >>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3) array([ 2.3       ,  0.6       , -0.25939942, -0.29328877])  >>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067) array([-0.06699323, -0.01736518,  0.45      , -0.06629904])","np.where, np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\gaussian_error_linear_unit.py","","sigmoid","Mathematical function sigmoid takes a vector x of K real numbers as input and returns 1/ (1 + e^-x). https://en.wikipedia.org/wiki/Sigmoid_function  >>> sigmoid(np.array([-1.0, 1.0, 2.0])) array([0.26894142, 0.73105858, 0.88079708])","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\gaussian_error_linear_unit.py","","gaussian_error_linear_unit","Implements the Gaussian Error Linear Unit (GELU) function  Parameters:     vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values  Returns:     gelu_vec (np.ndarray): The input numpy array, after applying gelu  Examples: >>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0])) array([-0.15420423,  0.84579577,  1.93565862])  >>> gaussian_error_linear_unit(np.array([-3])) array([-0.01807131])","sigmoid"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\leaky_rectified_linear_unit.py","","leaky_rectified_linear_unit","Implements the LeakyReLU activation function.      Parameters:         vector (np.ndarray): The input array for LeakyReLU activation.         alpha (float): The slope for negative values.      Returns:         np.ndarray: The input array after applying the LeakyReLU activation.      Formula: f(x) = x if x > 0 else f(x) = alpha * x  Examples: >>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3) array([ 2.3 ,  0.6 , -0.6 , -1.14])  >>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067) array([-0.6164 , -0.0201 ,  0.45   , -0.30552])","np.where"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\mish.py","","mish","Implements the Mish activation function.      Parameters:         vector (np.ndarray): The input array for Mish activation.      Returns:         np.ndarray: The input array after applying the Mish activation.      Formula:         f(x) = x * tanh(softplus(x)) = x * tanh(ln(1 + e^x))  Examples: >>> mish(vector=np.array([2.3,0.6,-2,-3.8])) array([ 2.26211893,  0.46613649, -0.25250148, -0.08405831])  >>> mish(np.array([-9.2, -0.3, 0.45, -4.56])) array([-0.00092952, -0.15113318,  0.33152014, -0.04745745])","np.tanh, softplus"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\rectified_linear_unit.py","","relu","Implements the relu function  Parameters:     vector (np.array,list,tuple): A  numpy array of shape (1,n)     consisting of real values or a similar list,tuple   Returns:     relu_vec (np.array): The input numpy array, after applying     relu.  >>> vec = np.array([-1, 0, 5]) >>> relu(vec) array([0, 0, 5])","np.maximum"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\scaled_exponential_linear_unit.py","","scaled_exponential_linear_unit","Applies the Scaled Exponential Linear Unit function to each element of the vector. Parameters :     vector : np.ndarray     alpha : float (default = 1.6732)     lambda_ : float (default = 1.0507)  Returns : np.ndarray Formula : f(x) = lambda_ * x if x > 0                  lambda_ * alpha * (e**x - 1) if x <= 0 Examples : >>> scaled_exponential_linear_unit(vector=np.array([1.3, 3.7, 2.4])) array([1.36591, 3.88759, 2.52168])  >>> scaled_exponential_linear_unit(vector=np.array([1.3, 4.7, 8.2])) array([1.36591, 4.93829, 8.61574])","np.where, np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\soboleva_modified_hyperbolic_tangent.py","","soboleva_modified_hyperbolic_tangent","Implements the Soboleva Modified Hyperbolic Tangent function  Parameters:     vector (ndarray): A vector that consists of numeric values     a_value (float): parameter a of the equation     b_value (float): parameter b of the equation     c_value (float): parameter c of the equation     d_value (float): parameter d of the equation  Returns:     vector (ndarray): Input array after applying SMHT function  >>> vector = np.array([5.4, -2.4, 6.3, -5.23, 3.27, 0.56]) >>> soboleva_modified_hyperbolic_tangent(vector, 0.2, 0.4, 0.6, 0.8) array([ 0.11075085, -0.28236685,  0.07861169, -0.1180085 ,  0.22999056,         0.1566043 ])","np.exp, np.exp, np.exp, np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\softplus.py","","softplus","Implements the Softplus activation function.  Parameters:     vector (np.ndarray): The input array for the Softplus activation.  Returns:     np.ndarray: The input array after applying the Softplus activation.  Formula: f(x) = ln(1 + e^x)  Examples: >>> softplus(np.array([2.3, 0.6, -2, -3.8])) array([2.39554546, 1.03748795, 0.12692801, 0.02212422])  >>> softplus(np.array([-9.2, -0.3, 0.45, -4.56])) array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])","np.log, np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\squareplus.py","","squareplus","Implements the SquarePlus activation function.  Parameters:     vector (np.ndarray): The input array for the SquarePlus activation.     beta (float): size of the curved region  Returns:     np.ndarray: The input array after applying the SquarePlus activation.  Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2  Examples: >>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2) array([2.5       , 1.06811457, 0.22474487, 0.12731349])  >>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3) array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])","np.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\swish.py","","sigmoid","Mathematical function sigmoid takes a vector x of K real numbers as input and returns 1/ (1 + e^-x). https://en.wikipedia.org/wiki/Sigmoid_function  >>> sigmoid(np.array([-1.0, 1.0, 2.0])) array([0.26894142, 0.73105858, 0.88079708])","np.exp"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\swish.py","","sigmoid_linear_unit","Implements the Sigmoid Linear Unit (SiLU) or swish function  Parameters:     vector (np.ndarray): A  numpy array consisting of real values  Returns:     swish_vec (np.ndarray): The input numpy array, after applying swish  Examples: >>> sigmoid_linear_unit(np.array([-1.0, 1.0, 2.0])) array([-0.26894142,  0.73105858,  1.76159416])  >>> sigmoid_linear_unit(np.array([-2])) array([-0.23840584])","sigmoid"
"C:/Users/Joseph Dania/Desktop/python_repo\neural_network\activation_functions\swish.py","","swish","Parameters:     vector (np.ndarray): A  numpy array consisting of real values     trainable_parameter: Use to implement various Swish Activation Functions  Returns:     swish_vec (np.ndarray): The input numpy array, after applying swish  Examples: >>> swish(np.array([-1.0, 1.0, 2.0]), 2) array([-0.11920292,  0.88079708,  1.96402758])  >>> swish(np.array([-2]), 1) array([-0.23840584])","sigmoid"
"C:/Users/Joseph Dania/Desktop/python_repo\other\activity_selection.py","","print_max_activities",">>> start = [1, 3, 0, 5, 8, 5] >>> finish = [2, 4, 6, 7, 9, 9] >>> print_max_activities(start, finish) The following activities are selected: 0,1,3,4,","len, print, print, range, print"
"C:/Users/Joseph Dania/Desktop/python_repo\other\alternative_list_arrange.py","","alternative_list_arrange","The method arranges two lists as one list in alternative forms of the list elements. :param first_input_list: :param second_input_list: :return: List >>> alternative_list_arrange([1, 2, 3, 4, 5], [""A"", ""B"", ""C""]) [1, 'A', 2, 'B', 3, 'C', 4, 5] >>> alternative_list_arrange([""A"", ""B"", ""C""], [1, 2, 3, 4, 5]) ['A', 1, 'B', 2, 'C', 3, 4, 5] >>> alternative_list_arrange([""X"", ""Y"", ""Z""], [9, 8, 7, 6]) ['X', 9, 'Y', 8, 'Z', 7, 6] >>> alternative_list_arrange([1, 2, 3, 4, 5], []) [1, 2, 3, 4, 5]","len, len, range, output_result_list.append, output_result_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","BankersAlgorithm","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","__init__",":param claim_vector: A nxn/nxm list depicting the amount of each resources  (eg. memory, interface, semaphores, etc.) available. :param allocated_resources_table: A nxn/nxm list depicting the amount of each  resource each process is currently holding :param maximum_claim_table: A nxn/nxm list depicting how much of each resource  the system currently has available",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","__processes_resource_summation","Check for allocated resources in line with each resource in the claim vector","sum, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","__available_resources","Check for available resources in line with each resource in the claim vector","np.array, np.array, self.__processes_resource_summation"
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","__need","Implement safety checker that calculates the needs by ensuring that ``max_claim[i][j] - alloc_table[i][j] <= avail[j]``","list, enumerate, np.array, np.array"
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","__need_index_manager","This function builds an index control dictionary to track original ids/indices of processes when altered during execution of method ""main""      :Return: {0: [a: int, b: int], 1: [c: int, d: int]}  >>> index_control = BankersAlgorithm( ...     test_claim_vector, test_allocated_res_table, test_maximum_claim_table ... )._BankersAlgorithm__need_index_manager() >>> {key: [int(x) for x in value] for key, value ...     in index_control.items()}  # doctest: +NORMALIZE_WHITESPACE {0: [1, 2, 0, 3], 1: [0, 1, 3, 1], 2: [1, 1, 0, 2], 3: [1, 3, 2, 0],  4: [2, 0, 0, 3]}",".index, self.__need, self.__need"
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","main","Utilize various methods in this class to simulate the Banker's algorithm     :Return: None  >>> BankersAlgorithm(test_claim_vector, test_allocated_res_table, ...    test_maximum_claim_table).main(describe=True)          Allocated Resource Table P1       2        0        1        1 <BLANKLINE> P2       0        1        2        1 <BLANKLINE> P3       4        0        0        3 <BLANKLINE> P4       0        2        1        0 <BLANKLINE> P5       1        0        3        0 <BLANKLINE>          System Resource Table P1       3        2        1        4 <BLANKLINE> P2       0        2        5        2 <BLANKLINE> P3       5        1        0        5 <BLANKLINE> P4       1        5        3        0 <BLANKLINE> P5       3        0        3        3 <BLANKLINE> Current Usage by Active Processes: 8 5 9 7 Initial Available Resources:       1 2 2 2 __________________________________________________ <BLANKLINE> Process 3 is executing. Updated available resource stack for processes: 5 2 2 5 The process is in a safe state. <BLANKLINE> Process 1 is executing. Updated available resource stack for processes: 7 2 3 6 The process is in a safe state. <BLANKLINE> Process 2 is executing. Updated available resource stack for processes: 7 3 5 7 The process is in a safe state. <BLANKLINE> Process 4 is executing. Updated available resource stack for processes: 7 5 6 7 The process is in a safe state. <BLANKLINE> Process 5 is executing. Updated available resource stack for processes: 8 5 9 7 The process is in a safe state. <BLANKLINE>","self.__need, self.__available_resources, self.__need_index_manager, kwargs.items, print, self.__pretty_data, enumerate, print, print, need_index_manager.items, print, need_list.remove, print, np.array, np.array, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\other\bankers_algorithm.py","","__pretty_data","Properly align display of the algorithm's solution","print, print, print, print, print, print, .join, .join, .join, .join, str, str, self.__available_resources, self.__allocated_resources_table.index, self.__maximum_claim_table.index"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","Clause","","| A clause represented in Conjunctive Normal Form. | A clause is a set of literals, either complemented or otherwise.  For example:     * {A1, A2, A3'} is the clause (A1 v A2 v A3')     * {A5', A2', A1} is the clause (A5' v A2' v A1)  Create model  >>> clause = Clause([""A1"", ""A2'"", ""A3""]) >>> clause.evaluate({""A1"": True}) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","Formula","","| A formula represented in Conjunctive Normal Form. | A formula is a set of clauses. | For example, |   {{A1, A2, A3'}, {A5', A2', A1}} is ((A1 v A2 v A3') and (A5' v A2' v A1))",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","generate_clause","| Randomly generate a clause. | All literals have the name Ax, where x is an integer from ``1`` to ``5``.","random.randint, Clause, random.randint, random.randint, str, literals.append"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","generate_formula","Randomly generate a formula.","set, random.randint, Formula, len, clauses.add, generate_clause"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","generate_parameters","| Return the clauses and symbols from a formula. | A symbol is the uncomplemented form of a literal.  For example,   * Symbol of A3 is A3.   * Symbol of A5' is A5.  >>> formula = Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])]) >>> clauses, symbols = generate_parameters(formula) >>> clauses_list = [str(i) for i in clauses] >>> clauses_list [""{A1 , A2' , A3}"", ""{A5' , A2' , A1}""] >>> symbols ['A1', 'A2', 'A3', 'A5']","symbols_set.append"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","find_pure_symbols","| Return pure symbols and their values to satisfy clause. | Pure symbols are symbols in a formula that exist only in one form, | either complemented or otherwise. | For example, |   {{A4 , A3 , A5' , A1 , A3'} , {A4} , {A3}} has pure symbols A4, A5' and A1.  This has the following steps:   1. Ignore clauses that have already evaluated to be ``True``.   2. Find symbols that occur only in one form in the rest of the clauses.   3. Assign value ``True`` or ``False`` depending on whether the symbols occurs      in normal or complemented form respectively.  >>> formula = Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])]) >>> clauses, symbols = generate_parameters(formula) >>> pure_symbols, values = find_pure_symbols(clauses, symbols, {}) >>> pure_symbols ['A1', 'A2', 'A3', 'A5'] >>> values {'A1': True, 'A2': False, 'A3': True, 'A5': False}","clause.evaluate, literals.append, pure_symbols.append"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","find_unit_clauses","Returns the unit symbols and their values to satisfy clause.  Unit symbols are symbols in a formula that are:   - Either the only symbol in a clause   - Or all other literals in that clause have been assigned ``False``  This has the following steps:   1. Find symbols that are the only occurrences in a clause.   2. Find symbols in a clause where all other literals are assigned ``False``.   3. Assign ``True`` or ``False`` depending on whether the symbols occurs in      normal or complemented form respectively.  >>> clause1 = Clause([""A4"", ""A3"", ""A5'"", ""A1"", ""A3'""]) >>> clause2 = Clause([""A4""]) >>> clause3 = Clause([""A3""]) >>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3])) >>> unit_clauses, values = find_unit_clauses(clauses, {}) >>> unit_clauses ['A4', 'A3'] >>> values {'A4': True, 'A3': True}","len, unit_symbols.append, clause.literals.items, len, next, unit_symbols.append, iter, clause.literals.keys, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","dpll_algorithm","Returns the model if the formula is satisfiable, else ``None``  This has the following steps:   1. If every clause in clauses is ``True``, return ``True``.   2. If some clause in clauses is ``False``, return ``False``.   3. Find pure symbols.   4. Find unit symbols.  >>> formula = Formula([Clause([""A4"", ""A3"", ""A5'"", ""A1"", ""A3'""]), Clause([""A4""])]) >>> clauses, symbols = generate_parameters(formula) >>> soln, model = dpll_algorithm(clauses, symbols, {}) >>> soln True >>> model {'A4': True}","find_unit_clauses, clause.evaluate, find_pure_symbols, len, list, dpll_algorithm, len, list, dpll_algorithm, dpll_algorithm, dpll_algorithm, print, tmp_symbols.remove, tmp_symbols.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","__init__","Represent the literals and an assignment in a clause.""","dict.fromkeys"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","__str__","To print a clause as in Conjunctive Normal Form.  >>> str(Clause([""A1"", ""A2'"", ""A3""])) ""{A1 , A2' , A3}""",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","__len__","To print a clause as in Conjunctive Normal Form.  >>> len(Clause([])) 0 >>> len(Clause([""A1"", ""A2'"", ""A3""])) 3","len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","assign","Assign values to literals of the clause as given by model.","literal.endswith"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","evaluate","Evaluates the clause with the assignments in model.  This has the following steps:   1. Return ``True`` if both a literal and its complement exist in the clause.   2. Return ``True`` if a single literal has the assignment ``True``.   3. Return ``None`` (unable to complete evaluation)      if a literal has no assignment.   4. Compute disjunction of all values assigned in clause.","self.assign, self.literals.values, any, self.literals.values, literal.endswith, literal.rstrip"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","__init__","Represent the number of clauses and the clauses themselves.","list"
"C:/Users/Joseph Dania/Desktop/python_repo\other\davis_putnam_logemann_loveland.py","","__str__","To print a formula as in Conjunctive Normal Form.  >>> str(Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])])) ""{{A1 , A2' , A3} , {A5' , A2' , A1}}""",".join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\other\doomsday.py","","get_week_day","Returns the week-day name out of a given date.  >>> get_week_day(2020, 10, 24) 'Saturday' >>> get_week_day(2017, 10, 24) 'Tuesday' >>> get_week_day(2019, 5, 3) 'Friday' >>> get_week_day(1970, 9, 16) 'Wednesday' >>> get_week_day(1870, 8, 13) 'Saturday' >>> get_week_day(2040, 3, 14) 'Wednesday'","len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\other\fischer_yates_shuffle.py","","fisher_yates_shuffle","","range, len, random.randint, random.randint, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\gauss_easter.py","","gauss_easter","Calculation Gregorian easter date for given year  >>> gauss_easter(2007) datetime.datetime(2007, 4, 8, 0, 0, tzinfo=datetime.timezone.utc)  >>> gauss_easter(2008) datetime.datetime(2008, 3, 23, 0, 0, tzinfo=datetime.timezone.utc)  >>> gauss_easter(2020) datetime.datetime(2020, 4, 12, 0, 0, tzinfo=datetime.timezone.utc)  >>> gauss_easter(2021) datetime.datetime(2021, 4, 4, 0, 0, tzinfo=datetime.timezone.utc)","math.floor, math.floor, datetime, datetime, datetime, timedelta, int"
"C:/Users/Joseph Dania/Desktop/python_repo\other\graham_scan.py","Direction","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\graham_scan.py","","angle_comparer","Return the angle toward to point from (minx, miny)  :param point: The target point        minx: The starting point's x        miny: The starting point's y :return: the angle  Examples: >>> angle_comparer((1,1), 0, 0) 45.0  >>> angle_comparer((100,1), 10, 10) -5.710593137499642  >>> angle_comparer((5,5), 2, 3) 33.690067525979785","degrees, atan2"
"C:/Users/Joseph Dania/Desktop/python_repo\other\graham_scan.py","","check_direction","Return the direction toward to the line from via to target from starting  :param starting: The starting point        via: The via point        target: The target point :return: the Direction  Examples: >>> check_direction((1,1), (2,2), (3,3)) Direction.straight  >>> check_direction((60,1), (-50,199), (30,2)) Direction.left  >>> check_direction((0,0), (5,5), (10,0)) Direction.right","degrees, degrees, atan2, atan2"
"C:/Users/Joseph Dania/Desktop/python_repo\other\graham_scan.py","","graham_scan","Pure implementation of graham scan algorithm in Python  :param points: The unique points on coordinates. :return: The points on convex hell.  Examples: >>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)]) [(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]  >>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)]) [(0, 0), (1, 0), (1, 1), (0, 1)]  >>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]) [(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]  >>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)]) [(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]","enumerate, points.pop, sorted, sorted_points.insert, deque, stack.append, stack.append, stack.append, range, list, len, ValueError, len, len, stack.append, check_direction, angle_comparer, stack.pop, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\other\graham_scan.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","Things","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","build_menu","","range, len, menu.append, Things"
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","greedy","","sorted, range, len, result.append, .get_weight, .get_value, .get_weight"
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","test_greedy",">>> food = [""Burger"", ""Pizza"", ""Coca Cola"", ""Rice"", ...         ""Sambhar"", ""Chicken"", ""Fries"", ""Milk""] >>> value = [80, 100, 60, 70, 50, 110, 90, 60] >>> weight = [40, 60, 40, 70, 100, 85, 55, 70] >>> foods = build_menu(food, value, weight) >>> foods  # doctest: +NORMALIZE_WHITESPACE [Things(Burger, 80, 40), Things(Pizza, 100, 60), Things(Coca Cola, 60, 40),  Things(Rice, 70, 70), Things(Sambhar, 50, 100), Things(Chicken, 110, 85),  Things(Fries, 90, 55), Things(Milk, 60, 70)] >>> greedy(foods, 500, Things.get_value)  # doctest: +NORMALIZE_WHITESPACE ([Things(Chicken, 110, 85), Things(Pizza, 100, 60), Things(Fries, 90, 55),   Things(Burger, 80, 40), Things(Rice, 70, 70), Things(Coca Cola, 60, 40),   Things(Milk, 60, 70)], 570.0)",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","get_value","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","get_name","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","get_weight","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\greedy.py","","value_weight","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\guess_the_number_search.py","","temp_input_value","Temporary input values for tests  >>> temp_input_value(option=True) 10  >>> temp_input_value(option=False) 1000  >>> temp_input_value(min_val=100, option=True) 100  >>> temp_input_value(min_val=100, max_val=50) Traceback (most recent call last):     ... ValueError: Invalid value for min_val or max_val (min_value < max_value)  >>> temp_input_value(""ten"",""fifty"",1) Traceback (most recent call last):     ... AssertionError: Invalid type of value(s) specified to function!  >>> temp_input_value(min_val=-100, max_val=500) -100  >>> temp_input_value(min_val=-5100, max_val=-100) -5100","isinstance, isinstance, isinstance, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\other\guess_the_number_search.py","","get_avg","Return the mid-number(whole) of two integers a and b  >>> get_avg(10, 15) 12  >>> get_avg(20, 300) 160  >>> get_avg(""abcd"", 300) Traceback (most recent call last):     ... TypeError: can only concatenate str (not ""int"") to str  >>> get_avg(10.5,50.25) 30","int"
"C:/Users/Joseph Dania/Desktop/python_repo\other\guess_the_number_search.py","","guess_the_number","The `guess_the_number` function that guess the number by some operations and using inner functions  >>> guess_the_number(10, 1000, 17) started... guess the number : 17 details : [505, 257, 133, 71, 40, 25, 17]  >>> guess_the_number(-10000, 10000, 7) started... guess the number : 7 details : [0, 5000, 2500, 1250, 625, 312, 156, 78, 39, 19, 9, 4, 6, 7]  >>> guess_the_number(10, 1000, ""a"") Traceback (most recent call last):     ... AssertionError: argument values must be type of ""int""  >>> guess_the_number(10, 1000, 5) Traceback (most recent call last):     ... ValueError: guess value must be within the range of lower and higher value  >>> guess_the_number(10000, 100, 5) Traceback (most recent call last):     ... ValueError: argument value for lower and higher must be(lower > higher)","print, print, print, isinstance, isinstance, isinstance, ValueError, ValueError, get_avg, last_numbers.append, answer, answer"
"C:/Users/Joseph Dania/Desktop/python_repo\other\guess_the_number_search.py","","main","starting point or function of script","int, int, int, guess_the_number, .strip, .strip, .strip, input, input, input"
"C:/Users/Joseph Dania/Desktop/python_repo\other\guess_the_number_search.py","","answer","Returns value by comparing with entered `to_guess` number",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\h_index.py","","h_index","Return H-index of citations  >>> h_index([3, 0, 6, 1, 5]) 3 >>> h_index([1, 3, 1]) 1 >>> h_index([1, 2, 3]) 2 >>> h_index('test') Traceback (most recent call last):     ... ValueError: The citations should be a list of non negative integers. >>> h_index([1,2,'3']) Traceback (most recent call last):     ... ValueError: The citations should be a list of non negative integers. >>> h_index([1,2,-3]) Traceback (most recent call last):     ... ValueError: The citations should be a list of non negative integers.","citations.sort, len, range, ValueError, isinstance, all, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\other\least_recently_used.py","LRUCache","","Page Replacement Algorithm, Least Recently Used (LRU) Caching.  >>> lru_cache: LRUCache[str | int] = LRUCache(4) >>> lru_cache.refer(""A"") >>> lru_cache.refer(2) >>> lru_cache.refer(3)  >>> lru_cache LRUCache(4) => [3, 2, 'A']  >>> lru_cache.refer(""A"") >>> lru_cache LRUCache(4) => ['A', 3, 2]  >>> lru_cache.refer(4) >>> lru_cache.refer(5) >>> lru_cache LRUCache(4) => [5, 4, 'A', 3]",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\least_recently_used.py","","__init__","Creates an empty store and map for the keys. The LRUCache is set the size n.","deque, set, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\other\least_recently_used.py","","refer","Looks for a page in the cache store and adds reference to the set. Remove the least recently used key if the store is full. Update store to reflect recent access.","self.dq_store.appendleft, self.key_reference.add, self.dq_store.remove, len, self.dq_store.pop, self.key_reference.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\other\least_recently_used.py","","display","Prints all the elements in the store.","print"
"C:/Users/Joseph Dania/Desktop/python_repo\other\least_recently_used.py","","__repr__","","list"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","DoubleLinkedListNode","","Double Linked List Node built specifically for LFU Cache  >>> node = DoubleLinkedListNode(1,1) >>> node Node: key: 1, val: 1, freq: 0, has next: False, has prev: False",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","DoubleLinkedList","","Double Linked List built specifically for LFU Cache  >>> dll: DoubleLinkedList = DoubleLinkedList() >>> dll DoubleLinkedList,     Node: key: None, val: None, freq: 0, has next: True, has prev: False,     Node: key: None, val: None, freq: 0, has next: False, has prev: True  >>> first_node = DoubleLinkedListNode(1,10) >>> first_node Node: key: 1, val: 10, freq: 0, has next: False, has prev: False   >>> dll.add(first_node) >>> dll DoubleLinkedList,     Node: key: None, val: None, freq: 0, has next: True, has prev: False,     Node: key: 1, val: 10, freq: 1, has next: True, has prev: True,     Node: key: None, val: None, freq: 0, has next: False, has prev: True  >>> # node is mutated >>> first_node Node: key: 1, val: 10, freq: 1, has next: True, has prev: True  >>> second_node = DoubleLinkedListNode(2,20) >>> second_node Node: key: 2, val: 20, freq: 0, has next: False, has prev: False  >>> dll.add(second_node) >>> dll DoubleLinkedList,     Node: key: None, val: None, freq: 0, has next: True, has prev: False,     Node: key: 1, val: 10, freq: 1, has next: True, has prev: True,     Node: key: 2, val: 20, freq: 1, has next: True, has prev: True,     Node: key: None, val: None, freq: 0, has next: False, has prev: True  >>> removed_node = dll.remove(first_node) >>> assert removed_node == first_node >>> dll DoubleLinkedList,     Node: key: None, val: None, freq: 0, has next: True, has prev: False,     Node: key: 2, val: 20, freq: 1, has next: True, has prev: True,     Node: key: None, val: None, freq: 0, has next: False, has prev: True   >>> # Attempt to remove node not on list >>> removed_node = dll.remove(first_node) >>> removed_node is None True  >>> # Attempt to remove head or rear >>> dll.head Node: key: None, val: None, freq: 0, has next: True, has prev: False >>> dll.remove(dll.head) is None True  >>> # Attempt to remove head or rear >>> dll.rear Node: key: None, val: None, freq: 0, has next: False, has prev: True >>> dll.remove(dll.rear) is None True",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","LFUCache","","LFU Cache to store a given capacity of data. Can be used as a stand-alone object or as a function decorator.  >>> cache = LFUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) >>> cache.get(2) is None True >>> cache.put(4, 4) >>> cache.get(1) is None True >>> cache.get(3) 3 >>> cache.get(4) 4 >>> cache CacheInfo(hits=3, misses=2, capacity=2, current_size=2) >>> @LFUCache.decorator(100) ... def fib(num): ...     if num in (1, 2): ...         return 1 ...     return fib(num - 1) + fib(num - 2)  >>> for i in range(1, 101): ...     res = fib(i)  >>> fib.cache_info() CacheInfo(hits=196, misses=100, capacity=100, current_size=100)",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__init__","","DoubleLinkedListNode, DoubleLinkedListNode"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__repr__","","rep.append, .join, rep.append, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","add","Adds the given node at the tail of the list and shifting it to proper position","self._position_node"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","_position_node","Moves node forward to maintain invariant of sort by freq value",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","remove","Removes and returns the given node from the list  Returns None if node.prev or node.next is None",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__init__","","DoubleLinkedList"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__repr__","Return the details for the cache instance [hits, misses, capacity, current_size]",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","__contains__",">>> cache = LFUCache(1)  >>> 1 in cache False  >>> cache.put(1, 1) >>> 1 in cache True",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","get","Returns the value for the input key and updates the Double Linked List. Returns Returns None if key is not present in cache","self.list.remove, self.list.add"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","put","Sets the value for the input key and updates the Double Linked List","DoubleLinkedListNode, self.list.add, self.list.remove, self.list.add, self.list.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","decorator","Decorator version of LFU Cache  Decorated function must be function of T -> U","setattr, .get, LFUCache, func, .put"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","cache_decorator_inner","","setattr, .get, LFUCache, func, .put"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","cache_decorator_wrapper","",".get, LFUCache, func, .put"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lfu_cache.py","","cache_info","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\linear_congruential_generator.py","LinearCongruentialGenerator","","A pseudorandom number generator.",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\linear_congruential_generator.py","","__init__","These parameters are saved and used when nextNumber() is called.  modulo is the largest number that can be generated (exclusive). The most efficient values are powers of 2. 2^32 is a common value.","int, time"
"C:/Users/Joseph Dania/Desktop/python_repo\other\linear_congruential_generator.py","","next_number","The smallest number that can be generated is zero. The largest number that can be generated is modulo-1. modulo is set in the constructor.",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","DoubleLinkedListNode","","Double Linked List Node built specifically for LRU Cache  >>> DoubleLinkedListNode(1,1) Node: key: 1, val: 1, has next: False, has prev: False",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","DoubleLinkedList","","Double Linked List built specifically for LRU Cache  >>> dll: DoubleLinkedList = DoubleLinkedList() >>> dll DoubleLinkedList,     Node: key: None, val: None, has next: True, has prev: False,     Node: key: None, val: None, has next: False, has prev: True  >>> first_node = DoubleLinkedListNode(1,10) >>> first_node Node: key: 1, val: 10, has next: False, has prev: False   >>> dll.add(first_node) >>> dll DoubleLinkedList,     Node: key: None, val: None, has next: True, has prev: False,     Node: key: 1, val: 10, has next: True, has prev: True,     Node: key: None, val: None, has next: False, has prev: True  >>> # node is mutated >>> first_node Node: key: 1, val: 10, has next: True, has prev: True  >>> second_node = DoubleLinkedListNode(2,20) >>> second_node Node: key: 2, val: 20, has next: False, has prev: False  >>> dll.add(second_node) >>> dll DoubleLinkedList,     Node: key: None, val: None, has next: True, has prev: False,     Node: key: 1, val: 10, has next: True, has prev: True,     Node: key: 2, val: 20, has next: True, has prev: True,     Node: key: None, val: None, has next: False, has prev: True  >>> removed_node = dll.remove(first_node) >>> assert removed_node == first_node >>> dll DoubleLinkedList,     Node: key: None, val: None, has next: True, has prev: False,     Node: key: 2, val: 20, has next: True, has prev: True,     Node: key: None, val: None, has next: False, has prev: True   >>> # Attempt to remove node not on list >>> removed_node = dll.remove(first_node) >>> removed_node is None True  >>> # Attempt to remove head or rear >>> dll.head Node: key: None, val: None, has next: True, has prev: False >>> dll.remove(dll.head) is None True  >>> # Attempt to remove head or rear >>> dll.rear Node: key: None, val: None, has next: False, has prev: True >>> dll.remove(dll.rear) is None True",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","LRUCache","","LRU Cache to store a given capacity of data. Can be used as a stand-alone object or as a function decorator.  >>> cache = LRUCache(2)  >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1  >>> cache.list DoubleLinkedList,     Node: key: None, val: None, has next: True, has prev: False,     Node: key: 2, val: 2, has next: True, has prev: True,     Node: key: 1, val: 1, has next: True, has prev: True,     Node: key: None, val: None, has next: False, has prev: True  >>> cache.cache  # doctest: +NORMALIZE_WHITESPACE {1: Node: key: 1, val: 1, has next: True, has prev: True,      2: Node: key: 2, val: 2, has next: True, has prev: True}  >>> cache.put(3, 3)  >>> cache.list DoubleLinkedList,     Node: key: None, val: None, has next: True, has prev: False,     Node: key: 1, val: 1, has next: True, has prev: True,     Node: key: 3, val: 3, has next: True, has prev: True,     Node: key: None, val: None, has next: False, has prev: True  >>> cache.cache  # doctest: +NORMALIZE_WHITESPACE {1: Node: key: 1, val: 1, has next: True, has prev: True,      3: Node: key: 3, val: 3, has next: True, has prev: True}  >>> cache.get(2) is None True  >>> cache.put(4, 4)  >>> cache.get(1) is None True  >>> cache.get(3) 3  >>> cache.get(4) 4  >>> cache CacheInfo(hits=3, misses=2, capacity=2, current size=2)  >>> @LRUCache.decorator(100) ... def fib(num): ...     if num in (1, 2): ...         return 1 ...     return fib(num - 1) + fib(num - 2)  >>> for i in range(1, 100): ...     res = fib(i)  >>> fib.cache_info() CacheInfo(hits=194, misses=99, capacity=100, current size=99)",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__repr__","","bool, bool"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__init__","","DoubleLinkedListNode, DoubleLinkedListNode"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__repr__","","rep.append, .join, rep.append, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","add","Adds the given node to the end of the list (before rear)",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","remove","Removes and returns the given node from the list  Returns None if node.prev or node.next is None",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__init__","","DoubleLinkedList"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__repr__","Return the details for the cache instance [hits, misses, capacity, current_size]",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","__contains__",">>> cache = LRUCache(1)  >>> 1 in cache False  >>> cache.put(1, 1)  >>> 1 in cache True",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","get","Returns the value for the input key and updates the Double Linked List. Returns None if key is not present in cache","self.list.remove, self.list.add"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","put","Sets the value for the input key and updates the Double Linked List","DoubleLinkedListNode, self.list.add, self.list.remove, self.list.add, self.list.remove"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","decorator","Decorator version of LRU Cache  Decorated function must be function of T -> U","setattr, .get, LRUCache, func, .put"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","cache_decorator_inner","","setattr, .get, LRUCache, func, .put"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","cache_decorator_wrapper","",".get, LRUCache, func, .put"
"C:/Users/Joseph Dania/Desktop/python_repo\other\lru_cache.py","","cache_info","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\magicdiamondpattern.py","","floyd","Print the upper half of a diamond pattern with '*' characters.  Args:     n (int): Size of the pattern.  Examples:     >>> floyd(3)     '  * \n * * \n* * * \n'      >>> floyd(5)     '    * \n   * * \n  * * * \n * * * * \n* * * * * \n'","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\magicdiamondpattern.py","","reverse_floyd","Print the lower half of a diamond pattern with '*' characters.  Args:     n (int): Size of the pattern.  Examples:     >>> reverse_floyd(3)     '* * * \n * * \n  * \n   '      >>> reverse_floyd(5)     '* * * * * \n * * * * \n  * * * \n   * * \n    * \n     '","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\magicdiamondpattern.py","","pretty_print","Print a complete diamond pattern with '*' characters.  Args:     n (int): Size of the pattern.  Examples:     >>> pretty_print(0)     '       ...       ....        nothing printing :('      >>> pretty_print(3)     '  * \n * * \n* * * \n* * * \n * * \n  * \n   '","floyd, reverse_floyd"
"C:/Users/Joseph Dania/Desktop/python_repo\other\majority_vote_algorithm.py","","majority_vote",">>> majority_vote([1, 2, 2, 3, 1, 3, 2], 3) [2] >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 2) [] >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 4) [1, 2, 3]","Counter, Counter, len, Counter, set, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\maximum_subsequence.py","","max_subsequence_sum","Return the maximum possible sum amongst all non - empty subsequences.  Raises:   ValueError: when nums is empty.  >>> max_subsequence_sum([1,2,3,4,-2]) 10 >>> max_subsequence_sum([-2, -3, -1, -4, -6]) -1 >>> max_subsequence_sum([]) Traceback (most recent call last):     . . . ValueError: Input sequence should not be empty >>> max_subsequence_sum() Traceback (most recent call last):     . . . ValueError: Input sequence should not be empty","range, ValueError, len, max"
"C:/Users/Joseph Dania/Desktop/python_repo\other\nested_brackets.py","","is_balanced",">>> is_balanced("""") True >>> is_balanced(""()"") True >>> is_balanced(""[]"") True >>> is_balanced(""{}"") True >>> is_balanced(""()[]{}"") True >>> is_balanced(""(())"") True >>> is_balanced(""[["") False >>> is_balanced(""([{}])"") True >>> is_balanced(""(()[)]"") False >>> is_balanced(""([)]"") False >>> is_balanced(""[[()]]"") True >>> is_balanced(""(()(()))"") True >>> is_balanced(""]"") False >>> is_balanced(""Life is a bowl of cherries."") True >>> is_balanced(""Life is a bowl of che{}ies."") True >>> is_balanced(""Life is a bowl of che}{ies."") False","stack.append, open_to_closed.values, stack.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\other\nested_brackets.py","","main","","input, print, is_balanced"
"C:/Users/Joseph Dania/Desktop/python_repo\other\number_container_system.py","NumberContainer","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\number_container_system.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\number_container_system.py","","binary_search_delete","Removes the item from the sorted array and returns the new array.  >>> NumberContainer().binary_search_delete([1,2,3], 2) [1, 3] >>> NumberContainer().binary_search_delete([0, 0, 0], 0) [0, 0] >>> NumberContainer().binary_search_delete([-1, -1, -1], -1) [-1, -1] >>> NumberContainer().binary_search_delete([-1, 0], 0) [-1] >>> NumberContainer().binary_search_delete([-1, 0], -1) [0] >>> NumberContainer().binary_search_delete(range(7), 3) [0, 1, 2, 4, 5, 6] >>> NumberContainer().binary_search_delete([1.1, 2.2, 3.3], 2.2) [1.1, 3.3] >>> NumberContainer().binary_search_delete(""abcde"", ""c"") ['a', 'b', 'd', 'e'] >>> NumberContainer().binary_search_delete([0, -1, 2, 4], 0) Traceback (most recent call last):     ... ValueError: Either the item is not in the array or the array was unsorted >>> NumberContainer().binary_search_delete([2, 0, 4, -1, 11], -1) Traceback (most recent call last):     ... ValueError: Either the item is not in the array or the array was unsorted >>> NumberContainer().binary_search_delete(125, 1) Traceback (most recent call last):     ... TypeError: binary_search_delete() only accepts either a list, range or str","isinstance, ValueError, list, len, isinstance, TypeError, array.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\other\number_container_system.py","","binary_search_insert","Inserts the index into the sorted array at the correct position.  >>> NumberContainer().binary_search_insert([1,2,3], 2) [1, 2, 2, 3] >>> NumberContainer().binary_search_insert([0,1,3], 2) [0, 1, 2, 3] >>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 103], 51) [-5, -3, 0, 0, 11, 51, 103] >>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 100, 103], 101) [-5, -3, 0, 0, 11, 100, 101, 103] >>> NumberContainer().binary_search_insert(range(10), 4) [0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9] >>> NumberContainer().binary_search_insert(""abd"", ""c"") ['a', 'b', 'c', 'd'] >>> NumberContainer().binary_search_insert(131, 23) Traceback (most recent call last):     ... TypeError: binary_search_insert() only accepts either a list, range or str","isinstance, array.insert, list, len, isinstance, TypeError, array.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\other\number_container_system.py","","change","Changes (sets) the index as number  >>> cont = NumberContainer() >>> cont.change(0, 10) >>> cont.change(0, 20) >>> cont.change(-13, 20) >>> cont.change(-100030, 20032903290)","self.binary_search_insert, len, self.binary_search_delete"
"C:/Users/Joseph Dania/Desktop/python_repo\other\number_container_system.py","","find","Returns the smallest index where the number is.  >>> cont = NumberContainer() >>> cont.find(10) -1 >>> cont.change(0, 10) >>> cont.find(10) 0 >>> cont.change(0, 20) >>> cont.find(10) -1 >>> cont.find(20) 0","self.numbermap.get"
"C:/Users/Joseph Dania/Desktop/python_repo\other\password.py","","password_generator","Password Generator allows you to generate a random password of length N.  >>> len(password_generator()) 8 >>> len(password_generator(length=16)) 16 >>> len(password_generator(257)) 257 >>> len(password_generator(length=0)) 0 >>> len(password_generator(-1)) 0",".join, secrets.choice, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\password.py","","alternative_password_generator","","len, list, shuffle, .join, random, random, random"
"C:/Users/Joseph Dania/Desktop/python_repo\other\password.py","","random","",".join, secrets.choice, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\password.py","","is_strong_password","This will check whether a given password is strong or not. The password must be at least as long as the provided minimum length, and it must contain at least 1 lowercase letter, 1 uppercase letter, 1 number and 1 special character.  >>> is_strong_password('Hwea7$2!') True >>> is_strong_password('Sh0r1') False >>> is_strong_password('Hello123') False >>> is_strong_password('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1') True >>> is_strong_password('0') False","any, any, any, any, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\password.py","","main","","int, .strip, print, print, print, .strip, password_generator, alternative_password_generator, input, input"
"C:/Users/Joseph Dania/Desktop/python_repo\other\scoring_algorithm.py","","get_data",">>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]]) [[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]","enumerate, .append, len, data_lists.append, float"
"C:/Users/Joseph Dania/Desktop/python_repo\other\scoring_algorithm.py","","calculate_each_score",">>> calculate_each_score([[20, 23, 22], [60, 90, 50], [2012, 2015, 2011]], ...                      [0, 0, 1]) [[1.0, 0.0, 0.33333333333333337], [0.75, 0.0, 1.0], [0.25, 1.0, 0.0]]","zip, min, max, score_lists.append, ValueError, score.append, score.append, score.append, score.append"
"C:/Users/Joseph Dania/Desktop/python_repo\other\scoring_algorithm.py","","generate_final_scores",">>> generate_final_scores([[1.0, 0.0, 0.33333333333333337], ...                        [0.75, 0.0, 1.0], ...                        [0.25, 1.0, 0.0]]) [2.0, 1.0, 1.3333333333333335]","enumerate, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\scoring_algorithm.py","","procentual_proximity","| `weights` - ``int`` list | possible values - ``0`` / ``1``      * ``0`` if lower values have higher weight in the data set     * ``1`` if higher values have higher weight in the data set  >>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1]) [[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]","get_data, calculate_each_score, generate_final_scores, enumerate, .append"
"C:/Users/Joseph Dania/Desktop/python_repo\other\sdes.py","","apply_table",">>> apply_table(""0123456789"", list(range(10))) '9012345678' >>> apply_table(""0123456789"", list(range(9, -1, -1))) '8765432109'",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\sdes.py","","left_shift",">>> left_shift(""0123456789"") '1234567890'",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\sdes.py","","xor",">>> xor(""01010101"", ""00001111"") '01011010'","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\sdes.py","","apply_sbox","","int, int, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\other\sdes.py","","function","","apply_table, xor, apply_sbox, apply_sbox, apply_table, xor, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\other\tower_of_hanoi.py","","move_tower",">>> move_tower(3, 'A', 'B', 'C') moving disk from A to B moving disk from A to C moving disk from B to C moving disk from A to B moving disk from C to A moving disk from C to B moving disk from A to B","move_tower, move_disk, move_tower"
"C:/Users/Joseph Dania/Desktop/python_repo\other\tower_of_hanoi.py","","move_disk","","print"
"C:/Users/Joseph Dania/Desktop/python_repo\other\tower_of_hanoi.py","","main","","int, move_tower, .strip, input"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","WordSearch","",">>> ws = WordSearch(WORDS, WIDTH, HEIGHT) >>> ws.board  # doctest: +ELLIPSIS [[None, ..., None], ..., [None, ..., None]] >>> ws.generate_board()",""
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","visualise_word_search","Graphically displays the word search in the terminal.  >>> ws = WordSearch(WORDS, 5, 5) >>> ws.insert_north(""cat"", [4], [4]) >>> visualise_word_search( ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE # # # # # # # # # # # # # # t # # # # a # # # # c >>> ws.insert_northeast(""snake"", [4], [4, 3, 2, 1, 0]) >>> visualise_word_search( ...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE # # # # e # # # k # # # a # t # n # # a s # # # c","range, print, WordSearch, word_search.generate_board, len, range, len, chr, randint"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","__init__","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_north",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_north(""cat"", [2], [2]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, None, 't'], [None, None, 'a'], [None, None, 'c']] >>> ws.insert_north(""at"", [0, 1, 2], [2, 1]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, 't', 't'], [None, 'a', 'a'], [None, None, 'c']]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_northeast",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_northeast(""cat"", [2], [0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, None, 't'], [None, 'a', None], ['c', None, None]] >>> ws.insert_northeast(""at"", [0, 1], [2, 1, 0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, 't', 't'], ['a', 'a', None], ['c', None, None]]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_east",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_east(""cat"", [1], [0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, None, None], ['c', 'a', 't'], [None, None, None]] >>> ws.insert_east(""at"", [1, 0], [2, 1, 0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, 'a', 't'], ['c', 'a', 't'], [None, None, None]]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_southeast",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_southeast(""cat"", [0], [0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['c', None, None], [None, 'a', None], [None, None, 't']] >>> ws.insert_southeast(""at"", [1, 0], [2, 1, 0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['c', None, None], ['a', 'a', None], [None, 't', 't']]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_south",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_south(""cat"", [0], [0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['c', None, None], ['a', None, None], ['t', None, None]] >>> ws.insert_south(""at"", [2, 1, 0], [0, 1, 2]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['c', None, None], ['a', 'a', None], ['t', 't', None]]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_southwest",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_southwest(""cat"", [0], [2]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, None, 'c'], [None, 'a', None], ['t', None, None]] >>> ws.insert_southwest(""at"", [1, 2], [2, 1, 0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, None, 'c'], [None, 'a', 'a'], ['t', 't', None]]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_west",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_west(""cat"", [1], [2]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [[None, None, None], ['t', 'a', 'c'], [None, None, None]] >>> ws.insert_west(""at"", [1, 0], [1, 2, 0]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['t', 'a', None], ['t', 'a', 'c'], [None, None, None]]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","insert_northwest",">>> ws = WordSearch(WORDS, 3, 3) >>> ws.insert_northwest(""cat"", [2], [2]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['t', None, None], [None, 'a', None], [None, None, 'c']] >>> ws.insert_northwest(""at"", [1, 2], [0, 1]) >>> ws.board  # doctest: +NORMALIZE_WHITESPACE [['t', None, None], ['t', 'a', None], [None, 'a', 'c']]","len, all, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\other\word_search.py","","generate_board","Generates a board with a random direction for each word.  >>> wt = WordSearch(WORDS, WIDTH, HEIGHT) >>> wt.generate_board() >>> len(list(filter(lambda word: word is not None, sum(wt.board, start=[]))) ... ) == sum(map(lambda word: len(word), WORDS)) True","shuffle, shuffle, , list, list, choice, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\altitude_pressure.py","","get_altitude_at_pressure","This method calculates the altitude from Pressure wrt to Sea level pressure as reference .Pressure is in Pascals https://en.wikipedia.org/wiki/Pressure_altitude https://community.bosch-sensortec.com/t5/Question-and-answers/How-to-calculate-the-altitude-from-the-pressure-sensor-data/qaq-p/5702  H = 44330 * [1 - (P/p0)^(1/5.255) ]  Where : H = altitude (m) P = measured pressure p0 = reference pressure at sea level 101325 Pa  Examples: >>> get_altitude_at_pressure(pressure=100_000) 105.47836610778828 >>> get_altitude_at_pressure(pressure=101_325) 0.0 >>> get_altitude_at_pressure(pressure=80_000) 1855.873388064995 >>> get_altitude_at_pressure(pressure=201_325) Traceback (most recent call last):   ... ValueError: Value Higher than Pressure at Sea Level ! >>> get_altitude_at_pressure(pressure=-80_000) Traceback (most recent call last):   ... ValueError: Atmospheric Pressure can not be negative !","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\archimedes_principle_of_buoyant_force.py","","archimedes_principle","Args:     fluid_density: density of fluid (kg/m^3)     volume: volume of object/liquid being displaced by the object (m^3)     gravity: Acceleration from gravity. Gravitational force on the system,         The default is Earth Gravity returns:     the buoyant force on an object in Newtons  >>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8) 19600.0 >>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8) 4885.3 >>> archimedes_principle(fluid_density=997, volume=0.7) 6844.061035 >>> archimedes_principle(fluid_density=997, volume=-0.7) Traceback (most recent call last):     ... ValueError: Impossible object volume >>> archimedes_principle(fluid_density=0, volume=0.7) Traceback (most recent call last):     ... ValueError: Impossible fluid density >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0) 0.0 >>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8) Traceback (most recent call last):     ... ValueError: Impossible gravity","ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\basic_orbital_capture.py","","capture_radii","Input Params: ------------- target_body_radius: Radius of the central body SI units: meters | m target_body_mass: Mass of the central body SI units: kilograms | kg projectile_velocity: Velocity of object moving toward central body     SI units: meters/second | m/s Returns: -------- >>> capture_radii(6.957e8, 1.99e30, 25000.0) 17209590691.0 >>> capture_radii(-6.957e8, 1.99e30, 25000.0) Traceback (most recent call last):     ... ValueError: Radius cannot be less than 0 >>> capture_radii(6.957e8, -1.99e30, 25000.0) Traceback (most recent call last):     ... ValueError: Mass cannot be less than 0 >>> capture_radii(6.957e8, 1.99e30, c+1) Traceback (most recent call last):     ... ValueError: Cannot go beyond speed of light  Returned SI units: ------------------ meters | m","round, ValueError, ValueError, ValueError, sqrt, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\basic_orbital_capture.py","","capture_area","Input Param: ------------ capture_radius: The radius of orbital capture and impact for a central body of mass M and a projectile moving towards it with velocity v     SI units: meters | m Returns: -------- >>> capture_area(17209590691) 9.304455331329126e+20 >>> capture_area(-1) Traceback (most recent call last):     ... ValueError: Cannot have a capture radius less than 0  Returned SI units: ------------------ meters*meters | m**2","round, ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\casimir_effect.py","","casimir_force","Input Parameters ---------------- force -> Casimir Force : magnitude in Newtons  area -> Surface area of each plate : magnitude in square meters  distance -> Distance between two plates : distance in Meters  Returns ------- result : dict name, value pair of the parameter having Zero as it's value  Returns the value of one of the parameters specified as 0, provided the values of other parameters are given. >>> casimir_force(force = 0, area = 4, distance = 0.03) {'force': 6.4248189174864216e-21}  >>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0) {'distance': 1.0323056015031114e-05}  >>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746) {'area': 0.06688838837354052}  >>> casimir_force(force = 3457e-12, area = 0, distance = 0) Traceback (most recent call last):     ... ValueError: One and only one argument must be 0  >>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344) Traceback (most recent call last):     ... ValueError: Distance can not be negative  >>> casimir_force(force = -912e-12, area = 0, distance = 0.09374) Traceback (most recent call last):     ... ValueError: Magnitude of force can not be negative","ValueError, .count, ValueError, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\center_of_mass.py","","center_of_mass","Input Parameters ---------------- particles: list(Particle): A list of particles where each particle is a tuple with it's (x, y, z) position and it's mass.  Returns ------- Coord3D: A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two decimal places.  Examples -------- >>> center_of_mass([ ...     Particle(1.5, 4, 3.4, 4), ...     Particle(5, 6.8, 7, 8.1), ...     Particle(9.4, 10.1, 11.6, 12) ... ]) Coord3D(x=6.61, y=7.98, z=8.69)  >>> center_of_mass([ ...     Particle(1, 2, 3, 4), ...     Particle(5, 6, 7, 8), ...     Particle(9, 10, 11, 12) ... ]) Coord3D(x=6.33, y=7.33, z=8.33)  >>> center_of_mass([ ...     Particle(1, 2, 3, -4), ...     Particle(5, 6, 7, 8), ...     Particle(9, 10, 11, 12) ... ]) Traceback (most recent call last):     ... ValueError: Mass of all particles must be greater than 0  >>> center_of_mass([ ...     Particle(1, 2, 3, 0), ...     Particle(5, 6, 7, 8), ...     Particle(9, 10, 11, 12) ... ]) Traceback (most recent call last):     ... ValueError: Mass of all particles must be greater than 0  >>> center_of_mass([]) Traceback (most recent call last):     ... ValueError: No particles provided","any, sum, round, round, round, Coord3D, ValueError, ValueError, sum, sum, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\centripetal_force.py","","centripetal","The Centripetal Force formula is given as: (m*v*v)/r  >>> round(centripetal(15.5,-30,10),2) 1395.0 >>> round(centripetal(10,15,5),2) 450.0 >>> round(centripetal(20,-50,15),2) 3333.33 >>> round(centripetal(12.25,40,25),2) 784.0 >>> round(centripetal(50,100,50),2) 10000.0","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\coulombs_law.py","","coulombs_law","Calculate the electrostatic force of attraction or repulsion between two point charges  >>> coulombs_law(15.5, 20, 15) 12382849136.06 >>> coulombs_law(1, 15, 5) 5392531075.38 >>> coulombs_law(20, -50, 15) -39944674632.44 >>> coulombs_law(-5, -8, 10) 3595020716.92 >>> coulombs_law(50, 100, 50) 17975103584.6","round, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\doppler_frequency.py","","doppler_effect","Input Parameters: ----------------- org_freq: frequency of the wave when the source is stationary wave_vel: velocity of the wave in the medium obs_vel: velocity of the observer, +ve if the observer is moving towards the source src_vel: velocity of the source, +ve if the source is moving towards the observer  Returns: -------- f: frequency of the wave as perceived by the observer  Docstring Tests: >>> doppler_effect(100, 330, 10, 0)  # observer moving towards the source 103.03030303030303 >>> doppler_effect(100, 330, -10, 0)  # observer moving away from the source 96.96969696969697 >>> doppler_effect(100, 330, 0, 10)  # source moving towards the observer 103.125 >>> doppler_effect(100, 330, 0, -10)  # source moving away from the observer 97.05882352941177 >>> doppler_effect(100, 330, 10, 10)  # source & observer moving towards each other 106.25 >>> doppler_effect(100, 330, -10, -10)  # source and observer moving away 94.11764705882354 >>> doppler_effect(100, 330, 10, 330)  # source moving at same speed as the wave Traceback (most recent call last):     ... ZeroDivisionError: Division by zero implies vs=v and observer in front of the source >>> doppler_effect(100, 330, 10, 340)  # source moving faster than the wave Traceback (most recent call last):     ... ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction) >>> doppler_effect(100, 330, -340, 10)  # observer moving faster than the wave Traceback (most recent call last):     ... ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)","ZeroDivisionError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\escape_velocity.py","","escape_velocity","Calculates the escape velocity needed to break free from a celestial body's gravitational field.  The formula used is:     v = sqrt(2 * G * M / R)  where:     v = escape velocity (m/s)     G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)     M = mass of the celestial body (kg)     R = radius from the center of mass (m)  Source:     https://en.wikipedia.org/wiki/Escape_velocity  Args:     mass (float): Mass of the celestial body in kilograms.     radius (float): Radius from the center of mass in meters.  Returns:     float: Escape velocity in meters per second, rounded to 3 decimal places.  Examples:     >>> escape_velocity(mass=5.972e24, radius=6.371e6)  # Earth     11185.978     >>> escape_velocity(mass=7.348e22, radius=1.737e6)  # Moon     2376.307     >>> escape_velocity(mass=1.898e27, radius=6.9911e7)  # Jupiter     60199.545     >>> escape_velocity(mass=0, radius=1.0)     0.0     >>> escape_velocity(mass=1.0, radius=0)     Traceback (most recent call last):         ...     ZeroDivisionError: Radius cannot be zero.","math.sqrt, round, ZeroDivisionError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\grahams_law.py","","validate","Input Parameters: ----------------- effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.) effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.) molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.) molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)  Returns: -------- >>> validate(2.016, 4.002) True >>> validate(-2.016, 4.002) False >>> validate() False","all, len"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\grahams_law.py","","effusion_ratio","Input Parameters: ----------------- molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.) molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)  Returns: -------- >>> effusion_ratio(2.016, 4.002) 1.408943 >>> effusion_ratio(-2.016, 4.002) ValueError('Input Error: Molar mass values must greater than 0.') >>> effusion_ratio(2.016) Traceback (most recent call last):   ... TypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'","validate, round, ValueError, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\grahams_law.py","","first_effusion_rate","Input Parameters: ----------------- effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.) molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.) molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)  Returns: -------- >>> first_effusion_rate(1, 2.016, 4.002) 1.408943 >>> first_effusion_rate(-1, 2.016, 4.002) ValueError('Input Error: Molar mass and effusion rate values must greater than 0.') >>> first_effusion_rate(1) Traceback (most recent call last):   ... TypeError: first_effusion_rate() missing 2 required positional arguments: 'molar_mass_1' and 'molar_mass_2' >>> first_effusion_rate(1, 2.016) Traceback (most recent call last):   ... TypeError: first_effusion_rate() missing 1 required positional argument: 'molar_mass_2'","validate, round, ValueError, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\grahams_law.py","","second_effusion_rate","Input Parameters: ----------------- effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.) molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.) molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)  Returns: -------- >>> second_effusion_rate(1, 2.016, 4.002) 0.709752 >>> second_effusion_rate(-1, 2.016, 4.002) ValueError('Input Error: Molar mass and effusion rate values must greater than 0.') >>> second_effusion_rate(1) Traceback (most recent call last):   ... TypeError: second_effusion_rate() missing 2 required positional arguments: 'molar_mass_1' and 'molar_mass_2' >>> second_effusion_rate(1, 2.016) Traceback (most recent call last):   ... TypeError: second_effusion_rate() missing 1 required positional argument: 'molar_mass_2'","validate, round, ValueError, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\grahams_law.py","","first_molar_mass","Input Parameters: ----------------- molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.) effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.) effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)  Returns: -------- >>> first_molar_mass(2, 1.408943, 0.709752) 0.507524 >>> first_molar_mass(-1, 2.016, 4.002) ValueError('Input Error: Molar mass and effusion rate values must greater than 0.') >>> first_molar_mass(1) Traceback (most recent call last):   ... TypeError: first_molar_mass() missing 2 required positional arguments: 'effusion_rate_1' and 'effusion_rate_2' >>> first_molar_mass(1, 2.016) Traceback (most recent call last):   ... TypeError: first_molar_mass() missing 1 required positional argument: 'effusion_rate_2'","validate, round, ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\grahams_law.py","","second_molar_mass","Input Parameters: ----------------- molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.) effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.) effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)  Returns: -------- >>> second_molar_mass(2, 1.408943, 0.709752) 1.970351 >>> second_molar_mass(-2, 1.408943, 0.709752) ValueError('Input Error: Molar mass and effusion rate values must greater than 0.') >>> second_molar_mass(1) Traceback (most recent call last):   ... TypeError: second_molar_mass() missing 2 required positional arguments: 'effusion_rate_1' and 'effusion_rate_2' >>> second_molar_mass(1, 2.016) Traceback (most recent call last):   ... TypeError: second_molar_mass() missing 1 required positional argument: 'effusion_rate_2'","validate, round, ValueError, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\horizontal_projectile_motion.py","","check_args","Check that the arguments are valid","isinstance, TypeError, isinstance, TypeError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\horizontal_projectile_motion.py","","horizontal_distance","Returns the horizontal distance that the object cover  Formula:     .. math::         \frac{v_0^2 \cdot \sin(2 \alpha)}{g}          v_0 - \text{initial velocity}          \alpha - \text{angle}  >>> horizontal_distance(30, 45) 91.77 >>> horizontal_distance(100, 78) 414.76 >>> horizontal_distance(-1, 20) Traceback (most recent call last):     ... ValueError: Invalid velocity. Should be a positive number. >>> horizontal_distance(30, -20) Traceback (most recent call last):     ... ValueError: Invalid angle. Range is 1-90 degrees.","check_args, deg_to_rad, round, sin"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\horizontal_projectile_motion.py","","max_height","Returns the maximum height that the object reach  Formula:     .. math::         \frac{v_0^2 \cdot \sin^2 (\alpha)}{2 g}          v_0 - \text{initial velocity}          \alpha - \text{angle}  >>> max_height(30, 45) 22.94 >>> max_height(100, 78) 487.82 >>> max_height(""a"", 20) Traceback (most recent call last):     ... TypeError: Invalid velocity. Should be an integer or float. >>> horizontal_distance(30, ""b"") Traceback (most recent call last):     ... TypeError: Invalid angle. Should be an integer or float.","check_args, deg_to_rad, round, sin"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\horizontal_projectile_motion.py","","total_time","Returns total time of the motion  Formula:     .. math::         \frac{2 v_0 \cdot \sin (\alpha)}{g}          v_0 - \text{initial velocity}          \alpha - \text{angle}  >>> total_time(30, 45) 4.33 >>> total_time(100, 78) 19.95 >>> total_time(-10, 40) Traceback (most recent call last):     ... ValueError: Invalid velocity. Should be a positive number. >>> total_time(30, ""b"") Traceback (most recent call last):     ... TypeError: Invalid angle. Should be an integer or float.","check_args, deg_to_rad, round, sin"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\horizontal_projectile_motion.py","","test_motion","Test motion  >>> test_motion()","horizontal_distance, max_height, total_time"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\hubble_parameter.py","","hubble_parameter","Input Parameters ---------------- hubble_constant: Hubble constante is the expansion rate today usually given in km/(s*Mpc)  radiation_density: relative radiation density today  matter_density: relative mass density today  dark_energy: relative dark energy density today  redshift: the light redshift  Returns ------- result : Hubble parameter in and the unit km/s/Mpc (the unit can be changed if you want, just need to change the unit of the Hubble constant)  >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4, ... matter_density=-0.3, dark_energy=0.7, redshift=1) Traceback (most recent call last): ... ValueError: All input parameters must be positive  >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4, ... matter_density= 1.2, dark_energy=0.7, redshift=1) Traceback (most recent call last): ... ValueError: Relative densities cannot be greater than one  >>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4, ... matter_density= 0.3, dark_energy=0.7, redshift=0) 68.3","any, any, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\ideal_gas_law.py","","pressure_of_gas_system",">>> pressure_of_gas_system(2, 100, 5) 332.57848 >>> pressure_of_gas_system(0.5, 273, 0.004) 283731.01575 >>> pressure_of_gas_system(3, -0.46, 23.5) Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter positive value.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\ideal_gas_law.py","","volume_of_gas_system",">>> volume_of_gas_system(2, 100, 5) 332.57848 >>> volume_of_gas_system(0.5, 273, 0.004) 283731.01575 >>> volume_of_gas_system(3, -0.46, 23.5) Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter positive value.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\ideal_gas_law.py","","temperature_of_gas_system",">>> temperature_of_gas_system(2, 100, 5) 30.068090996146232 >>> temperature_of_gas_system(11, 5009, 1000) 54767.66101807144 >>> temperature_of_gas_system(3, -0.46, 23.5) Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter positive value.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\ideal_gas_law.py","","moles_of_gas_system",">>> moles_of_gas_system(100, 5, 10) 0.06013618199229246 >>> moles_of_gas_system(110, 5009, 1000) 5476.766101807144 >>> moles_of_gas_system(3, -0.46, 23.5) Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter positive value.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\in_static_equilibrium.py","","polar_force","Resolves force along rectangular components. (force, angle) => (force_x, force_y) >>> import math >>> force = polar_force(10, 45) >>> math.isclose(force[0], 7.071067811865477) True >>> math.isclose(force[1], 7.0710678118654755) True >>> force = polar_force(10, 3.14, radian_mode=True) >>> math.isclose(force[0], -9.999987317275396) True >>> math.isclose(force[1], 0.01592652916486828) True","cos, sin, cos, sin, radians, radians"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\in_static_equilibrium.py","","in_static_equilibrium","Check if a system is in equilibrium. It takes two numpy.array objects. forces ==>  [                     [force1_x, force1_y],                     [force2_x, force2_y],                     ....] location ==>  [                     [x1, y1],                     [x2, y2],                     ....] >>> force = array([[1, 1], [-1, 2]]) >>> location = array([[1, 0], [10, 0]]) >>> in_static_equilibrium(force, location) False","cross, sum, bool, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\kinetic_energy.py","","kinetic_energy","Calculate kinetic energy.  The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv  >>> kinetic_energy(10,10) 500.0 >>> kinetic_energy(0,10) 0.0 >>> kinetic_energy(10,0) 0.0 >>> kinetic_energy(20,-20) 4000.0 >>> kinetic_energy(0,0) 0.0 >>> kinetic_energy(2,2) 4.0 >>> kinetic_energy(100,100) 500000.0","ValueError, abs, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lens_formulae.py","","focal_length_of_lens","Doctests: >>> from math import isclose >>> isclose(focal_length_of_lens(10,4), 6.666666666666667) True >>> from math import isclose >>> isclose(focal_length_of_lens(2.7,5.8), -5.0516129032258075) True >>> focal_length_of_lens(0, 20)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter non zero values with respect to the sign convention.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lens_formulae.py","","object_distance","Doctests: >>> from math import isclose >>> isclose(object_distance(10,40), -13.333333333333332) True  >>> from math import isclose >>> isclose(object_distance(6.2,1.5), 1.9787234042553192) True  >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter non zero values with respect to the sign convention.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lens_formulae.py","","image_distance","Doctests: >>> from math import isclose >>> isclose(image_distance(50,40), 22.22222222222222) True >>> from math import isclose >>> isclose(image_distance(5.3,7.9), 3.1719696969696973) True  >>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter non zero values with respect to the sign convention.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lorentz_transformation_four_vector.py","","beta","Calculates  = v/c, the given velocity as a fraction of c >>> beta(c) 1.0 >>> beta(199792458) 0.666435904801848 >>> beta(1e5) 0.00033356409519815205 >>> beta(0.2) Traceback (most recent call last):   ... ValueError: Speed must be greater than or equal to 1!","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lorentz_transformation_four_vector.py","","gamma","Calculate the Lorentz factor y = 1 / (1 - v/c) for a given velocity >>> gamma(4) 1.0000000000000002 >>> gamma(1e5) 1.0000000556325075 >>> gamma(3e7) 1.005044845777813 >>> gamma(2.8e8) 2.7985595722318277 >>> gamma(299792451) 4627.49902669495 >>> gamma(0.3) Traceback (most recent call last):   ... ValueError: Speed must be greater than or equal to 1! >>> gamma(2 * c) Traceback (most recent call last):   ... ValueError: Speed must not exceed light speed 299,792,458 [m/s]!","sqrt, beta"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lorentz_transformation_four_vector.py","","transformation_matrix","Calculate the Lorentz transformation matrix for movement in the x direction:  | y  -  0  0| |-  y   0  0| | 0   0   1  0| | 0   0   0  1|  where y is the Lorentz factor and  is the velocity as a fraction of c >>> transformation_matrix(29979245) array([[ 1.00503781, -0.10050378,  0.        ,  0.        ],        [-0.10050378,  1.00503781,  0.        ,  0.        ],        [ 0.        ,  0.        ,  1.        ,  0.        ],        [ 0.        ,  0.        ,  0.        ,  1.        ]]) >>> transformation_matrix(19979245.2) array([[ 1.00222811, -0.06679208,  0.        ,  0.        ],        [-0.06679208,  1.00222811,  0.        ,  0.        ],        [ 0.        ,  0.        ,  1.        ,  0.        ],        [ 0.        ,  0.        ,  0.        ,  1.        ]]) >>> transformation_matrix(1) array([[ 1.00000000e+00, -3.33564095e-09,  0.00000000e+00,          0.00000000e+00],        [-3.33564095e-09,  1.00000000e+00,  0.00000000e+00,          0.00000000e+00],        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,          0.00000000e+00],        [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,          1.00000000e+00]]) >>> transformation_matrix(0) Traceback (most recent call last):   ... ValueError: Speed must be greater than or equal to 1! >>> transformation_matrix(c * 1.5) Traceback (most recent call last):   ... ValueError: Speed must not exceed light speed 299,792,458 [m/s]!","np.array, gamma, gamma, beta, beta, gamma, gamma"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\lorentz_transformation_four_vector.py","","transform","Calculate a Lorentz transformation for movement in the x direction given a velocity and a four-vector for an inertial reference frame  If no four-vector is given, then calculate the transformation symbolically with variables >>> transform(29979245, np.array([1, 2, 3, 4])) array([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00]) >>> transform(29979245) array([1.00503781498831*ct - 0.100503778816875*x,        -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],       dtype=object) >>> transform(19879210.2) array([1.0022057787097*ct - 0.066456172618675*x,        -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],       dtype=object) >>> transform(299792459, np.array([1, 1, 1, 1])) Traceback (most recent call last):   ... ValueError: Speed must not exceed light speed 299,792,458 [m/s]! >>> transform(-1, np.array([1, 1, 1, 1])) Traceback (most recent call last):   ... ValueError: Speed must be greater than or equal to 1!","np.array, transformation_matrix"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\malus_law.py","","malus_law",">>> round(malus_law(10,45),2) 5.0 >>> round(malus_law(100,60),2) 25.0 >>> round(malus_law(50,150),2) 37.5 >>> round(malus_law(75,270),2) 0.0 >>> round(malus_law(10,-900),2) Traceback (most recent call last):     ... ValueError: In Malus Law, the angle is in the range 0-360 degrees >>> round(malus_law(10,900),2) Traceback (most recent call last):     ... ValueError: In Malus Law, the angle is in the range 0-360 degrees >>> round(malus_law(-100,900),2) Traceback (most recent call last):     ... ValueError: The value of intensity cannot be negative >>> round(malus_law(100,180),2) 100.0 >>> round(malus_law(100,360),2) 100.0","ValueError, ValueError, math.cos, math.radians"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\mass_energy_equivalence.py","","energy_from_mass","Calculates the Energy equivalence of the Mass using E = mc in SI units J from Mass in kg.  mass (float): Mass of body.  Usage example: >>> energy_from_mass(124.56) 1.11948945063458e+19 >>> energy_from_mass(320) 2.8760165719578165e+19 >>> energy_from_mass(0) 0.0 >>> energy_from_mass(-967.9) Traceback (most recent call last):     ... ValueError: Mass can't be negative.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\mass_energy_equivalence.py","","mass_from_energy","Calculates the Mass equivalence of the Energy using m = E/c in SI units kg from Energy in J.  energy (float): Mass of body.  Usage example: >>> mass_from_energy(124.56) 1.3859169098203872e-15 >>> mass_from_energy(320) 3.560480179371579e-15 >>> mass_from_energy(0) 0.0 >>> mass_from_energy(-967.9) Traceback (most recent call last):     ... ValueError: Energy can't be negative.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\mirror_formulae.py","","focal_length",">>> from math import isclose >>> isclose(focal_length(10, 20), 6.66666666666666) True >>> from math import isclose >>> isclose(focal_length(9.5, 6.7), 3.929012346) True >>> focal_length(0, 20)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter non zero values with respect to the sign convention.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\mirror_formulae.py","","object_distance",">>> from math import isclose >>> isclose(object_distance(30, 20), -60.0) True >>> from math import isclose >>> isclose(object_distance(10.5, 11.7), 102.375) True >>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter non zero values with respect to the sign convention.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\mirror_formulae.py","","image_distance",">>> from math import isclose >>> isclose(image_distance(10, 40), 13.33333333) True >>> from math import isclose >>> isclose(image_distance(1.5, 6.7), 1.932692308) True >>> image_distance(0, 0)  # doctest: +NORMALIZE_WHITESPACE Traceback (most recent call last):     ... ValueError: Invalid inputs. Enter non zero values with respect to the sign convention.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\newtons_law_of_gravitation.py","","gravitational_law","Input Parameters ---------------- force : magnitude in Newtons  mass_1 : mass in Kilograms  mass_2 : mass in Kilograms  distance : distance in Meters  Returns ------- result : dict name, value pair of the parameter having Zero as it's value  Returns the value of one of the parameters specified as 0, provided the values of other parameters are given. >>> gravitational_law(force=0, mass_1=5, mass_2=10, distance=20) {'force': 8.342875e-12}  >>> gravitational_law(force=7367.382, mass_1=0, mass_2=74, distance=3048) {'mass_1': 1.385816317292268e+19}  >>> gravitational_law(force=36337.283, mass_1=0, mass_2=0, distance=35584) Traceback (most recent call last):     ... ValueError: One and only one argument must be 0  >>> gravitational_law(force=36337.283, mass_1=-674, mass_2=0, distance=35584) Traceback (most recent call last):     ... ValueError: Mass can not be negative  >>> gravitational_law(force=-847938e12, mass_1=674, mass_2=0, distance=9374) Traceback (most recent call last):     ... ValueError: Gravitational force can not be negative","ValueError, .count, ValueError, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\newtons_second_law_of_motion.py","","newtons_second_law_of_motion","Calculates force from `mass` and `acceleration`  >>> newtons_second_law_of_motion(10, 10) 100 >>> newtons_second_law_of_motion(2.0, 1) 2.0",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","Body","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","BodySystem","","This class is used to hold the bodies, the gravitation constant, the time factor and the softening factor. The time factor is used to control the speed of the simulation. The softening factor is used for softening, a numerical trick for N-body simulations to prevent numerical divergences when two bodies get too close to each other.",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","update_step","Updates the body-system and applies the change to the patch-list used for plotting  >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)]) >>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size, ... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS >>> update_step(body_system_1, 1, patches_1) >>> patches_1[0].center (0.01, 0.0)  >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10) >>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size, ... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS >>> update_step(body_system_2, 1, patches_2) >>> patches_2[0].center (-9.0, 0.0)","body_system.update_system, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","plot","Utility function to plot how the given body-system evolves over time. No doctest provided since this function does not have a return value.","plt.figure, fig.canvas.manager.set_window_title, plt.axes, .set_aspect, animation.FuncAnimation, plt.show, plt.Circle, ax.add_patch, update_step, plt.gca"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","example_1","Example 1: figure-8 solution to the 3-body-problem This example can be seen as a test of the implementation: given the right initial conditions, the bodies should move in a figure-8. (initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html) >>> body_system = example_1() >>> len(body_system) 3","BodySystem, Body, Body, Body"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","example_2","Example 2: Moon's orbit around the earth This example can be seen as a test of the implementation: given the right initial conditions, the moon should orbit around the earth as it actually does. (mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth and https://en.wikipedia.org/wiki/Moon) No doctest provided since this function does not have a return value.","Body, Body, BodySystem"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","example_3","Example 3: Random system with many bodies. No doctest provided since this function does not have a return value.","range, BodySystem, random.uniform, random.uniform, bodies.append, bodies.append, Body, Body, random.uniform, random.uniform, random.uniform, random.uniform"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","__init__","The parameters ""size"" & ""color"" are not relevant for the simulation itself, they are only used for plotting.",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","position","",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","velocity","",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","update_velocity","Euler algorithm for velocity  >>> body_1 = Body(0.,0.,0.,0.) >>> body_1.update_velocity(1.,0.,1.) >>> body_1.velocity (1.0, 0.0)  >>> body_1.update_velocity(1.,0.,1.) >>> body_1.velocity (2.0, 0.0)  >>> body_2 = Body(0.,0.,5.,0.) >>> body_2.update_velocity(0.,-10.,10.) >>> body_2.velocity (5.0, -100.0)  >>> body_2.update_velocity(0.,-10.,10.) >>> body_2.velocity (5.0, -200.0)",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","update_position","Euler algorithm for position  >>> body_1 = Body(0.,0.,1.,0.) >>> body_1.update_position(1.) >>> body_1.position (1.0, 0.0)  >>> body_1.update_position(1.) >>> body_1.position (2.0, 0.0)  >>> body_2 = Body(10.,10.,0.,-2.) >>> body_2.update_position(1.) >>> body_2.position (10.0, 8.0)  >>> body_2.update_position(1.) >>> body_2.position (10.0, 6.0)",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","__len__","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","update_system","For each body, loop through all other bodies to calculate the total force they exert on it. Use that force to update the body's velocity.  >>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)]) >>> len(body_system_1) 2 >>> body_system_1.update_system(1) >>> body_system_1.bodies[0].position (0.01, 0.0) >>> body_system_1.bodies[0].velocity (0.01, 0.0)  >>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10) >>> body_system_2.update_system(1) >>> body_system_2.bodies[0].position (-9.0, 0.0) >>> body_system_2.bodies[0].velocity (0.1, 0.0)","body1.update_velocity, body.update_position"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\n_body_simulation.py","","update","","update_step"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\orbital_transfer_work.py","","orbital_transfer_work","Calculates the work required to move an object from one orbit to another in a gravitational field based on the change in total mechanical energy.  The formula used is:     W = (G * M * m / 2) * (1/r_initial - 1/r_final)  where:     W = work done (Joules)     G = gravitational constant (6.67430 * 10^-11 m^3 kg^-1 s^-2)     M = mass of the central body (kg)     m = mass of the orbiting object (kg)     r_initial = initial orbit radius (m)     r_final = final orbit radius (m)  Args:     mass_central (float): Mass of the central body (kg)     mass_object (float): Mass of the object being moved (kg)     r_initial (float): Initial orbital radius (m)     r_final (float): Final orbital radius (m)  Returns:     str: Work done in Joules as a string in scientific notation (3 decimals)  Examples:     >>> orbital_transfer_work(5.972e24, 1000, 6.371e6, 7e6)     '2.811e+09'     >>> orbital_transfer_work(5.972e24, 500, 7e6, 6.371e6)     '-1.405e+09'     >>> orbital_transfer_work(1.989e30, 1000, 1.5e11, 2.28e11)     '1.514e+11'","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\period_of_pendulum.py","","period_of_pendulum",">>> period_of_pendulum(1.23) 2.2252155506257845 >>> period_of_pendulum(2.37) 3.0888278441908574 >>> period_of_pendulum(5.63) 4.76073193364765 >>> period_of_pendulum(-12) Traceback (most recent call last):     ... ValueError: The length should be non-negative >>> period_of_pendulum(0) 0.0","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\photoelectric_effect.py","","maximum_kinetic_energy","Calculates the maximum kinetic energy of emitted electron from the surface. if the maximum kinetic energy is zero then no electron will be emitted or given electromagnetic wave frequency is small.  frequency (float): Frequency of electromagnetic wave. work_function (float): Work function of the surface. in_ev (optional)(bool): Pass True if values are in eV.  Usage example: >>> maximum_kinetic_energy(1000000,2) 0 >>> maximum_kinetic_energy(1000000,2,True) 0 >>> maximum_kinetic_energy(10000000000000000,2,True) 39.357000000000006 >>> maximum_kinetic_energy(-9,20) Traceback (most recent call last):     ... ValueError: Frequency can't be negative.  >>> maximum_kinetic_energy(1000,""a"") Traceback (most recent call last):     ... TypeError: unsupported operand type(s) for -: 'float' and 'str'","max, ValueError, max"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\potential_energy.py","","potential_energy",">>> potential_energy(10,10) 980.665 >>> potential_energy(0,5) 0.0 >>> potential_energy(8,0) 0.0 >>> potential_energy(10,5) 490.3325 >>> potential_energy(0,0) 0.0 >>> potential_energy(2,8) 156.9064 >>> potential_energy(20,100) 19613.3","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\rainfall_intensity.py","","rainfall_intensity","Calculate the intensity of a rainfall event for a given duration and return period. It's based on the Sherman intensity-duration-frequency curve:  I = k * T^a / (D + b)^c  where:     I = Intensity of the rainfall event [mm/h]     k, a, b, c = Coefficients obtained through statistical distribution adjust     T = Return period in years     D = Rainfall event duration in minutes  Parameters ---------- coefficient_k : float     Coefficient obtained through statistical distribution adjust. coefficient_a : float     Coefficient obtained through statistical distribution adjust. coefficient_b : float     Coefficient obtained through statistical distribution adjust. coefficient_c : float     Coefficient obtained through statistical distribution adjust. return_period : float     Return period in years. duration : float     Rainfall event duration in minutes.  Returns ------- intensity : float     Intensity of the rainfall event in mm/h.  Raises ------ ValueError     If any of the parameters are not positive.  Examples --------  >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 60) 49.83339231138578  >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 30) 77.36319588106228  >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 5, 60) 43.382487747633625  >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, -0.2, 11.6, 0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0.2, -11.6, 0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0.2, 11.6, -0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0, 11.6, 0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0.2, 0, 0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0.2, 11.6, 0, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 0, 60) Traceback (most recent call last): ... ValueError: All parameters must be positive.  >>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 0) Traceback (most recent call last): ... ValueError: All parameters must be positive.","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\reynolds_number.py","","reynolds_number",">>> reynolds_number(900, 2.5, 0.05, 0.4) 281.25 >>> reynolds_number(450, 3.86, 0.078, 0.23) 589.0695652173912 >>> reynolds_number(234, -4.5, 0.3, 0.44) 717.9545454545454 >>> reynolds_number(-90, 2, 0.045, 1) Traceback (most recent call last):     ... ValueError: please ensure that density, diameter and viscosity are positive >>> reynolds_number(0, 2, -0.4, -2) Traceback (most recent call last):     ... ValueError: please ensure that density, diameter and viscosity are positive","ValueError, abs"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\rms_speed_of_molecule.py","","rms_speed_of_molecule",">>> rms_speed_of_molecule(100, 2) 35.315279554323226 >>> rms_speed_of_molecule(273, 12) 23.821458421977443","Exception, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\shear_stress.py","","shear_stress","This function can calculate any one of the three - 1. Shear Stress 2. Tangential Force 3. Cross-sectional Area This is calculated from the other two provided values Examples - >>> shear_stress(stress=25, tangential_force=100, area=0) ('area', 4.0) >>> shear_stress(stress=0, tangential_force=1600, area=200) ('stress', 8.0) >>> shear_stress(stress=1000, tangential_force=0, area=1200) ('tangential_force', 1200000)",".count, ValueError, ValueError, ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\speeds_of_gas_molecules.py","","avg_speed_of_molecule","Takes the temperature (in K) and molar mass (in kg/mol) of a gas and returns the average speed of a molecule in the gas (in m/s).  Examples:  >>> avg_speed_of_molecule(273, 0.028) # nitrogen at 273 K 454.3488755062257 >>> avg_speed_of_molecule(300, 0.032) # oxygen at 300 K 445.5257273433045 >>> avg_speed_of_molecule(-273, 0.028) # invalid temperature Traceback (most recent call last):     ... Exception: Absolute temperature cannot be less than 0 K >>> avg_speed_of_molecule(273, 0) # invalid molar mass Traceback (most recent call last):     ... Exception: Molar mass should be greater than 0 kg/mol","Exception, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\speeds_of_gas_molecules.py","","mps_speed_of_molecule","Takes the temperature (in K) and molar mass (in kg/mol) of a gas and returns the most probable speed of a molecule in the gas (in m/s).  Examples:  >>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K 402.65620702280023 >>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K 394.8368955535605 >>> mps_speed_of_molecule(-273, 0.028) # invalid temperature Traceback (most recent call last):     ... Exception: Absolute temperature cannot be less than 0 K >>> mps_speed_of_molecule(273, 0) # invalid molar mass Traceback (most recent call last):     ... Exception: Molar mass should be greater than 0 kg/mol","Exception, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\speed_of_sound.py","","speed_of_sound_in_a_fluid","Calculates the speed of sound in a fluid from its density and bulk modulus  Examples: Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m  >>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998) 1467.7563207952705 >>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600) 1447.614670861731","ValueError, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\physics\terminal_velocity.py","","terminal_velocity",">>> terminal_velocity(1, 25, 0.6, 0.77) 1.3031197996044768 >>> terminal_velocity(2, 100, 0.45, 0.23) 1.9467947148674276 >>> terminal_velocity(5, 50, 0.2, 0.5) 4.428690551393267 >>> terminal_velocity(-5, 50, -0.2, -2) Traceback (most recent call last):     ... ValueError: mass, density, area and the drag coefficient all need to be positive >>> terminal_velocity(3, -20, -1, 2) Traceback (most recent call last):     ... ValueError: mass, density, area and the drag coefficient all need to be positive >>> terminal_velocity(-2, -1, -0.44, -1) Traceback (most recent call last):     ... ValueError: mass, density, area and the drag coefficient all need to be positive","ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol1.py","","solution","Returns the sum of all the multiples of 3 or 5 below n.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700 >>> solution(-7) 0","sum, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol2.py","","solution","Returns the sum of all the multiples of 3 or 5 below n.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol3.py","","solution","This solution is based on the pattern that the successive numbers in the series follow: 0+3,+2,+1,+3,+1,+2,+3. Returns the sum of all the multiples of 3 or 5 below n.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol4.py","","solution","Returns the sum of all the multiples of 3 or 5 below n.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700","list, sum, set, zmulti.append, xmulti.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol5.py","","solution","Returns the sum of all the multiples of 3 or 5 below n. A straightforward pythonic solution using list comprehension.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700","sum, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol6.py","","solution","Returns the sum of all the multiples of 3 or 5 below n.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_001\sol7.py","","solution","Returns the sum of all the multiples of 3 or 5 below n.  >>> solution(3) 0 >>> solution(4) 3 >>> solution(10) 23 >>> solution(600) 83700","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_002\sol1.py","","solution","Returns the sum of all even fibonacci sequence elements that are lower or equal to n.  >>> solution(10) 10 >>> solution(15) 10 >>> solution(2) 2 >>> solution(1) 0 >>> solution(34) 44",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_002\sol2.py","","solution","Returns the sum of all even fibonacci sequence elements that are lower or equal to n.  >>> solution(10) 10 >>> solution(15) 10 >>> solution(2) 2 >>> solution(1) 0 >>> solution(34) 44","sum, even_fibs.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_002\sol3.py","","solution","Returns the sum of all even fibonacci sequence elements that are lower or equal to n.  >>> solution(10) 10 >>> solution(15) 10 >>> solution(2) 2 >>> solution(1) 0 >>> solution(34) 44",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_002\sol4.py","","solution","Returns the sum of all even fibonacci sequence elements that are lower or equal to n.  >>> solution(10) 10 >>> solution(15) 10 >>> solution(2) 2 >>> solution(1) 0 >>> solution(34) 44 >>> solution(3.4) 2 >>> solution(0) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution(-17) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution([]) Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int. >>> solution(""asd"") Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int.","int, int, ValueError, getcontext, Decimal, Decimal, TypeError, round, Decimal, Decimal, math.floor, Decimal, math.log"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_002\sol5.py","","solution","Returns the sum of all even fibonacci sequence elements that are lower or equal to n.  >>> solution(10) 10 >>> solution(15) 10 >>> solution(2) 2 >>> solution(1) 0 >>> solution(34) 44","range, fib.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_003\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_003\sol1.py","","solution","Returns the largest prime factor of a given number n.  >>> solution(13195) 29 >>> solution(10) 5 >>> solution(17) 17 >>> solution(3.4) 3 >>> solution(0) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution(-17) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution([]) Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int. >>> solution(""asd"") Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int.","is_prime, is_prime, range, int, ValueError, TypeError, int, is_prime, math.sqrt, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_003\sol2.py","","solution","Returns the largest prime factor of a given number n.  >>> solution(13195) 29 >>> solution(10) 5 >>> solution(17) 17 >>> solution(3.4) 3 >>> solution(0) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution(-17) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution([]) Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int. >>> solution(""asd"") Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int.","int, int, ValueError, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_003\sol3.py","","solution","Returns the largest prime factor of a given number n.  >>> solution(13195) 29 >>> solution(10) 5 >>> solution(17) 17 >>> solution(3.4) 3 >>> solution(0) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution(-17) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution([]) Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int. >>> solution(""asd"") Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int.","int, int, ValueError, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_004\sol1.py","","solution","Returns the largest palindrome made from the product of two 3-digit numbers which is less than n.  >>> solution(20000) 19591 >>> solution(30000) 29992 >>> solution(40000) 39893 >>> solution(10000) Traceback (most recent call last):     ... ValueError: That number is larger than our acceptable range.","range, ValueError, str, len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_004\sol2.py","","solution","Returns the largest palindrome made from the product of two 3-digit numbers which is less than n.  >>> solution(20000) 19591 >>> solution(30000) 29992 >>> solution(40000) 39893","range, range, str, max"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_005\sol1.py","","solution","Returns the smallest positive number that is evenly divisible (divisible with no remainder) by all of the numbers from 1 to n.  >>> solution(10) 2520 >>> solution(15) 360360 >>> solution(22) 232792560 >>> solution(3.4) 6 >>> solution(0) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution(-17) Traceback (most recent call last):     ... ValueError: Parameter n must be greater than or equal to one. >>> solution([]) Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int. >>> solution(""asd"") Traceback (most recent call last):     ... TypeError: Parameter n must be int or castable to int.","int, ValueError, range, TypeError"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_005\sol2.py","","lcm","Least Common Multiple.  Using the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b  >>> lcm(3, 15) 15 >>> lcm(1, 27) 27 >>> lcm(13, 27) 351 >>> lcm(64, 48) 192","greatest_common_divisor"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_005\sol2.py","","solution","Returns the smallest positive number that is evenly divisible (divisible with no remainder) by all of the numbers from 1 to n.  >>> solution(10) 2520 >>> solution(15) 360360 >>> solution(22) 232792560","range, lcm"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_006\sol1.py","","solution","Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.  >>> solution(10) 2640 >>> solution(15) 13160 >>> solution(20) 41230 >>> solution(50) 1582700","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_006\sol2.py","","solution","Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.  >>> solution(10) 2640 >>> solution(15) 13160 >>> solution(20) 41230 >>> solution(50) 1582700",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_006\sol3.py","","solution","Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.  >>> solution(10) 2640 >>> solution(15) 13160 >>> solution(20) 41230 >>> solution(50) 1582700","sum, int, math.pow, sum, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_006\sol4.py","","solution","Returns the difference between the sum of the squares of the first n natural numbers and the square of the sum.  >>> solution(10) 2640 >>> solution(15) 13160 >>> solution(20) 41230 >>> solution(50) 1582700","int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False","range, int, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol1.py","","solution","Returns the n-th prime number.  >>> solution(6) 13 >>> solution(1) 2 >>> solution(3) 5 >>> solution(20) 71 >>> solution(50) 229 >>> solution(100) 541","is_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol2.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol2.py","","solution","Returns the n-th prime number.  >>> solution(6) 13 >>> solution(1) 2 >>> solution(3) 5 >>> solution(20) 71 >>> solution(50) 229 >>> solution(100) 541 >>> solution(3.4) 5 >>> solution(0) Traceback (most recent call last):     ... ValueError: Parameter nth must be greater than or equal to one. >>> solution(-17) Traceback (most recent call last):     ... ValueError: Parameter nth must be greater than or equal to one. >>> solution([]) Traceback (most recent call last):     ... TypeError: Parameter nth must be int or castable to int. >>> solution(""asd"") Traceback (most recent call last):     ... TypeError: Parameter nth must be int or castable to int.","int, ValueError, len, is_prime, TypeError, primes.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol3.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol3.py","","prime_generator","Generate a sequence of prime numbers","is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_007\sol3.py","","solution","Returns the n-th prime number.  >>> solution(6) 13 >>> solution(1) 2 >>> solution(3) 5 >>> solution(20) 71 >>> solution(50) 229 >>> solution(100) 541","next, itertools.islice, prime_generator"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_008\sol1.py","","solution","Find the thirteen adjacent digits in the 1000-digit number n that have the greatest product and returns it.  >>> solution(""13978431290823798458352374"") 609638400 >>> solution(""13978431295823798458352374"") 2612736000 >>> solution(""1397843129582379841238352374"") 209018880","range, range, max, len, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_008\sol2.py","","solution","Find the thirteen adjacent digits in the 1000-digit number n that have the greatest product and returns it.  >>> solution(""13978431290823798458352374"") 609638400 >>> solution(""13978431295823798458352374"") 2612736000 >>> solution(""1397843129582379841238352374"") 209018880","max, int, reduce, range, str, len, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_008\sol3.py","","str_eval","Returns product of digits in given string n  >>> str_eval(""987654321"") 362880 >>> str_eval(""22222222"") 256","int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_008\sol3.py","","solution","Find the thirteen adjacent digits in the 1000-digit number n that have the greatest product and returns it.","len, int, int, max, str_eval"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol1.py","","solution","Returns the product of a,b,c which are Pythagorean Triplet that satisfies the following:   1. a < b < c   2. a**2 + b**2 = c**2   3. a + b + c = 1000  >>> solution() 31875000","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol1.py","","solution_fast","Returns the product of a,b,c which are Pythagorean Triplet that satisfies the following:   1. a < b < c   2. a**2 + b**2 = c**2   3. a + b + c = 1000  >>> solution_fast() 31875000","range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol1.py","","benchmark","Benchmark code comparing two different version function.","print, print, timeit.timeit, timeit.timeit"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol2.py","","solution","Return the product of a,b,c which are Pythagorean Triplet that satisfies the following:   1. a < b < c   2. a**2 + b**2 = c**2   3. a + b + c = n  >>> solution(36) 1620 >>> solution(126) 66780","range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol3.py","","solution","Returns the product of a,b,c which are Pythagorean Triplet that satisfies the following:   1. a**2 + b**2 = c**2   2. a + b + c = 1000  >>> solution() 31875000","next, iter, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol4.py","","get_squares",">>> get_squares(0) [] >>> get_squares(1) [0] >>> get_squares(2) [0, 1] >>> get_squares(3) [0, 1, 4] >>> get_squares(4) [0, 1, 4, 9]","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_009\sol4.py","","solution","Precomputing squares and checking if a^2 + b^2 is the square by set look-up.  >>> solution(12) 60 >>> solution(36) 1620","get_squares, set, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_010\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number num (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_010\sol1.py","","solution","Returns the sum of all the primes below n.  >>> solution(1000) 76127 >>> solution(5000) 1548136 >>> solution(10000) 5736396 >>> solution(7) 10","sum, range, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_010\sol2.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number num (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_010\sol2.py","","prime_generator","Generate a list sequence of prime numbers","is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_010\sol2.py","","solution","Returns the sum of all the primes below n.  >>> solution(1000) 76127 >>> solution(5000) 1548136 >>> solution(10000) 5736396 >>> solution(7) 10","sum, takewhile, prime_generator"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_010\sol3.py","","solution","Returns the sum of all the primes below n using Sieve of Eratosthenes:  The sieve of Eratosthenes is one of the most efficient ways to find all primes smaller than n when n is smaller than 10 million.  Only for positive numbers.  >>> solution(1000) 76127 >>> solution(5000) 1548136 >>> solution(10000) 5736396 >>> solution(7) 10 >>> solution(7.1)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: 'float' object cannot be interpreted as an integer >>> solution(-7)  # doctest: +ELLIPSIS Traceback (most recent call last):     ... IndexError: list assignment index out of range >>> solution(""seven"")  # doctest: +ELLIPSIS Traceback (most recent call last):     ... TypeError: can only concatenate str (not ""int"") to str","range, range, range, int, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_011\sol1.py","","largest_product","","len, len, range, range, max, max"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_011\sol1.py","","solution","Returns the greatest product of four adjacent numbers (horizontally, vertically, or diagonally).  >>> solution() 70600674","largest_product, open, grid.append, int, range, os.path.dirname, .split, len, line.strip"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_011\sol2.py","","solution","Returns the greatest product of four adjacent numbers (horizontally, vertically, or diagonally).  >>> solution() 70600674","open, range, range, range, range, range, grid.append, range, range, range, range, os.path.dirname, max, max, max, max, int, .split, f.readline"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_012\sol1.py","","count_divisors","",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_012\sol1.py","","solution","Returns the value of the first triangle number to have over five hundred divisors.  >>> solution() 76576500","count_divisors"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_012\sol2.py","","triangle_number_generator","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_012\sol2.py","","count_divisors","",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_012\sol2.py","","solution","Returns the value of the first triangle number to have over five hundred divisors.  >>> solution() 76576500","next, triangle_number_generator, count_divisors"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_013\sol1.py","","solution","Returns the first ten digits of the sum of the array elements from the file num.txt  >>> solution() '5537376230'","os.path.join, os.path.dirname, open, str, sum, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_014\sol1.py","","solution","Returns the number under n that generates the longest sequence using the formula: n  n/2 (n is even) n  3n + 1 (n is odd)  >>> solution(1000000) 837799 >>> solution(200) 171 >>> solution(5000) 3711 >>> solution(15000) 13255","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_014\sol2.py","","collatz_sequence_length","Returns the Collatz sequence length for n.","collatz_sequence_length"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_014\sol2.py","","solution","Returns the number under n that generates the longest Collatz sequence.  >>> solution(1000000) 837799 >>> solution(200) 171 >>> solution(5000) 3711 >>> solution(15000) 13255","max, collatz_sequence_length, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_015\sol1.py","","solution","Returns the number of paths possible in a n x n grid starting at top left corner going to bottom right corner and being able to move right and down only. >>> solution(25) 126410606437752 >>> solution(23) 8233430727600 >>> solution(20) 137846528820 >>> solution(15) 155117520 >>> solution(1) 2","int, factorial, factorial, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_016\sol1.py","","solution","Returns the sum of the digits of the number 2^power. >>> solution(1000) 1366 >>> solution(50) 76 >>> solution(20) 31 >>> solution(15) 26","str, list, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_016\sol2.py","","solution","Returns the sum of the digits of the number 2^power.  >>> solution(1000) 1366 >>> solution(50) 76 >>> solution(20) 31 >>> solution(15) 26",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_017\sol1.py","","solution","Returns the number of letters used to write all numbers from 1 to n. where n is lower or equals to 1000. >>> solution(1000) 21124 >>> solution(5) 19","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_018\solution.py","","solution","Finds the maximum total in a triangle as described by the problem statement above.  >>> solution() 1074","os.path.dirname, os.path.join, range, max, os.path.realpath, open, f.readlines, len, range, int, len, max, .split, len, x.rstrip"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_019\sol1.py","","solution","Returns the number of mondays that fall on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?  >>> solution() 171",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_020\sol1.py","","factorial","Find the factorial of a given number n","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_020\sol1.py","","split_and_add","Split number digits and add them.",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_020\sol1.py","","solution","Returns the sum of the digits in the factorial of num >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(2) 2 >>> solution(1) 1","factorial, split_and_add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_020\sol2.py","","solution","Returns the sum of the digits in the factorial of num >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(2) 2 >>> solution(1) 1","sum, int, str, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_020\sol3.py","","solution","Returns the sum of the digits in the factorial of num >>> solution(1000) 10539 >>> solution(200) 1404 >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(2) 2 >>> solution(1) 1 >>> solution(0) 1","sum, map, str, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_020\sol4.py","","solution","Returns the sum of the digits in the factorial of num >>> solution(100) 648 >>> solution(50) 216 >>> solution(10) 27 >>> solution(5) 3 >>> solution(3) 6 >>> solution(2) 2 >>> solution(1) 1","range, str, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_021\sol1.py","","sum_of_divisors","","range, int, sqrt, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_021\sol1.py","","solution","Returns the sum of all the amicable numbers under n.  >>> solution(10000) 31626 >>> solution(5000) 8442 >>> solution(1000) 504 >>> solution(100) 0 >>> solution(50) 0","sum, range, sum_of_divisors, sum_of_divisors, sum_of_divisors"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_022\sol1.py","","solution","Returns the total of all the name scores in the file.  >>> solution() 871198282","names.sort, enumerate, open, str, .split, os.path.dirname, file.readlines, names.replace, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_022\sol2.py","","solution","Returns the total of all the name scores in the file.  >>> solution() 871198282","name.sort, range, open, str, .split, len, os.path.dirname, file.readlines, name.replace, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_023\sol1.py","","solution","Finds the sum of all the positive integers which cannot be written as the sum of two abundant numbers as described by the statement above.  >>> solution() 4179871","range, set, range, range, int, abundants.add, any"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_024\sol1.py","","solution","Returns the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.  >>> solution() '2783915460'","list, map, permutations"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_025\sol1.py","","fibonacci","Computes the Fibonacci number for input n by iterating through n numbers and creating an array of ints using the Fibonacci formula. Returns the nth element of the array.  >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(12) 144","isinstance, range, sequence.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_025\sol1.py","","fibonacci_digits_index","Computes incrementing Fibonacci numbers starting from 3 until the length of the resulting Fibonacci result is the input value n. Returns the term of the Fibonacci sequence where this occurs.  >>> fibonacci_digits_index(1000) 4782 >>> fibonacci_digits_index(100) 476 >>> fibonacci_digits_index(50) 237 >>> fibonacci_digits_index(3) 12","len, str, fibonacci"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_025\sol1.py","","solution","Returns the index of the first term in the Fibonacci sequence to contain n digits.  >>> solution(1000) 4782 >>> solution(100) 476 >>> solution(50) 237 >>> solution(3) 12","fibonacci_digits_index"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_025\sol2.py","","fibonacci_generator","A generator that produces numbers in the Fibonacci sequence  >>> generator = fibonacci_generator() >>> next(generator) 1 >>> next(generator) 2 >>> next(generator) 3 >>> next(generator) 5 >>> next(generator) 8",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_025\sol2.py","","solution","Returns the index of the first term in the Fibonacci sequence to contain n digits.  >>> solution(1000) 4782 >>> solution(100) 476 >>> solution(50) 237 >>> solution(3) 12","fibonacci_generator, len, str, next"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_025\sol3.py","","solution","Returns the index of the first term in the Fibonacci sequence to contain n digits.  >>> solution(1000) 4782 >>> solution(100) 476 >>> solution(50) 237 >>> solution(3) 12","str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_026\sol1.py","","solution","Considering any range can be provided, because as per the problem, the digit d < 1000 >>> solution(1, 10) 7 >>> solution(10, 100) 97 >>> solution(10, 1000) 983","range, range, has_been_divided.append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_027\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)). A number is prime if it has exactly two factors: 1 and itself. Returns boolean representing primality of given number num (i.e., if the result is true, then the number is indeed prime else it is not).  >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(2999) True >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(-10) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_027\sol1.py","","solution",">>> solution(1000, 1000) -59231 >>> solution(200, 1000) -59231 >>> solution(200, 200) -4925 >>> solution(-1000, 1000) 0 >>> solution(-1000, -1000) 0","range, range, is_prime, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_028\sol1.py","","solution","Returns the sum of the numbers on the diagonals in a n by n spiral formed in the same way.  >>> solution(1001) 669171001 >>> solution(500) 82959497 >>> solution(100) 651897 >>> solution(50) 79697 >>> solution(10) 537","range, ceil"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_029\sol1.py","","solution","Returns the number of distinct terms in the sequence generated by a^b for 2 <= a <= 100 and 2 <= b <= 100.  >>> solution(100) 9183 >>> solution(50) 2184 >>> solution(20) 324 >>> solution(5) 15 >>> solution(2) 1 >>> solution(1) 0","set, range, len, range, collect_powers.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_030\sol1.py","","digits_fifth_powers_sum",">>> digits_fifth_powers_sum(1234) 1300","sum, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_030\sol1.py","","solution","","sum, range, digits_fifth_powers_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","one_pence","",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","two_pence","","two_pence, one_pence"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","five_pence","","five_pence, two_pence"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","ten_pence","","ten_pence, five_pence"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","twenty_pence","","twenty_pence, ten_pence"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","fifty_pence","","fifty_pence, twenty_pence"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","one_pound","","one_pound, fifty_pence"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","two_pound","","two_pound, one_pound"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol1.py","","solution","Returns the number of different ways can n pence be made using any number of coins?  >>> solution(500) 6295434 >>> solution(200) 73682 >>> solution(50) 451 >>> solution(10) 11","two_pound"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_031\sol2.py","","solution","Returns the number of different ways to make X pence using any number of coins. The solution is based on dynamic programming paradigm in a bottom-up fashion.  >>> solution(500) 6295434 >>> solution(200) 73682 >>> solution(50) 451 >>> solution(10) 11","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_032\sol32.py","","is_combination_valid","Checks if a combination (a tuple of 9 digits) is a valid product equation.  >>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4')) True  >>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9')) False","int, int, int, int, .join, int, int, .join, .join, .join, .join, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_032\sol32.py","","solution","Finds the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital  >>> solution() 45228","sum, int, .join, itertools.permutations, is_combination_valid"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_033\sol1.py","","is_digit_cancelling","",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_033\sol1.py","","fraction_list",">>> fraction_list(2) ['16/64', '19/95', '26/65', '49/98'] >>> fraction_list(3) ['16/64', '19/95', '26/65', '49/98'] >>> fraction_list(4) ['16/64', '19/95', '26/65', '49/98'] >>> fraction_list(0) [] >>> fraction_list(5) ['16/64', '19/95', '26/65', '49/98']","int, range, is_digit_cancelling, solutions.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_033\sol1.py","","solution","Return the solution to the problem","fraction_list, int, Fraction"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_034\sol1.py","","sum_of_digit_factorial","Returns the sum of the factorial of digits in n >>> sum_of_digit_factorial(15) 121 >>> sum_of_digit_factorial(0) 1","sum, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_034\sol1.py","","solution","Returns the sum of all numbers whose sum of the factorials of all digits add up to the number itself. >>> solution() 40730","sum, factorial, range, sum_of_digit_factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_035\sol1.py","","is_prime","For 2 <= n <= 1000000, return True if n is prime. >>> is_prime(87) False >>> is_prime(23) True >>> is_prime(25363) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_035\sol1.py","","contains_an_even_digit","Return True if n contains an even digit. >>> contains_an_even_digit(0) True >>> contains_an_even_digit(975317933) False >>> contains_an_even_digit(-245679) True","any, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_035\sol1.py","","find_circular_primes","Return circular primes below limit. >>> len(find_circular_primes(100)) 13 >>> len(find_circular_primes(1000000)) 55","range, is_prime, str, all, contains_an_even_digit, int, result.append, range, is_prime, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_035\sol1.py","","solution",">>> solution() 55","len, find_circular_primes"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_036\sol1.py","","is_palindrome","Return true if the input n is a palindrome. Otherwise return false. n can be an integer or a string.  >>> is_palindrome(909) True >>> is_palindrome(908) False >>> is_palindrome('10101') True >>> is_palindrome('10111') False","str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_036\sol1.py","","solution","Return the sum of all numbers, less than n , which are palindromic in base 10 and base 2.  >>> solution(1000000) 872187 >>> solution(500000) 286602 >>> solution(100000) 286602 >>> solution(1000) 1772 >>> solution(100) 157 >>> solution(10) 25 >>> solution(2) 1 >>> solution(1) 0","range, is_palindrome, is_palindrome, .split, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_037\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_037\sol1.py","","list_truncated_nums","Returns a list of all left and right truncated numbers of n >>> list_truncated_nums(927628) [927628, 27628, 92762, 7628, 9276, 628, 927, 28, 92, 8, 9] >>> list_truncated_nums(467) [467, 67, 46, 7, 4] >>> list_truncated_nums(58) [58, 8, 5]","str, range, len, list_nums.append, list_nums.append, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_037\sol1.py","","validate","To optimize the approach, we will rule out the numbers above 1000, whose first or last three digits are not prime >>> validate(74679) False >>> validate(235693) False >>> validate(3797) True","len, str, is_prime, is_prime, int, int, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_037\sol1.py","","compute_truncated_primes","Returns the list of truncated primes >>> compute_truncated_primes(11) [23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397]","len, validate, list_truncated_nums, all, list_truncated_primes.append, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_037\sol1.py","","solution","Returns the sum of truncated primes","sum, compute_truncated_primes"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_038\sol1.py","","is_9_pandigital","Checks whether n is a 9-digit 1 to 9 pandigital number. >>> is_9_pandigital(12345) False >>> is_9_pandigital(156284973) True >>> is_9_pandigital(1562849733) False","str, len, set, set"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_038\sol1.py","","solution","Return the largest 1 to 9 pandigital 9-digital number that can be formed as the concatenated product of an integer with (1,2,...,n) where n > 1.","range, range, is_9_pandigital, is_9_pandigital"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_039\sol1.py","","pythagorean_triple","Returns a dictionary with keys as the perimeter of a right angled triangle and value as the number of corresponding triplets. >>> pythagorean_triple(15) Counter({12: 1}) >>> pythagorean_triple(40) Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1}) >>> pythagorean_triple(50) Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})","Counter, range, range, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_039\sol1.py","","solution","Returns perimeter with maximum solutions. >>> solution(100) 90 >>> solution(200) 180 >>> solution(1000) 840","pythagorean_triple, triplets.most_common"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_040\sol1.py","","solution","Returns  >>> solution() 210",".join, len, constant.append, int, str, int, int, int, int, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_041\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_041\sol1.py","","solution","Returns the maximum pandigital prime number of length n. If there are none, then it will return 0. >>> solution(2) 0 >>> solution(4) 4231 >>> solution(7) 7652413",".join, int, max, str, .join, permutations, is_prime, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_042\solution42.py","","solution","Finds the amount of triangular words in the words file.  >>> solution() 162","os.path.dirname, os.path.join, len, os.path.realpath, open, f.readline, word.strip, .split, sum, words.strip, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_043\sol1.py","","is_substring_divisible","Returns True if the pandigital number passes all the divisibility tests. >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9)) False >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9)) False >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9)) True","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_043\sol1.py","","solution","Returns the sum of all pandigital numbers which pass the divisibility tests. >>> solution(10) 16695334890","sum, int, .join, permutations, is_substring_divisible, map, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_044\sol1.py","","is_pentagonal","Returns True if n is pentagonal, False otherwise. >>> is_pentagonal(330) True >>> is_pentagonal(7683) False >>> is_pentagonal(2380) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_044\sol1.py","","solution","Returns the minimum difference of two pentagonal numbers P1 and P2 such that P1 + P2 is pentagonal and P2 - P1 is pentagonal. >>> solution(5000) 5482660","enumerate, range, range, len, is_pentagonal, is_pentagonal"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_045\sol1.py","","hexagonal_num","Returns nth hexagonal number >>> hexagonal_num(143) 40755 >>> hexagonal_num(21) 861 >>> hexagonal_num(10) 190",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_045\sol1.py","","is_pentagonal","Returns True if n is pentagonal, False otherwise. >>> is_pentagonal(330) True >>> is_pentagonal(7683) False >>> is_pentagonal(2380) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_045\sol1.py","","solution","Returns the next number which is triangular, pentagonal and hexagonal. >>> solution(144) 1533776805","hexagonal_num, is_pentagonal, hexagonal_num"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_046\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_046\sol1.py","","compute_nums","Returns a list of first n odd composite numbers which do not follow the conjecture. >>> compute_nums(1) [5777] >>> compute_nums(2) [5777, 5993] >>> compute_nums(0) Traceback (most recent call last):     ... ValueError: n must be >= 0 >>> compute_nums(""a"") Traceback (most recent call last):     ... ValueError: n must be an integer >>> compute_nums(1.1) Traceback (most recent call last):     ... ValueError: n must be an integer","range, isinstance, ValueError, ValueError, len, is_prime, list_nums.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_046\sol1.py","","solution","Return the solution to the problem","compute_nums"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_047\sol1.py","","unique_prime_factors","Find unique prime factors of an integer. Tests include sorting because only the set matters, not the order in which it is produced. >>> sorted(set(unique_prime_factors(14))) [2, 7] >>> sorted(set(unique_prime_factors(644))) [2, 7, 23] >>> sorted(set(unique_prime_factors(646))) [2, 17, 19]","set, factors.add, factors.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_047\sol1.py","","upf_len","Memoize upf() length results for a given value. >>> upf_len(14) 2","len, unique_prime_factors"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_047\sol1.py","","equality","Check the equality of ALL elements in an iterable >>> equality([1, 2, 3, 4]) False >>> equality([2, 2, 2, 2]) True >>> equality([1, 2, 3, 2, 1]) False","len, set"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_047\sol1.py","","run","Runs core process to find problem solution. >>> run(3) [644, 645, 646]","checker.append, equality, upf_len, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_047\sol1.py","","solution","Return the first value of the first four consecutive integers to have four distinct prime factors each. >>> solution() 134043","run, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_048\sol1.py","","solution","Returns the last 10 digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.  >>> solution() '9110846700'","range, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_049\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_049\sol1.py","","search","function to search a number in a list using Binary Search. >>> search(3, [1, 2, 3]) True >>> search(4, [1, 2, 3]) False >>> search(101, list(range(-100, 100))) False","len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_049\sol1.py","","solution","Return the solution of the problem. >>> solution() 296962999629","set, max, permutations, tmp_numbers.sort, len, range, answer.add, range, is_prime, list, int, search, len, candidates.append, range, .join, int, str, .join, tmp_numbers.append, range, str, passed.append, abs, abs, len, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_050\sol1.py","","prime_sieve","Sieve of Erotosthenes Function to return all the prime numbers up to a number 'limit' https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes  >>> prime_sieve(3) [2]  >>> prime_sieve(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","range, range, int, primes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_050\sol1.py","","solution","Returns the biggest prime, below the celing, that can be written as the sum of consecutive the most consecutive primes.  >>> solution(500) 499  >>> solution(1_000) 953  >>> solution(10_000) 9521","prime_sieve, range, len, range, len, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_051\sol1.py","","prime_sieve","Sieve of Erotosthenes Function to return all the prime numbers up to a certain number https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes  >>> prime_sieve(3) [2]  >>> prime_sieve(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","range, range, int, primes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_051\sol1.py","","digit_replacements","Returns all the possible families of digit replacements in a number which contains at least one repeating digit  >>> digit_replacements(544) [[500, 511, 522, 533, 544, 555, 566, 577, 588, 599]]  >>> digit_replacements(3112) [[3002, 3112, 3222, 3332, 3442, 3552, 3662, 3772, 3882, 3992]]","str, Counter, Counter, replacements.append, set, int, number_str.replace"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_051\sol1.py","","solution","Returns the solution of the problem  >>> solution(2) 229399  >>> solution(3) 221311","set, digit_replacements, set, numbers_checked.update, primes.intersection, min, prime_sieve, len, len, len, str, set, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_052\sol1.py","","solution","Returns the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.  >>> solution() 142857","sorted, sorted, sorted, sorted, sorted, sorted, str, str, str, str, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_053\sol1.py","","combinations","","factorial, factorial, factorial"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_053\sol1.py","","solution","Returns the number of values of nCr, for 1  n  100, are greater than one-million  >>> solution() 4075","range, range, combinations"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","PokerHand","","Create an object representing a Poker Hand based on an input of a string which represents the best 5-card combination from the player's hand and board cards.  Attributes: (read-only)     hand: a string representing the hand consisting of five cards  Methods:     compare_with(opponent): takes in player's hand (self) and         opponent's hand (opponent) and compares both hands according to         the rules of Texas Hold'em.         Returns one of 3 strings (Win, Loss, Tie) based on whether         player's hand is better than the opponent's hand.      hand_name(): Returns a string made up of two parts: hand name         and high card.  Supported operators:     Rich comparison operators: <, >, <=, >=, ==, !=  Supported built-in methods and functions:     list.sort(), sorted()",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","solution","","os.path.abspath, os.path.join, os.path.dirname, open, .strip, .strip, player.compare_with, PokerHand, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__init__","Initialize hand. Hand should of type str and should contain only five cards each separated by a space.  The cards should be of the following format: [card value][card suit]  The first character is the value of the card: 2, 3, 4, 5, 6, 7, 8, 9, T(en), J(ack), Q(ueen), K(ing), A(ce)  The second character represents the suit: S(pades), H(earts), D(iamonds), C(lubs)  For example: ""6S 4C KC AS TH""","self._internal_state, self._get_hand_type, isinstance, TypeError, len, ValueError, hand.split"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","hand","Returns the self hand",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","compare_with","Determines the outcome of comparing self hand with other hand. Returns the output as 'Win', 'Loss', 'Tie' according to the rules of Texas Hold'em.  Here are some examples: >>> player = PokerHand(""2H 3H 4H 5H 6H"")  # Stright flush >>> opponent = PokerHand(""KS AS TS QS JS"")  # Royal flush >>> player.compare_with(opponent) 'Loss'  >>> player = PokerHand(""2S AH 2H AS AC"")  # Full house >>> opponent = PokerHand(""2H 3H 5H 6H 7H"")  # Flush >>> player.compare_with(opponent) 'Win'  >>> player = PokerHand(""2S AH 4H 5S 6C"")  # High card >>> opponent = PokerHand(""AD 4C 5H 6H 2C"")  # High card >>> player.compare_with(opponent) 'Tie'","self._compare_cards"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","hand_name","Return the name of the hand in the following format: 'hand name, high card'  Here are some examples: >>> PokerHand(""KS AS TS QS JS"").hand_name() 'Royal flush'  >>> PokerHand(""2D 6D 3D 4D 5D"").hand_name() 'Straight flush, Six-high'  >>> PokerHand(""JC 6H JS JD JH"").hand_name() 'Four of a kind, Jacks'  >>> PokerHand(""3D 2H 3H 2C 2D"").hand_name() 'Full house, Twos over Threes'  >>> PokerHand(""2H 4D 3C AS 5S"").hand_name()  # Low ace 'Straight, Five-high'  Source: https://en.wikipedia.org/wiki/List_of_poker_hands",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_compare_cards","","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_get_hand_type","","self._is_flush, self._is_same_kind, self._is_five_high_straight, self._is_straight, self._is_five_high_straight, self._is_straight, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_is_flush","","len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_is_five_high_straight","","sorted, self._card_values.pop, self._card_values.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_is_straight","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_is_same_kind","","range, max, min, self._card_values.count"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","_internal_state","",".split, int, sorted, self._hand.translate, str.maketrans"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__eq__","","isinstance, self.compare_with"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__lt__","","isinstance, self.compare_with"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__le__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__gt__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__ge__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\sol1.py","","__hash__","","object.__hash__"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","generate_random_hand","","randrange, randrange, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","generate_random_hands","","generate_random_hand, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_hand_is_flush","","pytest.mark.parametrize, ._is_flush, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_hand_is_straight","","pytest.mark.parametrize, ._is_straight, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_hand_is_five_high_straight","","pytest.mark.parametrize, PokerHand, player._is_five_high_straight"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_hand_is_same_kind","","pytest.mark.parametrize, ._is_same_kind, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_hand_values","","pytest.mark.parametrize, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_compare_simple","","pytest.mark.parametrize, .compare_with, PokerHand, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_compare_random","","pytest.mark.parametrize, generate_random_hands, .compare_with, PokerHand, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_hand_sorted","","poker_hands.copy, shuffle, chain, enumerate, PokerHand, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_custom_sort_five_high_straight","","pokerhands.sort, PokerHand, PokerHand, .__str__"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_multiple_calls_five_high_straight","","PokerHand, range, pokerhand._is_five_high_straight"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_054\test_poker_hand.py","","test_euler_project","","os.path.abspath, os.path.join, os.path.dirname, open, .strip, .strip, player.compare_with, PokerHand, PokerHand"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_055\sol1.py","","is_palindrome","Returns True if a number is palindrome. >>> is_palindrome(12567321) False >>> is_palindrome(1221) True >>> is_palindrome(9876789) True","str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_055\sol1.py","","sum_reverse","Returns the sum of n and reverse of n. >>> sum_reverse(123) 444 >>> sum_reverse(3478) 12221 >>> sum_reverse(12) 33","int, int, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_055\sol1.py","","solution","Returns the count of all lychrel numbers below limit. >>> solution(10000) 249 >>> solution(5000) 76 >>> solution(1000) 13","range, len, sum_reverse, is_palindrome, lychrel_nums.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_056\sol1.py","","solution","Considering natural numbers of the form, a**b, where a, b < 100, what is the maximum digital sum? :param a: :param b: :return: >>> solution(10,10) 45  >>> solution(100,100) 972  >>> solution(100,200) 1872","max, sum, range, range, int, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_057\sol1.py","","solution","returns number of fractions containing a numerator with more digits than the denominator in the first n expansions. >>> solution(14) 2 >>> solution(100) 15 >>> solution(10000) 1508","range, len, len, len, result.append, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_058\sol1.py","","is_prime","Checks to see if a number is a prime in O(sqrt(n)).  A number is prime if it has exactly two factors: 1 and itself.  >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(27) False >>> is_prime(87) False >>> is_prime(563) True >>> is_prime(2999) True >>> is_prime(67483) False","range, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_058\sol1.py","","solution","Returns the side length of the square spiral of odd length greater than 1 for which the ratio of primes along both diagonals first falls below the given ratio. >>> solution(.5) 11 >>> solution(.2) 309 >>> solution(.111) 11317","range, is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_059\sol1.py","","try_key","Given an encrypted message and a possible 3-character key, decrypt the message. If the decrypted message contains a invalid character, i.e. not an ASCII letter, a digit, punctuation or whitespace, then we know the key is incorrect, so return None. >>> try_key([0, 17, 20, 4, 27], (104, 116, 120)) 'hello' >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None True","zip, cycle, chr"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_059\sol1.py","","filter_valid_chars","Given an encrypted message, test all 3-character strings to try and find the key. Return a list of the possible decrypted messages. >>> from itertools import cycle >>> text = ""The enemy's gate is down"" >>> key = ""end"" >>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)] >>> text in filter_valid_chars(encoded) True","product, try_key, possibles.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_059\sol1.py","","filter_common_word","Given a list of possible decoded messages, narrow down the possibilities for checking for the presence of a specified common word. Only decoded messages containing common_word will be returned. >>> filter_common_word(['asfla adf', 'I am here', '   !?! #a'], 'am') ['I am here'] >>> filter_common_word(['athla amf', 'I am here', '   !?! #a'], 'am') ['athla amf', 'I am here']","possible.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_059\sol1.py","","solution","Test the ciphertext against all possible 3-character keys, then narrow down the possibilities by filtering using common words until there's only one possible decoded message. >>> solution(""test_cipher.txt"") 3000",".read_text, filter_valid_chars, sum, int, filter_common_word, .parent.joinpath, .split, len, ord, data.strip, Path"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_062\sol1.py","","solution","Iterate through every possible cube and sort the cube's digits in ascending order. Sorting maintains an ordering of the digits that allows you to compare permutations. Store each sorted sequence of digits in a dictionary, whose key is the sequence of digits and value is a list of numbers that are the base of the cube.  Once you find 5 numbers that produce the same sequence of digits, return the smallest one, which is at index 0 since we insert each base number in ascending order.  >>> solution(2) 125 >>> solution(3) 41063625","defaultdict, get_digits, .append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_062\sol1.py","","get_digits","Computes the sorted sequence of digits of the cube of num.  >>> get_digits(3) '27' >>> get_digits(99) '027999' >>> get_digits(123) '0166788'",".join, sorted, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_063\sol1.py","","solution","Returns the count of all n-digit numbers which are nth power >>> solution(10, 22) 49 >>> solution(0, 0) 0 >>> solution(1, 1) 0 >>> solution(-1, -1) 0","range, range, sum, len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_064\sol1.py","","continuous_fraction_period","Returns the continued fraction period of a number n.  >>> continuous_fraction_period(2) 1 >>> continuous_fraction_period(5) 1 >>> continuous_fraction_period(7) 4 >>> continuous_fraction_period(11) 2 >>> continuous_fraction_period(13) 5","int, sqrt, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_064\sol1.py","","solution","Returns the count of numbers <= 10000 with odd periods. This function calls continuous_fraction_period for numbers which are not perfect squares. This is checked in if sr - floor(sr) != 0 statement. If an odd period is returned by continuous_fraction_period, count_odd_periods is increased by 1.  >>> solution(2) 1 >>> solution(5) 2 >>> solution(7) 2 >>> solution(11) 3 >>> solution(13) 4","range, sqrt, floor, continuous_fraction_period"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_065\sol1.py","","sum_digits","Returns the sum of every digit in num.  >>> sum_digits(1) 1 >>> sum_digits(12345) 15 >>> sum_digits(999001) 28",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_065\sol1.py","","solution","Returns the sum of the digits in the numerator of the max-th convergent of the continued fraction for e.  >>> solution(9) 13 >>> solution(10) 17 >>> solution(50) 91","range, sum_digits"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_067\sol1.py","","solution","Finds the maximum total in a triangle as described by the problem statement above.  >>> solution() 7273","os.path.dirname, os.path.join, range, max, os.path.realpath, open, f.readlines, .split, a.append, len, range, numbers_from_line.append, len, max, line.strip, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_067\sol2.py","","solution","Finds the maximum total in a triangle as described by the problem statement above. >>> solution() 7273","os.path.dirname, os.path.join, os.path.realpath, open, len, triangle.pop, range, max, int, len, line.split"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_068\sol1.py","","solution","Find the maximum number for a ""magic"" gon_side-gon ring  The gon_side parameter should be in the range [3, 5], other side numbers aren't tested  >>> solution(3) 432621513 >>> solution(4) 426561813732 >>> solution() 6531031914842725 >>> solution(6) Traceback (most recent call last): ValueError: gon_side must be in the range [3, 5]","list, list, permutations, ValueError, ValueError, range, range, generate_gon_ring, is_magic_gon, list, int, .join, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_068\sol1.py","","generate_gon_ring","Generate a gon_side-gon ring from a permutation state The permutation state is the ring, but every duplicate is removed  >>> generate_gon_ring(3, [4, 2, 3, 5, 1, 6]) [4, 2, 3, 5, 3, 1, 6, 1, 2] >>> generate_gon_ring(5, [6, 5, 4, 3, 2, 1, 7, 8, 9, 10]) [6, 5, 4, 3, 4, 2, 1, 2, 7, 8, 7, 9, 10, 9, 5]","perm.append, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_068\sol1.py","","is_magic_gon","Check if the solution set is a magic n-gon ring Check that the first number is the smallest number on the outer ring Take a list, and check if the sum of each 3 numbers chunk is equal to the same total  >>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2]) True >>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3]) True >>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3]) True >>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9]) False >>> is_magic_gon([1]) Traceback (most recent call last): ValueError: a gon ring should have a length that is a multiple of 3","sum, all, ValueError, min, len, sum, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_069\sol1.py","","solution","Returns solution to problem. Algorithm: 1. Precompute (k) for all natural k, k <= n using product formula (wikilink below) https://en.wikipedia.org/wiki/Euler%27s_totient_function#Euler's_product_formula  2. Find k/(k) for all k  n and return the k that attains maximum  >>> solution(10) 6  >>> solution(100) 30  >>> solution(9973) 2310","list, range, range, ValueError, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_070\sol1.py","","get_totients","Calculates a list of totients from 0 to max_one exclusive, using the definition of Euler's product formula.  >>> get_totients(5) [0, 1, 1, 2, 2]  >>> get_totients(10) [0, 1, 1, 2, 2, 4, 2, 6, 4, 6]","np.arange, range, totients.tolist, np.arange"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_070\sol1.py","","has_same_digits","Return True if num1 and num2 have the same frequency of every digit, False otherwise.  >>> has_same_digits(123456789, 987654321) True  >>> has_same_digits(123, 23) False  >>> has_same_digits(1234566, 123456) False","sorted, sorted, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_070\sol1.py","","solution","Finds the value of n from 1 to max such that n/(n) produces a minimum.  >>> solution(100) 21  >>> solution(10000) 4435","get_totients, range, has_same_digits"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_071\sol1.py","","solution","Returns the closest numerator of the fraction immediately to the left of given fraction (numerator/denominator) from a list of reduced proper fractions. >>> solution() 428570 >>> solution(3, 7, 8) 2 >>> solution(6, 7, 60) 47","range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_072\sol1.py","","solution","Returns an integer, the solution to the problem >>> solution(10) 31 >>> solution(100) 3043 >>> solution(1_000) 304191","np.arange, range, int, np.sum, np.arange"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_072\sol2.py","","solution","Return the number of reduced proper fractions with denominator less than limit. >>> solution(8) 21 >>> solution(1000) 304191","set, primes.add, range, int, range, primes.difference_update, float, range, sum, set, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_073\sol1.py","","solution","Returns number of fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d  max_d  >>> solution(4) 0  >>> solution(5) 1  >>> solution(8) 3","range, range, gcd"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_074\sol1.py","","sum_digit_factorials","Return the sum of the factorial of the digits of n. >>> sum_digit_factorials(145) 145 >>> sum_digit_factorials(45361) 871 >>> sum_digit_factorials(540) 145","sum, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_074\sol1.py","","chain_length","Calculate the length of the chain of non-repeating terms starting with n. Previous is a set containing the previous member of the chain. >>> chain_length(10101) 11 >>> chain_length(555) 20 >>> chain_length(178924) 39","sum_digit_factorials, set, previous.add, chain_length"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_074\sol1.py","","solution","Return the number of chains with a starting number below one million which contain exactly n non-repeating terms. >>> solution(10,1000) 28","sum, range, chain_length"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_074\sol2.py","","digit_factorial_sum","Function to perform the sum of the factorial of all the digits in number  >>> digit_factorial_sum(69.0) Traceback (most recent call last):     ... TypeError: Parameter number must be int  >>> digit_factorial_sum(-1) Traceback (most recent call last):     ... ValueError: Parameter number must be greater than or equal to 0  >>> digit_factorial_sum(0) 1  >>> digit_factorial_sum(69) 363600","sum, isinstance, TypeError, ValueError, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_074\sol2.py","","solution","Returns the number of numbers below number_limit that produce chains with exactly chain_length non repeating elements.  >>> solution(10.0, 1000) Traceback (most recent call last):     ... TypeError: Parameters chain_length and number_limit must be int  >>> solution(10, 1000.0) Traceback (most recent call last):     ... TypeError: Parameters chain_length and number_limit must be int  >>> solution(0, 1000) Traceback (most recent call last):     ... ValueError: Parameters chain_length and number_limit must be greater than 0  >>> solution(10, 0) Traceback (most recent call last):     ... ValueError: Parameters chain_length and number_limit must be greater than 0  >>> solution(10, 1000) 26","range, TypeError, ValueError, set, isinstance, isinstance, chain_set.add, digit_factorial_sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_075\sol1.py","","solution","Return the number of values of L <= limit such that a wire of length L can be formmed into an integer sided right angle triangle in exactly one way. >>> solution(50) 6 >>> solution(1000) 112 >>> solution(50000) 5502","defaultdict, sum, range, range, gcd, frequencies.values"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_076\sol1.py","","solution","Returns the number of different ways the number m can be written as a sum of at least two positive integers.  >>> solution(100) 190569291 >>> solution(50) 204225 >>> solution(30) 5603 >>> solution(10) 41 >>> solution(5) 6 >>> solution(3) 2 >>> solution(2) 1 >>> solution(1) 0","range, range, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_077\sol1.py","","partition","Return a set of integers corresponding to unique prime partitions of n. The unique prime partitions can be represented as unique prime decompositions, e.g. (7+3) <-> 7*3 = 12, (3+3+2+2) = 3*3*2*2 = 36 >>> partition(10) {32, 36, 21, 25, 30} >>> partition(15) {192, 160, 105, 44, 112, 243, 180, 150, 216, 26, 125, 126} >>> len(partition(20)) 26","lru_cache, set, set, partition, ret.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_077\sol1.py","","solution","Return the smallest integer that can be written as the sum of primes in over m unique ways. >>> solution(4) 10 >>> solution(500) 45 >>> solution(1000) 53","range, len, partition"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_078\sol1.py","","solution",">>> solution(1) 1  >>> solution(9) 14  >>> solution() 55374","itertools.count, len, itertools.count, partitions.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_079\sol1.py","","find_secret_passcode","Returns the shortest possible secret passcode of unknown length.  >>> find_secret_passcode([""135"", ""259"", ""235"", ""189"", ""690"", ""168"", ""120"", ...     ""136"", ""289"", ""589"", ""160"", ""165"", ""580"", ""369"", ""250"", ""280""]) 12365890  >>> find_secret_passcode([""426"", ""281"", ""061"", ""819"" ""268"", ""406"", ""420"", ...     ""428"", ""209"", ""689"", ""019"", ""421"", ""469"", ""261"", ""681"", ""201""]) 4206819","itertools.permutations, Exception, tuple, int, .join, permutation.index, permutation.index, permutation.index"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_079\sol1.py","","solution","Returns the shortest possible secret passcode of unknown length for successful login attempts given by `input_file` text file.  >>> solution(""keylog_test.txt"") 6312980",".splitlines, find_secret_passcode, .read_text, .parent.joinpath, Path"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_080\sol1.py","","solution","To evaluate the sum, Used decimal python module to calculate the decimal places up to 100, the most important thing would be take calculate a few extra places for decimal otherwise there will be rounding error.  >>> solution() 40886","decimal.Context, range, decimal.Decimal, number.sqrt, len, int, sum, str, str, str, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_081\sol1.py","","solution","Returns the minimal path sum from the top left to the bottom right of the matrix. >>> solution() 427337","len, range, range, range, open, in_file.read, range, os.path.join, int, .splitlines, range, os.path.dirname, row.split, range, min, data.strip"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_082\sol1.py","","solution","Returns the minimal path sum in the matrix from the file, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right  >>> solution(""test_matrix.txt"") 994","len, len, range, range, min, open, range, range, range, os.path.join, range, min, min, os.path.dirname, int, input_file.readlines, range, line.split"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_085\sol1.py","","solution","Find the area of the grid which contains as close to two million rectangles as possible. >>> solution(20) 6 >>> solution(2000) 72 >>> solution(2000000000) 86595","range, enumerate, ceil, triangle_numbers.append, floor, ceil, abs, abs, abs, abs, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_086\sol1.py","","solution","Return the least value of M such that there are more than one million cuboids of side lengths 1 <= a,b,c <= M such that the shortest distance between two opposite vertices of the cuboid is integral. >>> solution(100) 24 >>> solution(1000) 72 >>> solution(2000) 100 >>> solution(20000) 288","range, .is_integer, sqrt, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_087\sol1.py","","solution","Return the number of integers less than limit which can be expressed as the sum of a prime square, prime cube, and prime fourth power. >>> solution(50) 4","set, int, set, primes.add, range, len, range, primes.difference_update, set, range, ret.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_089\sol1.py","","parse_roman_numerals","Converts a string of roman numerals to an integer. e.g. >>> parse_roman_numerals(""LXXXIX"") 89 >>> parse_roman_numerals(""IIII"") 4","len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_089\sol1.py","","generate_roman_numerals","Generates a string of roman numerals for a given integer. e.g. >>> generate_roman_numerals(89) 'LXXXIX' >>> generate_roman_numerals(4) 'IV'",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_089\sol1.py","","solution","Calculates and returns the answer to project euler problem 89.  >>> solution(""/numeralcleanup_test.txt"") 16","open, file1.readlines, line.strip, parse_roman_numerals, generate_roman_numerals, len, len, os.path.dirname"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_091\sol1.py","","is_right","Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled. Note: this doesn't check if P and Q are equal, but that's handled by the use of itertools.combinations in the solution function.  >>> is_right(0, 1, 2, 0) True >>> is_right(1, 0, 2, 2) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_091\sol1.py","","solution","Return the number of right triangles OPQ that can be formed by two points P, Q which have both x- and y- coordinates between 0 and limit inclusive.  >>> solution(2) 14 >>> solution(10) 448","sum, combinations, is_right, product, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_092\sol1.py","","next_number","Returns the next number of the chain by adding the square of each digit to form a new number. For example, if number = 12, next_number() will return 1^2 + 2^2 = 5. Therefore, 5 is the next number of the chain. >>> next_number(44) 32 >>> next_number(10) 1 >>> next_number(32) 13",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_092\sol1.py","","chain","The function generates the chain of numbers until the next number is 1 or 89. For example, if starting number is 44, then the function generates the following chain of numbers: 44  32  13  10  1  1. Once the next number generated is 1 or 89, the function returns whether or not the next number generated by next_number() is 1. >>> chain(10) True >>> chain(58) False >>> chain(1) True","chain, next_number"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_092\sol1.py","","solution","The function returns the number of integers that end up being 89 in each chain. The function accepts a range number and the function checks all the values under value number.  >>> solution(100) 80 >>> solution(10000000) 8581146","range, .count, chain"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_094\sol1.py","","solution","Returns the sum of the perimeters of all almost equilateral triangles with integral side lengths and area and whose perimeters do not exceed max_perimeter  >>> solution(20) 16",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_095\sol1.py","","generate_primes","Calculates the list of primes up to and including `max_num`.  >>> generate_primes(6) [2, 3, 5]","range, isqrt, range, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_095\sol1.py","","multiply","Run over all prime combinations to generate non-prime numbers.  >>> chain = [0] * 3 >>> primes_degrees = {} >>> multiply( ...     chain=chain, ...     primes=[2], ...     min_prime_idx=0, ...     prev_num=1, ...     max_num=2, ...     prev_sum=0, ...     primes_degrees=primes_degrees, ... ) >>> chain [0, 0, 1] >>> primes_degrees {2: 1}","primes_degrees.get, range, len, multiply, primes_degrees.copy"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_095\sol1.py","","find_longest_chain","Finds the smallest element of longest chain  >>> find_longest_chain(chain=[0, 0, 0, 0, 0, 0, 6], max_num=6) 6","range, len, visited.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_095\sol1.py","","solution","Runs the calculation for numbers <= `max_num`.  >>> solution(10) 6 >>> solution(200000) 12496","generate_primes, enumerate, find_longest_chain, multiply"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_097\sol1.py","","solution","Returns the last n digits of NUMBER. >>> solution() '8739992577' >>> solution(8) '39992577' >>> solution(1) '7' >>> solution(-1) Traceback (most recent call last):     ... ValueError: Invalid input >>> solution(8.3) Traceback (most recent call last):     ... ValueError: Invalid input >>> solution(""a"") Traceback (most recent call last):     ... ValueError: Invalid input","str, ValueError, isinstance, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_099\sol1.py","","solution",">>> solution() 709","enumerate, open, list, os.path.join, map, os.path.dirname, line.split, log10, log10"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_100\sol1.py","","solution","Returns the number of blue discs for the first arrangement to contain over min_total discs in total  >>> solution(2) 3  >>> solution(4) 15  >>> solution(21) 85",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_101\sol1.py","","solve","Solve the linear system of equations Ax = b (A = ""matrix"", b = ""vector"") for x using Gaussian elimination and back substitution. We assume that A is an invertible square matrix and that b is a column vector of the same height. >>> solve([[1, 0], [0, 1]], [[1],[2]]) [[1.0], [2.0]] >>> solve([[2, 1, -1],[-3, -1, 2],[-2, 1, 2]],[[8], [-11],[-3]]) [[2.0], [3.0], [-1.0]]","len, range, range, range, range, range, range, max, range, range, round, range, range, abs, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_101\sol1.py","","interpolate","Given a list of data points (1,y0),(2,y1), ..., return a function that interpolates the data points. We find the coefficients of the interpolating polynomial by solving a system of linear equations corresponding to x = 1, 2, 3...  >>> interpolate([1])(3) 1 >>> interpolate([1, 8])(3) 15 >>> interpolate([1, 8, 27])(4) 58 >>> interpolate([1, 8, 27, 64])(6) 216","len, enumerate, solve, range, sum, range, range, range, round, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_101\sol1.py","","question_function","The generating function u as specified in the question. >>> question_function(0) 1 >>> question_function(1) 1 >>> question_function(5) 8138021 >>> question_function(10) 9090909091",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_101\sol1.py","","solution","Find the sum of the FITs of the BOPS. For each interpolating polynomial of order 1, 2, ... , 10, find the first x such that the value of the polynomial at x does not equal u(x). >>> solution(lambda n: n ** 3, 3) 74","func, interpolate, poly, range, range, func, poly"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_101\sol1.py","","interpolated_func",">>> interpolate([1])(3) 1 >>> interpolate([1, 8])(3) 15 >>> interpolate([1, 8, 27])(4) 58 >>> interpolate([1, 8, 27, 64])(6) 216","sum, round, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_102\sol1.py","","vector_product","Return the 2-d vector product of two vectors. >>> vector_product((1, 2), (-5, 0)) 10 >>> vector_product((3, 1), (6, 10)) 24",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_102\sol1.py","","contains_origin","Check if the triangle given by the points A(x1, y1), B(x2, y2), C(x3, y3) contains the origin. >>> contains_origin(-340, 495, -153, -910, 835, -947) True >>> contains_origin(-175, 41, -421, -714, 574, -645) False","vector_product, vector_product, vector_product, vector_product"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_102\sol1.py","","solution","Find the number of triangles whose interior contains the origin. >>> solution(""test_triangles.txt"") 1",".read_text, .split, triangles.append, contains_origin, .parent.joinpath, data.strip, int, line.split, Path"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_104\sol1.py","","check","Takes a number and checks if it is pandigital both from start and end   >>> check(123456789987654321) True  >>> check(120000987654321) False  >>> check(1234567895765677987654321) True","range, range, int, range, range, int, str, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_104\sol1.py","","check1","Takes a number and checks if it is pandigital from END  >>> check1(123456789987654321) True  >>> check1(120000987654321) True  >>> check1(12345678957656779870004321) False","range, range, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_104\sol1.py","","solution","Outputs the answer is the least Fibonacci number pandigital from both sides. >>> solution() 329468","range, range, check1, check"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_107\sol1.py","Graph","","A class representing an undirected weighted graph.",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_107\sol1.py","","solution","Find the maximum saving which can be achieved by removing redundant edges whilst ensuring that the network remains connected. >>> solution(""test_network.txt"") 150","os.path.abspath, os.path.join, range, Graph, graph.prims_algorithm, sum, sum, os.path.dirname, open, .split, line.split, len, range, set, graph.edges.values, subgraph.edges.values, range, .strip, int, len, f.read"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_107\sol1.py","","__init__","","min, max, edges.items"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_107\sol1.py","","add_edge","Add a new edge to the graph. >>> graph = Graph({1, 2}, {(2, 1): 4}) >>> graph.add_edge((3, 1), 5) >>> sorted(graph.vertices) [1, 2, 3] >>> sorted([(v,k) for k,v in graph.edges.items()]) [(4, (1, 2)), (5, (1, 3))]","self.vertices.add, self.vertices.add, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_107\sol1.py","","prims_algorithm","Run Prim's algorithm to find the minimum spanning tree. Reference: https://en.wikipedia.org/wiki/Prim%27s_algorithm >>> graph = Graph({1,2,3,4},{(1,2):5, (1,3):10, (1,4):20, (2,4):30, (3,4):1}) >>> mst = graph.prims_algorithm() >>> sorted(mst.vertices) [1, 2, 3, 4] >>> sorted(mst.edges) [(1, 2), (1, 3), (3, 4)]","Graph, len, len, self.edges.items, subgraph.add_edge, min, max, self.edges.values"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_109\sol1.py","","solution","Count the number of distinct ways a player can checkout with a score less than limit. >>> solution(171) 42336 >>> solution(50) 12577","combinations_with_replacement, list, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_112\sol1.py","","check_bouncy","Returns True if number is bouncy, False otherwise >>> check_bouncy(6789) False >>> check_bouncy(-12345) False >>> check_bouncy(0) False >>> check_bouncy(6.74) Traceback (most recent call last):     ... ValueError: check_bouncy() accepts only integer arguments >>> check_bouncy(132475) True >>> check_bouncy(34) False >>> check_bouncy(341) True >>> check_bouncy(47) False >>> check_bouncy(-12.54) Traceback (most recent call last):     ... ValueError: check_bouncy() accepts only integer arguments >>> check_bouncy(-6548) True","str, .join, isinstance, ValueError, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_112\sol1.py","","solution","Returns the least number for which the proportion of bouncy numbers is exactly 'percent' >>> solution(50) 538 >>> solution(90) 21780 >>> solution(80) 4770 >>> solution(105) Traceback (most recent call last):     ... ValueError: solution() only accepts values from 0 to 100 >>> solution(100.011) Traceback (most recent call last):     ... ValueError: solution() only accepts values from 0 to 100","ValueError, check_bouncy"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_113\sol1.py","","choose","Calculate the binomial coefficient c(n,r) using the multiplicative formula. >>> choose(4,2) 6 >>> choose(5,3) 10 >>> choose(20,6) 38760","range, round"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_113\sol1.py","","non_bouncy_exact","Calculate the number of non-bouncy numbers with at most n digits. >>> non_bouncy_exact(1) 9 >>> non_bouncy_exact(6) 7998 >>> non_bouncy_exact(10) 136126","choose, choose"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_113\sol1.py","","non_bouncy_upto","Calculate the number of non-bouncy numbers with at most n digits. >>> non_bouncy_upto(1) 9 >>> non_bouncy_upto(6) 12951 >>> non_bouncy_upto(10) 277032","sum, non_bouncy_exact, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_113\sol1.py","","solution","Calculate the number of non-bouncy numbers less than a googol. >>> solution(6) 12951 >>> solution(10) 277032","non_bouncy_upto"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_114\sol1.py","","solution","Returns the number of ways a row of the given length can be filled  >>> solution(7) 17","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_115\sol1.py","","solution","Returns for given minimum block length the least value of n for which the fill-count function first exceeds one million  >>> solution(3) 30  >>> solution(10) 57","count, fill_count_functions.append, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_116\sol1.py","","solution","Returns the number of different ways can the grey tiles in a row of the given length be replaced if colours cannot be mixed and at least one coloured tile must be used  >>> solution(5) 12","range, sum, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_117\sol1.py","","solution","Returns the number of ways can a row of the given length be tiled  >>> solution(5) 15","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_119\sol1.py","","digit_sum","Returns the sum of the digits of the number. >>> digit_sum(123) 6 >>> digit_sum(456) 15 >>> digit_sum(78910) 25","sum, int, str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_119\sol1.py","","solution","Returns the value of 30th digit power sum. >>> solution(2) 512 >>> solution(5) 5832 >>> solution(10) 614656","range, digit_to_powers.sort, range, int, math.pow, digit_sum, digit_to_powers.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_120\sol1.py","","solution","Returns  r_max for 3 <= a <= n as explained above >>> solution(10) 300 >>> solution(100) 330750 >>> solution(1000) 333082500","sum, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_121\sol1.py","","solution","Find the maximum prize fund that should be allocated to a single game in which fifteen turns are played. >>> solution(4) 10 >>> solution(10) 225","product, int, range, series.count, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_122\sol1.py","","solve","Checks if nums can have a sum equal to goal, given that length of nums does not exceed depth.  >>> solve([1], 2, 2) True >>> solve([1], 2, 0) False","len, nums.append, solve"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_122\sol1.py","","solution","Calculates sum of smallest number of multiplactions for each number up to and including n.  >>> solution(1) 0 >>> solution(2) 1 >>> solution(14) 45 >>> solution(15) 50","range, solve"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_123\sol1.py","","sieve","Returns a prime number generator using sieve method. >>> type(sieve()) <class 'generator'> >>> primes = sieve() >>> next(primes) 2 >>> next(primes) 3 >>> next(primes) 5 >>> next(primes) 7 >>> next(primes) 11 >>> next(primes) 13","factor_map.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_123\sol1.py","","solution","Returns the least value of n for which the remainder first exceeds 10^10. >>> solution(1e8) 2371 >>> solution(1e9) 7037","sieve, next, next"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_125\sol1.py","","is_palindrome","Check if an integer is palindromic. >>> is_palindrome(12521) True >>> is_palindrome(12522) False >>> is_palindrome(12210) False","str"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_125\sol1.py","","solution","Returns the sum of all numbers less than 1e8 that are both palindromic and can be written as the sum of consecutive squares.","set, sum, is_palindrome, answer.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_129\sol1.py","","least_divisible_repunit","Return the least value k such that the Repunit of length k is divisible by divisor. >>> least_divisible_repunit(7) 6 >>> least_divisible_repunit(41) 5 >>> least_divisible_repunit(1234567) 34020",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_129\sol1.py","","solution","Return the least value of n for which least_divisible_repunit(n) first exceeds limit. >>> solution(10) 17 >>> solution(100) 109 >>> solution(1000) 1017","least_divisible_repunit"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_131\sol1.py","","is_prime","Determines whether number is prime  >>> is_prime(3) True  >>> is_prime(4) False","all, range, isqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_131\sol1.py","","solution","Returns number of primes below max_prime with the property  >>> solution(100) 4","is_prime"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_135\sol1.py","","solution","returns the values of n less than or equal to the limit have exactly ten distinct solutions. >>> solution(100) 0 >>> solution(10000) 45 >>> solution(50050) 292","range, sum, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_136\sol1.py","","solution","Define n count list and loop over delta, y to get the counts, then check which n has count == 1.  >>> solution(3) 0 >>> solution(10) 3 >>> solution(100) 25 >>> solution(110) 27","range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_144\sol1.py","","next_point","Given that a laser beam hits the interior of the white cell at point (point_x, point_y) with gradient incoming_gradient, return a tuple (x,y,m1) where the next point of contact with the interior is (x,y) with gradient m1. >>> next_point(5.0, 0.0, 0.0) (-5.0, 0.0, 0.0) >>> next_point(5.0, 0.0, -2.0) (0.0, -10.0, 2.0)","isclose, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_144\sol1.py","","solution","Return the number of times that the beam hits the interior wall of the cell before exiting. >>> solution(0.00001,-10) 1 >>> solution(5, 0) 287","next_point"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_145\sol1.py","","slow_reversible_numbers","Count the number of reversible numbers of given length. Iterate over possible digits considering parity of current sum remainder. >>> slow_reversible_numbers(1, 0, [0], 1) 0 >>> slow_reversible_numbers(2, 0, [0] * 2, 2) 20 >>> slow_reversible_numbers(3, 0, [0] * 3, 3) 100","range, range, range, slow_reversible_numbers, slow_reversible_numbers"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_145\sol1.py","","slow_solution","To evaluate the solution, use solution() >>> slow_solution(3) 120 >>> slow_solution(6) 18720 >>> slow_solution(7) 68720","range, slow_reversible_numbers"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_145\sol1.py","","reversible_numbers","Count the number of reversible numbers of given length. Iterate over possible digits considering parity of current sum remainder. >>> reversible_numbers(1, 0, [0], 1) 0 >>> reversible_numbers(2, 0, [0] * 2, 2) 20 >>> reversible_numbers(3, 0, [0] * 3, 3) 100","slow_reversible_numbers"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_145\sol1.py","","solution","To evaluate the solution, use solution() >>> solution(3) 120 >>> solution(6) 18720 >>> solution(7) 68720","range, reversible_numbers"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_145\sol1.py","","benchmark","Benchmarks","print, print, print, timeit, timeit, globals, globals"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_164\sol1.py","","solve","Solve for remaining 'digit' digits, with previous 'prev1' digit, and previous-previous 'prev2' digit, total sum of 'sum_max'. Pass around 'cache' to store/reuse intermediate results.  >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=True, cache={}) 9 >>> solve(digit=1, prev1=0, prev2=0, sum_max=9, first=False, cache={}) 10","range, solve"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_164\sol1.py","","solution","Solves the problem for n_digits number of digits.  >>> solution(2) 45 >>> solution(10) 21838806","solve"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_173\sol1.py","","solution","Return the number of different square laminae that can be formed using up to one million tiles. >>> solution(100) 41","range, max, ceil, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_174\sol1.py","","solution","Return the sum of N(n) for 1 <= n <= n_limit.  >>> solution(1000,5) 222 >>> solution(1000,10) 249 >>> solution(10000,10) 2383","defaultdict, range, sum, range, max, ceil, count.values, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_180\sol1.py","","is_sq","Check if number is a perfect square.  >>> is_sq(1) True >>> is_sq(1000001) False >>> is_sq(1000000) True","int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_180\sol1.py","","add_three","Given the numerators and denominators of three fractions, return the numerator and denominator of their sum in lowest form. >>> add_three(1, 3, 1, 3, 1, 3) (1, 1) >>> add_three(2, 5, 4, 11, 12, 3) (262, 55)","gcd"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_180\sol1.py","","solution","Find the sum of the numerator and denominator of the sum of all s(x,y,z) for golden triples (x,y,z) of the given order.  >>> solution(5) 296 >>> solution(10) 12519 >>> solution(20) 19408891927","set, Fraction, range, range, Fraction, range, range, gcd, gcd, add_three, unique_s.add, is_sq, is_sq, int, int, gcd, add_three, unique_s.add, is_sq, is_sq, int, int, gcd, sqrt, sqrt, add_three, unique_s.add, sqrt, sqrt, add_three, unique_s.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_187\sol1.py","","slow_calculate_prime_numbers","Returns prime numbers below max_number. See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes  >>> slow_calculate_prime_numbers(10) [2, 3, 5, 7]  >>> slow_calculate_prime_numbers(2) []","range, isqrt, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_187\sol1.py","","calculate_prime_numbers","Returns prime numbers below max_number. See: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes  >>> calculate_prime_numbers(10) [2, 3, 5, 7]  >>> calculate_prime_numbers(2) []","range, isqrt, len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_187\sol1.py","","slow_solution","Returns the number of composite integers below max_number have precisely two, not necessarily distinct, prime factors.  >>> slow_solution(30) 10","slow_calculate_prime_numbers, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_187\sol1.py","","while_solution","Returns the number of composite integers below max_number have precisely two, not necessarily distinct, prime factors.  >>> while_solution(30) 10","calculate_prime_numbers, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_187\sol1.py","","solution","Returns the number of composite integers below max_number have precisely two, not necessarily distinct, prime factors.  >>> solution(30) 10","calculate_prime_numbers, range, len, len, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_187\sol1.py","","benchmark","Benchmarks","print, print, print, print, timeit, timeit, timeit, globals, globals, globals"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_188\sol1.py","","_modexpt","Returns the modular exponentiation, that is the value of `base ** exponent % modulo_value`, without calculating the actual number. >>> _modexpt(2, 4, 10) 6 >>> _modexpt(2, 1024, 100) 16 >>> _modexpt(13, 65535, 7) 6","_modexpt, _modexpt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_188\sol1.py","","solution","Returns the last 8 digits of the hyperexponentiation of base by height, i.e. the number baseheight:  >>> solution(base=3, height=2) 27 >>> solution(base=3, height=3) 97484987 >>> solution(base=123, height=456, digits=4) 2547","range, _modexpt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_190\sol1.py","","solution","Calculate sum of |_ P_m _| for m from 2 to n.  >>> solution(2) 1 >>> solution(3) 2 >>> solution(4) 4 >>> solution(5) 10","range, range, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_191\sol1.py","","_calculate","A small helper function for the recursion, mainly to have a clean interface for the solution() function below.  It should get called with the number of days (corresponding to the desired length of the 'prize strings'), and the initial values for the number of consecutive absent days and number of total late days.  >>> _calculate(days=4, absent=0, late=0) 43 >>> _calculate(days=30, absent=2, late=0) 0 >>> _calculate(days=30, absent=1, late=0) 98950096","_calculate, _calculate, _calculate"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_191\sol1.py","","solution","Returns the number of possible prize strings for a particular number of days, using a simple recursive function with caching to speed it up.  >>> solution() 1918080160 >>> solution(4) 43","_calculate"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_203\sol1.py","","get_pascal_triangle_unique_coefficients","Returns the unique coefficients of a Pascal's triangle of depth ""depth"".  The coefficients of this triangle are symmetric. A further improvement to this method could be to calculate the coefficients once per level. Nonetheless, the current implementation is fast enough for the original problem.  >>> get_pascal_triangle_unique_coefficients(1) {1} >>> get_pascal_triangle_unique_coefficients(2) {1} >>> get_pascal_triangle_unique_coefficients(3) {1, 2} >>> get_pascal_triangle_unique_coefficients(8) {1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}","range, zip, coefficients.add, previous_coefficients.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_203\sol1.py","","get_squarefrees","Calculates the squarefree numbers inside unique_coefficients.  Based on the definition of a non-squarefree number, then any non-squarefree n can be decomposed as n = p*p*r, where p is positive prime number and r is a positive integer.  Under the previous formula, any coefficient that is lower than p*p is squarefree as r cannot be negative. On the contrary, if any r exists such that n = p*p*r, then the number is non-squarefree.  >>> get_squarefrees({1}) {1} >>> get_squarefrees({1, 2}) {1, 2} >>> get_squarefrees({1, 2, 3, 4, 5, 6, 7, 35, 10, 15, 20, 21}) {1, 2, 3, 5, 6, 7, 35, 10, 15, 21}","set, unique_coefficients.difference, non_squarefrees.add"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_203\sol1.py","","solution","Returns the sum of squarefrees for a given Pascal's Triangle of depth n.  >>> solution(1) 1 >>> solution(8) 105 >>> solution(9) 175","get_pascal_triangle_unique_coefficients, get_squarefrees, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_205\sol1.py","","total_frequency_distribution","Returns frequency distribution of total  >>> total_frequency_distribution(sides_number=6, dice_number=1) [0, 1, 1, 1, 1, 1, 1]  >>> total_frequency_distribution(sides_number=4, dice_number=2) [0, 0, 1, 2, 3, 4, 3, 2, 1]","range, product, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_205\sol1.py","","solution","Returns probability that Pyramidal Peter beats Cubic Colin rounded to seven decimal places in the form 0.abcdefg  >>> solution() 0.5731441","total_frequency_distribution, total_frequency_distribution, range, round, sum"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_206\sol1.py","","is_square_form","Determines if num is in the form 1_2_3_4_5_6_7_8_9  >>> is_square_form(1) False >>> is_square_form(112233445566778899) True >>> is_square_form(123456789012345678) False",""
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_206\sol1.py","","solution","Returns the first integer whose square is of the form 1_2_3_4_5_6_7_8_9_0","is_square_form"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_207\sol1.py","","check_partition_perfect","Check if t = f(positive_integer) = log2(sqrt(4*positive_integer+1)/2 + 1/2) is a real number.  >>> check_partition_perfect(2) True  >>> check_partition_perfect(6) False","math.log2, int, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_207\sol1.py","","solution","Find m for which the proportion of perfect partitions to total partitions is lower than max_proportion  >>> solution(1) > 5 True  >>> solution(1/2) > 10 True  >>> solution(3 / 13) > 185 True","int, int, check_partition_perfect, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_234\sol1.py","","prime_sieve","Sieve of Erotosthenes Function to return all the prime numbers up to a certain number https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes >>> prime_sieve(3) [2] >>> prime_sieve(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","range, range, int, primes.append"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_234\sol1.py","","solution","Computes the solution to the problem up to the specified limit >>> solution(1000) 34825  >>> solution(10_000) 1134942  >>> solution(100_000) 36393008","prime_sieve, math.floor, math.sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_301\sol1.py","","solution","For any given exponent x >= 0, 1 <= n <= 2^x. This function returns how many Nim games are lost given that each Nim game has three heaps of the form (n, 2*n, 3*n). >>> solution(0) 1 >>> solution(2) 3 >>> solution(10) 144","int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_345\sol1.py","","solve","Finds the max sum for array `arr` starting with row index `row`, and with columns included in `cols`. `cache` is used for caching intermediate results.  >>> solve(arr=np.array([[1, 2], [3, 4]]), row=0, cols={0, 1}, cache={}) 5","len, max, sorted, int, solve"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_345\sol1.py","","solution","Takes list of strings `matrix_str` to parse the matrix and calculates the max sum.  >>> solution([""1 2"", ""3 4""]) 5 >>> solution(MATRIX_1) 3315","len, np.empty, enumerate, solve, matrix_row_str.split, enumerate, int, set, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_493\sol1.py","","solution","Calculates the expected number of distinct colours  >>> solution(10) '5.669644129'  >>> solution(30) '6.985042712'","math.comb, math.comb"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_551\sol1.py","","next_term","Calculates and updates a_i in-place to either the n-th term or the smallest term for which c > 10^k when the terms are written in the form:         a(i) = b * 10^k + c  For any a(i), if digitsum(b) and c have the same value, the difference between subsequent terms will be the same until c >= 10^k.  This difference is cached to greatly speed up the computation.  Arguments: a_i -- array of digits starting from the one's place that represent        the i-th term in the sequence k --  k when terms are written in the from a(i) = b*10^k + c.       Term are calulcated until c > 10^k or the n-th term is reached. i -- position along the sequence n -- term to calculate up to if k is large enough  Return: a tuple of difference between ending term and starting term, and the number of terms calculated. ex. if starting term is a_0=1, and ending term is a_10=62, then (61, 9) is returned.","sum, sum, memo.get, .insert, sub_memo.get, compute, len, range, next_term, range, range, len, range, len, min, len, min, divmod, add, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_551\sol1.py","","compute","same as next_term(a_i, k, i, n) but computes terms without memoizing results.","range, len, a_i.extend, len, range, add, divmod, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_551\sol1.py","","add","adds addend to digit array given in digits starting at index k","range, len, divmod, digits.append, divmod"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_551\sol1.py","","solution","returns n-th term of sequence  >>> solution(10) 62  >>> solution(10**6) 31054319  >>> solution(10**15) 73597483551591773","range, next_term, len"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_587\sol1.py","","circle_bottom_arc_integral","Returns integral of circle bottom arc y = 1 / 2 - sqrt(1 / 4 - (x - 1 / 2) ^ 2)  >>> circle_bottom_arc_integral(0) 0.39269908169872414  >>> circle_bottom_arc_integral(1 / 2) 0.44634954084936207  >>> circle_bottom_arc_integral(1) 0.5","asin, sqrt, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_587\sol1.py","","concave_triangle_area","Returns area of concave triangle  >>> concave_triangle_area(1) 0.026825229575318944  >>> concave_triangle_area(2) 0.01956236140083944","circle_bottom_arc_integral, circle_bottom_arc_integral, sqrt"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_587\sol1.py","","solution","Returns least value of n for which the concave triangle occupies less than fraction of the L-section  >>> solution(1 / 10) 15","count, concave_triangle_area"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_686\sol1.py","","log_difference","This function returns the decimal value of a number multiplied with log(2) Since the problem is on powers of two, finding the powers of two with large exponents is time consuming. Hence we use log to reduce compute time.  We can find out that the first power of 2 with starting digits 123 is 90. Computing 2^90 is time consuming. Hence we find log(2^90) = 90*log(2) = 27.092699609758302 But we require only the decimal part to determine whether the power starts with 123. So we just return the decimal part of the log product. Therefore we return 0.092699609758302  >>> log_difference(90) 0.092699609758302 >>> log_difference(379) 0.090368356648852","round, math.log, int"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_686\sol1.py","","solution","This function calculates the power of two which is nth (n = number) smallest value of power of 2 such that the starting digits of the 2^power is 123.  For example the powers of 2 for which starting digits is 123 are: 90, 379, 575, 864, 1060, 1545, 1741, 2030, 2226, 2515 and so on. 90 is the first power of 2 whose starting digits are 123, 379 is second power of 2 whose starting digits are 123, and so on.  So if number = 10, then solution returns 2515 as we observe from above series.  We will define a lowerbound and upperbound. lowerbound = log(1.23), upperbound = log(1.24) because we need to find the powers that yield 123 as starting digits.  log(1.23) = 0.08990511143939792, log(1,24) = 0.09342168516223506. We use 1.23 and not 12.3 or 123, because log(1.23) yields only decimal value which is less than 1. log(12.3) will be same decimal value but 1 added to it which is log(12.3) = 1.093421685162235. We observe that decimal value remains same no matter 1.23 or 12.3 Since we use the function log_difference(), which returns the value that is only decimal part, using 1.23 is logical.  If we see, 90*log(2) = 27.092699609758302, decimal part = 0.092699609758302, which is inside the range of lowerbound and upperbound.  If we compute the difference between all the powers which lead to 123 starting digits is as follows:  379 - 90 = 289 575 - 379 = 196 864 - 575 = 289 1060 - 864 = 196  We see a pattern here. The difference is either 196 or 289 = 196 + 93.  Hence to optimize the algorithm we will increment by 196 or 93 depending upon the log_difference() value.  Let's take for example 90. Since 90 is the first power leading to staring digits as 123, we will increment iterator by 196. Because the difference between any two powers leading to 123 as staring digits is greater than or equal to 196. After incrementing by 196 we get 286.  log_difference(286) = 0.09457875989861 which is greater than upperbound. The next power is 379, and we need to add 93 to get there. The iterator will now become 379, which is the next power leading to 123 as starting digits.  Let's take 1060. We increment by 196, we get 1256. log_difference(1256) = 0.09367455396034, Which is greater than upperbound hence we increment by 93. Now iterator is 1349. log_difference(1349) = 0.08946415071057 which is less than lowerbound. The next power is 1545 and we need to add 196 to get 1545.  Conditions are as follows:  1) If we find a power whose log_difference() is in the range of lower and upperbound, we will increment by 196. which implies that the power is a number which will lead to 123 as starting digits. 2) If we find a power, whose log_difference() is greater than or equal upperbound, we will increment by 93. 3) if log_difference() < lowerbound, we increment by 196.  Reference to the above logic: https://math.stackexchange.com/questions/4093970/powers-of-2-starting-with-123-does-a-pattern-exist  >>> solution(1000) 284168  >>> solution(56000) 15924915  >>> solution(678910) 193060223","math.log, math.log, log_difference"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_800\sol1.py","","calculate_prime_numbers","Returns prime numbers below max_number  >>> calculate_prime_numbers(10) [2, 3, 5, 7]","range, isqrt, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\project_euler\problem_800\sol1.py","","solution","Returns the number of hybrid-integers less than or equal to base^degree  >>> solution(800, 1) 2  >>> solution(800, 800) 10790","int, calculate_prime_numbers, log2, len, log2, log2"
"C:/Users/Joseph Dania/Desktop/python_repo\quantum\q_fourier_transform.py","","quantum_fourier_transform","# >>> quantum_fourier_transform(2) # {'00': 2500, '01': 2500, '11': 2500, '10': 2500} # quantum circuit for number_of_qubits = 3:                                             qr_0:  H X                              P(/2)   qr_1:  H         P(/4)  P(/2)                 qr_2:  H X        cr: 3/ Args:     n : number of qubits Returns:     qiskit.result.counts.Counts: distribute counts.  >>> quantum_fourier_transform(2) {'00': 2500, '01': 2500, '10': 2500, '11': 2500} >>> quantum_fourier_transform(-1) Traceback (most recent call last):     ... ValueError: number of qubits must be > 0. >>> quantum_fourier_transform('a') Traceback (most recent call last):     ... TypeError: number of qubits must be a integer. >>> quantum_fourier_transform(100) Traceback (most recent call last):     ... ValueError: number of qubits too large to simulate(>10). >>> quantum_fourier_transform(0.5) Traceback (most recent call last):     ... ValueError: number of qubits must be exact integer.","isinstance, QuantumRegister, ClassicalRegister, QuantumCircuit, range, range, quantum_circuit.measure, Aer.get_backend, execute, .get_counts, TypeError, ValueError, math.floor, ValueError, ValueError, quantum_circuit.h, range, quantum_circuit.swap, quantum_circuit.cp, job.result"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\first_come_first_served.py","","calculate_waiting_times","This function calculates the waiting time of some processes that have a specified duration time.     Return: The waiting time for each process. >>> calculate_waiting_times([5, 10, 15]) [0, 5, 15] >>> calculate_waiting_times([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10] >>> calculate_waiting_times([10, 3]) [0, 10]","range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\first_come_first_served.py","","calculate_turnaround_times","This function calculates the turnaround time of some processes.     Return: The time difference between the completion time and the             arrival time.             Practically waiting_time + duration_time >>> calculate_turnaround_times([5, 10, 15], [0, 5, 15]) [5, 15, 30] >>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10]) [1, 3, 6, 10, 15] >>> calculate_turnaround_times([10, 3], [0, 10]) [10, 13]","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\first_come_first_served.py","","calculate_average_turnaround_time","This function calculates the average of the turnaround times     Return: The average of the turnaround times. >>> calculate_average_turnaround_time([0, 5, 16]) 7.0 >>> calculate_average_turnaround_time([1, 5, 8, 12]) 6.5 >>> calculate_average_turnaround_time([10, 24]) 17.0","sum, len"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\first_come_first_served.py","","calculate_average_waiting_time","This function calculates the average of the waiting times     Return: The average of the waiting times. >>> calculate_average_waiting_time([0, 5, 16]) 7.0 >>> calculate_average_waiting_time([1, 5, 8, 12]) 6.5 >>> calculate_average_waiting_time([10, 24]) 17.0","sum, len"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\highest_response_ratio_next.py","","calculate_turn_around_time","Calculate the turn around time of each processes  Return: The turn around time time for each process. >>> calculate_turn_around_time([""A"", ""B"", ""C""], [3, 5, 8], [2, 4, 6], 3) [2, 4, 7] >>> calculate_turn_around_time([""A"", ""B"", ""C""], [0, 2, 4], [3, 5, 7], 3) [3, 6, 11]","arrival_time.sort, max, range, np.argsort, np.argsort"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\highest_response_ratio_next.py","","calculate_waiting_time","Calculate the waiting time of each processes.  Return: The waiting time for each process. >>> calculate_waiting_time([""A"", ""B"", ""C""], [2, 4, 7], [2, 4, 6], 3) [0, 0, 1] >>> calculate_waiting_time([""A"", ""B"", ""C""], [3, 6, 11], [3, 5, 7], 3) [0, 1, 4]","range"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\job_sequence_with_deadline.py","Task","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\job_sequence_with_deadline.py","","max_tasks","Create a list of Task objects that are sorted so the highest rewards come first. Return a list of those task ids that can be completed before i becomes too high. >>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)]) [2, 0] >>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)]) [3, 2] >>> max_tasks([(9, 10)]) [0] >>> max_tasks([(-9, 10)]) [] >>> max_tasks([]) [] >>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)]) [] >>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)]) []","sorted, Task, attrgetter, enumerate, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\job_sequencing_with_deadline.py","","job_sequencing_with_deadlines","Function to find the maximum profit by doing jobs in a given time frame  Args:     jobs [list]: A list of tuples of (job_id, deadline, profit)  Returns:     max_profit [int]: Maximum profit that can be earned by doing jobs     in a given time frame  Examples: >>> job_sequencing_with_deadlines( ... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)]) [2, 60] >>> job_sequencing_with_deadlines( ... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)]) [2, 127]","sorted, max, range"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","Process","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","MLFQ","","MLFQ(Multi Level Feedback Queue) https://en.wikipedia.org/wiki/Multilevel_feedback_queue MLFQ has a lot of queues that have different priority In this MLFQ, The first Queue(0) to last second Queue(N-2) of MLFQ have Round Robin Algorithm The last Queue(N-1) has First Come, First Served Algorithm",""
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","__init__","","deque"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","calculate_sequence_of_finish_queue","This method returns the sequence of finished processes >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> _ = mlfq.multi_level_feedback_queue() >>> mlfq.calculate_sequence_of_finish_queue() ['P2', 'P4', 'P1', 'P3']","range, len, sequence.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","calculate_waiting_time","This method calculates waiting time of processes >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> _ = mlfq.multi_level_feedback_queue() >>> mlfq.calculate_waiting_time([P1, P2, P3, P4]) [83, 17, 94, 101]","range, len, waiting_times.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","calculate_turnaround_time","This method calculates turnaround time of processes >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> _ = mlfq.multi_level_feedback_queue() >>> mlfq.calculate_turnaround_time([P1, P2, P3, P4]) [136, 34, 162, 125]","range, len, turnaround_times.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","calculate_completion_time","This method calculates completion time of processes >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> _ = mlfq.multi_level_feedback_queue() >>> mlfq.calculate_turnaround_time([P1, P2, P3, P4]) [136, 34, 162, 125]","range, len, completion_times.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","calculate_remaining_burst_time_of_processes","This method calculate remaining burst time of processes >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> finish_queue, ready_queue = mlfq.round_robin(deque([P1, P2, P3, P4]), 17) >>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue) [0] >>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue) [36, 51, 7] >>> finish_queue, ready_queue = mlfq.round_robin(ready_queue, 25) >>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue) [0, 0] >>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue) [11, 26]",""
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","update_waiting_time","This method updates waiting times of unfinished processes >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> mlfq.current_time = 10 >>> P1.stop_time = 5 >>> mlfq.update_waiting_time(P1) 5",""
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","first_come_first_served","FCFS(First Come, First Served) FCFS will be applied to MLFQ's last queue A first came process will be finished at first >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> _ = mlfq.first_come_first_served(mlfq.ready_queue) >>> mlfq.calculate_sequence_of_finish_queue() ['P1', 'P2', 'P3', 'P4']","deque, self.finish_queue.extend, len, ready_queue.popleft, self.update_waiting_time, finished.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","round_robin","RR(Round Robin) RR will be applied to MLFQ's all queues except last queue All processes can't use CPU for time more than time_slice If the process consume CPU up to time_slice, it will go back to ready queue >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> finish_queue, ready_queue = mlfq.round_robin(mlfq.ready_queue, 17) >>> mlfq.calculate_sequence_of_finish_queue() ['P2']","deque, range, self.finish_queue.extend, len, ready_queue.popleft, self.update_waiting_time, ready_queue.append, finished.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\multi_level_feedback_queue.py","","multi_level_feedback_queue","MLFQ(Multi Level Feedback Queue) >>> P1 = Process(""P1"", 0, 53) >>> P2 = Process(""P2"", 0, 17) >>> P3 = Process(""P3"", 0, 68) >>> P4 = Process(""P4"", 0, 24) >>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0) >>> finish_queue = mlfq.multi_level_feedback_queue() >>> mlfq.calculate_sequence_of_finish_queue() ['P2', 'P4', 'P1', 'P3']","range, self.first_come_first_served, self.round_robin"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\non_preemptive_shortest_job_first.py","","calculate_waitingtime","Calculate the waiting time of each processes  Return: The waiting time for each process. >>> calculate_waitingtime([0,1,2], [10, 5, 8], 3) [0, 9, 13] >>> calculate_waitingtime([1,2,2,4], [4, 6, 3, 1], 4) [0, 7, 4, 1] >>> calculate_waitingtime([0,0,0], [12, 2, 10],3) [12, 0, 2]","range, range, len, ready_process.append"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\non_preemptive_shortest_job_first.py","","calculate_turnaroundtime","Calculate the turnaround time of each process.  Return: The turnaround time for each process. >>> calculate_turnaroundtime([0,1,2], 3, [0, 10, 15]) [0, 11, 17] >>> calculate_turnaroundtime([1,2,2,4], 4, [1, 8, 5, 4]) [2, 10, 7, 8] >>> calculate_turnaroundtime([0,0,0], 3, [12, 0, 2]) [12, 0, 2]","range"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\round_robin.py","","calculate_waiting_times","Calculate the waiting times of a list of processes that have a specified duration.  Return: The waiting time for each process. >>> calculate_waiting_times([10, 5, 8]) [13, 10, 13] >>> calculate_waiting_times([4, 6, 3, 1]) [5, 8, 9, 6] >>> calculate_waiting_times([12, 2, 10]) [12, 2, 12]","list, len, enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\round_robin.py","","calculate_turn_around_times",">>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3]) [1, 3, 6] >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11]) [20, 9, 18]","zip"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\shortest_job_first.py","","calculate_waitingtime","Calculate the waiting time of each processes Return: List of waiting times. >>> calculate_waitingtime([1,2,3,4],[3,3,5,1],4) [0, 3, 5, 0] >>> calculate_waitingtime([1,2,3],[2,5,1],3) [0, 2, 0] >>> calculate_waitingtime([2,3],[5,1],2) [1, 0]","range, range, max"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\shortest_job_first.py","","calculate_turnaroundtime","Calculate the turn around time of each Processes Return: list of turn around times. >>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0]) [3, 6, 10, 1] >>> calculate_turnaroundtime([3,3], 2, [0,3]) [3, 6] >>> calculate_turnaroundtime([8,10,1], 3, [1,0,3]) [9, 10, 4]","range"
"C:/Users/Joseph Dania/Desktop/python_repo\scheduling\shortest_job_first.py","","calculate_average_times","This function calculates the average of the waiting & turnaround times Prints: Average Waiting time & Average Turn Around Time >>> calculate_average_times([0,3,5,0],[3,6,10,1],4) Average waiting time = 2.00000 Average turn around time = 5.0 >>> calculate_average_times([2,3],[3,6],2) Average waiting time = 2.50000 Average turn around time = 4.5 >>> calculate_average_times([10,4,3],[2,7,6],3) Average waiting time = 5.66667 Average turn around time = 5.0","range, print, print"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\build_directory_md.py","","good_file_paths","","os.walk, os.path.splitext, .lstrip, os.path.join"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\build_directory_md.py","","md_prefix","Markdown prefix based on indent for bullet points  >>> md_prefix(0) '\n##' >>> md_prefix(1) '  *' >>> md_prefix(2) '    *' >>> md_prefix(3) '      *'",""
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\build_directory_md.py","","print_path","","old_path.split, enumerate, new_path.split, print, len, md_prefix, .title, new_part.replace"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\build_directory_md.py","","print_directory_md","","sorted, good_file_paths, os.path.split, .replace, print, print_path, os.path.splitext, filepath.count, .title, md_prefix, filename.replace"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\validate_solutions.py","","convert_path_to_module","Converts a file path to a Python module","importlib.util.spec_from_file_location, importlib.util.module_from_spec, spec.loader.exec_module, str"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\validate_solutions.py","","all_solution_file_paths","Collects all the solution file path in the Project Euler directory","PROJECT_EULER_DIR_PATH.iterdir, problem_dir_path.iterdir, problem_dir_path.is_file, problem_dir_path.name.startswith, solution_file_paths.append, file_path.name.startswith"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\validate_solutions.py","","get_files_url","Return the pull request number which triggered this action.","open, json.load"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\validate_solutions.py","","added_solution_file_path","Collects only the solution file path which got added in the current pull request.  This will only be triggered if the script is ran from GitHub Actions.",".json, .joinpath, solution_file_paths.append, httpx.get, filepath.name.startswith, get_files_url, pathlib.Path.cwd, filepath.name.startswith"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\validate_solutions.py","","collect_solution_file_paths","","all_solution_file_paths, os.environ.get, os.environ.get, added_solution_file_path"
"C:/Users/Joseph Dania/Desktop/python_repo\scripts\validate_solutions.py","","test_project_euler","Testing for all Project Euler solutions","pytest.mark.parametrize, .zfill, convert_path_to_module, str, .hexdigest, collect_solution_file_paths, solution_module.solution, hashlib.sha256, answer.encode"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","bisect_left","Locates the first element in a sorted array that is larger or equal to a given value.  It has the same interface as https://docs.python.org/3/library/bisect.html#bisect.bisect_left .  :param sorted_collection: some ascending sorted collection with comparable items :param item: item to bisect :param lo: lowest index to consider (as in sorted_collection[lo:hi]) :param hi: past the highest index to consider (as in sorted_collection[lo:hi]) :return: index i such that all values in sorted_collection[lo:i] are < item and all     values in sorted_collection[i:hi] are >= item.  Examples: >>> bisect_left([0, 5, 7, 10, 15], 0) 0 >>> bisect_left([0, 5, 7, 10, 15], 6) 2 >>> bisect_left([0, 5, 7, 10, 15], 20) 5 >>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3) 3 >>> bisect_left([0, 5, 7, 10, 15], 6, 2) 2","len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","bisect_right","Locates the first element in a sorted array that is larger than a given value.  It has the same interface as https://docs.python.org/3/library/bisect.html#bisect.bisect_right .  :param sorted_collection: some ascending sorted collection with comparable items :param item: item to bisect :param lo: lowest index to consider (as in sorted_collection[lo:hi]) :param hi: past the highest index to consider (as in sorted_collection[lo:hi]) :return: index i such that all values in sorted_collection[lo:i] are <= item and     all values in sorted_collection[i:hi] are > item.  Examples: >>> bisect_right([0, 5, 7, 10, 15], 0) 1 >>> bisect_right([0, 5, 7, 10, 15], 15) 5 >>> bisect_right([0, 5, 7, 10, 15], 6) 2 >>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3) 3 >>> bisect_right([0, 5, 7, 10, 15], 6, 2) 2","len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","insort_left","Inserts a given value into a sorted array before other values with the same value.  It has the same interface as https://docs.python.org/3/library/bisect.html#bisect.insort_left .  :param sorted_collection: some ascending sorted collection with comparable items :param item: item to insert :param lo: lowest index to consider (as in sorted_collection[lo:hi]) :param hi: past the highest index to consider (as in sorted_collection[lo:hi])  Examples: >>> sorted_collection = [0, 5, 7, 10, 15] >>> insort_left(sorted_collection, 6) >>> sorted_collection [0, 5, 6, 7, 10, 15] >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)] >>> item = (5, 5) >>> insort_left(sorted_collection, item) >>> sorted_collection [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)] >>> item is sorted_collection[1] True >>> item is sorted_collection[2] False >>> sorted_collection = [0, 5, 7, 10, 15] >>> insort_left(sorted_collection, 20) >>> sorted_collection [0, 5, 7, 10, 15, 20] >>> sorted_collection = [0, 5, 7, 10, 15] >>> insort_left(sorted_collection, 15, 1, 3) >>> sorted_collection [0, 5, 7, 15, 10, 15]","sorted_collection.insert, bisect_left"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","insort_right","Inserts a given value into a sorted array after other values with the same value.  It has the same interface as https://docs.python.org/3/library/bisect.html#bisect.insort_right .  :param sorted_collection: some ascending sorted collection with comparable items :param item: item to insert :param lo: lowest index to consider (as in sorted_collection[lo:hi]) :param hi: past the highest index to consider (as in sorted_collection[lo:hi])  Examples: >>> sorted_collection = [0, 5, 7, 10, 15] >>> insort_right(sorted_collection, 6) >>> sorted_collection [0, 5, 6, 7, 10, 15] >>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)] >>> item = (5, 5) >>> insort_right(sorted_collection, item) >>> sorted_collection [(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)] >>> item is sorted_collection[1] False >>> item is sorted_collection[2] True >>> sorted_collection = [0, 5, 7, 10, 15] >>> insort_right(sorted_collection, 20) >>> sorted_collection [0, 5, 7, 10, 15, 20] >>> sorted_collection = [0, 5, 7, 10, 15] >>> insort_right(sorted_collection, 15, 1, 3) >>> sorted_collection [0, 5, 7, 15, 10, 15]","sorted_collection.insert, bisect_right"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","binary_search","Pure implementation of a binary search algorithm in Python  Be careful collection must be ascending sorted otherwise, the result will be unpredictable  :param sorted_collection: some ascending sorted collection with comparable items :param item: item value to search :return: index of the found item or -1 if the item is not found  Examples: >>> binary_search([0, 5, 7, 10, 15], 0) 0 >>> binary_search([0, 5, 7, 10, 15], 15) 4 >>> binary_search([0, 5, 7, 10, 15], 5) 1 >>> binary_search([0, 5, 7, 10, 15], 6) -1","list, sorted, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","binary_search_std_lib","Pure implementation of a binary search algorithm in Python using stdlib  Be careful collection must be ascending sorted otherwise, the result will be unpredictable  :param sorted_collection: some ascending sorted collection with comparable items :param item: item value to search :return: index of the found item or -1 if the item is not found  Examples: >>> binary_search_std_lib([0, 5, 7, 10, 15], 0) 0 >>> binary_search_std_lib([0, 5, 7, 10, 15], 15) 4 >>> binary_search_std_lib([0, 5, 7, 10, 15], 5) 1 >>> binary_search_std_lib([0, 5, 7, 10, 15], 6) -1","bisect.bisect_left, list, sorted, ValueError, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","binary_search_by_recursion","Pure implementation of a binary search algorithm in Python by recursion  Be careful collection must be ascending sorted otherwise, the result will be unpredictable First recursion should be started with left=0 and right=(len(sorted_collection)-1)  :param sorted_collection: some ascending sorted collection with comparable items :param item: item value to search :return: index of the found item or -1 if the item is not found  Examples: >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4) 0 >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4) 4 >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4) 1 >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4) -1","list, sorted, ValueError, len, binary_search_by_recursion, binary_search_by_recursion"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_search.py","","exponential_search","Pure implementation of an exponential search algorithm in Python Resources used: https://en.wikipedia.org/wiki/Exponential_search  Be careful collection must be ascending sorted otherwise, result will be unpredictable  :param sorted_collection: some ascending sorted collection with comparable items :param item: item value to search :return: index of the found item or -1 if the item is not found  the order of this algorithm is O(lg I) where I is index position of item if exist  Examples: >>> exponential_search([0, 5, 7, 10, 15], 0) 0 >>> exponential_search([0, 5, 7, 10, 15], 15) 4 >>> exponential_search([0, 5, 7, 10, 15], 5) 1 >>> exponential_search([0, 5, 7, 10, 15], 6) -1","min, binary_search_by_recursion, list, sorted, ValueError, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","TreeNode","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","build_tree","","print, .lower, queue.Queue, TreeNode, q.put, ValueError, int, q.empty, q.get, TreeNode, q.put, TreeNode, q.put, .strip, .lower, int, .lower, int, input, .strip, .strip, input, input"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","pre_order",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> pre_order(root) 1,2,4,5,3,6,7,","print, pre_order, pre_order, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","in_order",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> in_order(root) 4,2,5,1,6,3,7,","in_order, print, in_order, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","post_order",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> post_order(root) 4,5,2,6,7,3,1,","post_order, post_order, print, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","level_order",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> level_order(root) 1,2,3,4,5,6,7,","queue.Queue, q.put, q.empty, q.get, print, isinstance, q.put, q.put"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","level_order_actual",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> level_order_actual(root) 1, 2,3, 4,5,6,7,","queue.Queue, q.put, q.empty, print, isinstance, q.empty, q.get, print, q.put, list_.append, list_.append"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","pre_order_iter",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> pre_order_iter(root) 1,2,4,5,3,6,7,","stack.pop, isinstance, print, stack.append"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","in_order_iter",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> in_order_iter(root) 4,2,5,1,6,3,7,","stack.pop, print, isinstance, stack.append"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","post_order_iter",">>> root = TreeNode(1) >>> tree_node2 = TreeNode(2) >>> tree_node3 = TreeNode(3) >>> tree_node4 = TreeNode(4) >>> tree_node5 = TreeNode(5) >>> tree_node6 = TreeNode(6) >>> tree_node7 = TreeNode(7) >>> root.left, root.right = tree_node2, tree_node3 >>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5 >>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7 >>> post_order_iter(root) 4,5,2,6,7,3,1,","stack1.append, stack1.pop, stack2.append, print, isinstance, stack1.append, stack1.append, stack2.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","prompt","","divmod, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\binary_tree_traversal.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\double_linear_search.py","","double_linear_search","Iterate through the array from both sides to find the index of search_item.  :param array: the array to be searched :param search_item: the item to be searched :return the index of search_item, if search_item is in array, else -1  Examples: >>> double_linear_search([1, 5, 5, 10], 1) 0 >>> double_linear_search([1, 5, 5, 10], 5) 1 >>> double_linear_search([1, 5, 5, 10], 100) -1 >>> double_linear_search([1, 5, 5, 10], 10) 3","len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\double_linear_search_recursion.py","","search","Iterate through the array to find the index of key using recursion. :param list_data: the list to be searched :param key: the key to be searched :param left: the index of first element :param right: the index of last element :return: the index of key value if found, -1 otherwise.  >>> search(list(range(0, 11)), 5) 5 >>> search([1, 2, 4, 5, 3], 4) 2 >>> search([1, 2, 4, 5, 3], 6) -1 >>> search([5], 5) 0 >>> search([], 1) -1","len, search"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\exponential_search.py","","binary_search_by_recursion","Pure implementation of binary search algorithm in Python using recursion  Be careful: the collection must be ascending sorted otherwise, the result will be unpredictable.  :param sorted_collection: some ascending sorted collection with comparable items :param item: item value to search :param left: starting index for the search :param right: ending index for the search :return: index of the found item or -1 if the item is not found  Examples: >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4) 0 >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4) 4 >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4) 1 >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4) -1","list, sorted, ValueError, len, binary_search_by_recursion, binary_search_by_recursion"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\exponential_search.py","","exponential_search","Pure implementation of an exponential search algorithm in Python. For more information, refer to: https://en.wikipedia.org/wiki/Exponential_search  Be careful: the collection must be ascending sorted, otherwise the result will be unpredictable.  :param sorted_collection: some ascending sorted collection with comparable items :param item: item value to search :return: index of the found item or -1 if the item is not found  The time complexity of this algorithm is O(log i) where i is the index of the item.  Examples: >>> exponential_search([0, 5, 7, 10, 15], 0) 0 >>> exponential_search([0, 5, 7, 10, 15], 15) 4 >>> exponential_search([0, 5, 7, 10, 15], 5) 1 >>> exponential_search([0, 5, 7, 10, 15], 6) -1","min, binary_search_by_recursion, list, sorted, ValueError, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\fibonacci_search.py","","fibonacci","Finds fibonacci number in index k.  Parameters ---------- k :     Index of fibonacci.  Returns ------- int     Fibonacci number in position k.  >>> fibonacci(0) 0 >>> fibonacci(2) 1 >>> fibonacci(5) 5 >>> fibonacci(15) 610 >>> fibonacci('a') Traceback (most recent call last): TypeError: k must be an integer. >>> fibonacci(-5) Traceback (most recent call last): ValueError: k integer must be greater or equal to zero.","isinstance, TypeError, ValueError, fibonacci, fibonacci"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\fibonacci_search.py","","fibonacci_search","A pure Python implementation of a fibonacci search algorithm.  Parameters ---------- arr     List of sorted elements. val     Element to search in list.  Returns ------- int     The index of the element in the array.     -1 if the element is not found.  >>> fibonacci_search([4, 5, 6, 7], 4) 0 >>> fibonacci_search([4, 5, 6, 7], -10) -1 >>> fibonacci_search([-18, 2], -18) 0 >>> fibonacci_search([5], 5) 0 >>> fibonacci_search(['a', 'c', 'd'], 'c') 1 >>> fibonacci_search(['a', 'c', 'd'], 'f') -1 >>> fibonacci_search([], 1) -1 >>> fibonacci_search([.1, .4 , 7], .4) 1 >>> fibonacci_search([], 9) -1 >>> fibonacci_search(list(range(100)), 63) 63 >>> fibonacci_search(list(range(100)), 99) 99 >>> fibonacci_search(list(range(-100, 100, 3)), -97) 1 >>> fibonacci_search(list(range(-100, 100, 3)), 0) -1 >>> fibonacci_search(list(range(-100, 100, 5)), 0) 20 >>> fibonacci_search(list(range(-100, 100, 5)), 95) 39","len, min, fibonacci, fibonacci, fibonacci"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","SearchProblem","","An interface to define search problems. The interface will be illustrated using the example of mathematical function.",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","hill_climbing","Implementation of the hill climbling algorithm. We start with a given state, find all its neighbors, move towards the neighbor which provides the maximum (or minimum) change. We keep doing this until we are at a state where we do not have any neighbors which can improve the solution.     Args:         search_prob: The search state at the start.         find_max: If True, the algorithm should find the maximum else the minimum.         max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.         visualization: If True, a matplotlib graph is displayed.         max_iter: number of times to run the iteration.     Returns a search state having the maximum (or minimum) score.","set, visited.add, current_state.score, scores.append, current_state.get_neighbors, plt.plot, plt.xlabel, plt.ylabel, plt.show, range, neighbor.score"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","__init__","The constructor of the search problem.  x: the x coordinate of the current search state. y: the y coordinate of the current search state. step_size: size of the step to take when looking for neighbors. function_to_optimize: a function to optimize having the signature f(x, y).",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","score","Returns the output of the function called with current x and y coordinates. >>> def test_function(x, y): ...     return x + y >>> SearchProblem(0, 0, 1, test_function).score()  # 0 + 0 = 0 0 >>> SearchProblem(5, 7, 1, test_function).score()  # 5 + 7 = 12 12","self.function"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","get_neighbors","Returns a list of coordinates of neighbors adjacent to the current coordinates.  Neighbors: | 0 | 1 | 2 | | 3 | _ | 4 | | 5 | 6 | 7 |","SearchProblem"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","__hash__","hash the string representation of the current search state.","hash, str"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","__eq__","Check if the 2 objects are equal.","isinstance, hash, hash, str, str"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","__str__","string representation of the current search state. >>> str(SearchProblem(0, 0, 1, None)) 'x: 0 y: 0' >>> str(SearchProblem(2, 5, 1, None)) 'x: 2 y: 5'",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","test_f1","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\hill_climbing.py","","test_f2","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\interpolation_search.py","","interpolation_search","Searches for an item in a sorted collection by interpolation search algorithm.  Args:     sorted_collection: sorted list of integers     item: item value to search  Returns:     int: The index of the found item, or None if the item is not found. Examples: >>> interpolation_search([1, 2, 3, 4, 5], 2) 1 >>> interpolation_search([1, 2, 3, 4, 5], 4) 3 >>> interpolation_search([1, 2, 3, 4, 5], 6) is None True >>> interpolation_search([], 1) is None True >>> interpolation_search([100], 100) 0 >>> interpolation_search([1, 2, 3, 4, 5], 0) is None True >>> interpolation_search([1, 2, 3, 4, 5], 7) is None True >>> interpolation_search([1, 2, 3, 4, 5], 2) 1 >>> interpolation_search([1, 2, 3, 4, 5], 0) is None True >>> interpolation_search([1, 2, 3, 4, 5], 7) is None True >>> interpolation_search([1, 2, 3, 4, 5], 2) 1 >>> interpolation_search([5, 5, 5, 5, 5], 3) is None True","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\interpolation_search.py","","interpolation_search_by_recursion","Pure implementation of interpolation search algorithm in Python by recursion Be careful collection must be ascending sorted, otherwise result will be unpredictable First recursion should be started with left=0 and right=(len(sorted_collection)-1)  Args:     sorted_collection: some sorted collection with comparable items     item: item value to search     left: left index in collection     right: right index in collection  Returns:     index of item in collection or None if item is not present  Examples: >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 0) 0 >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 15) 4 >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 5) 1 >>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 100) is None True >>> interpolation_search_by_recursion([5, 5, 5, 5, 5], 3) is None True","interpolation_search_by_recursion, interpolation_search_by_recursion, interpolation_search_by_recursion, interpolation_search_by_recursion, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\jump_search.py","Comparable","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\jump_search.py","","jump_search","Python implementation of the jump search algorithm. Return the index if the `item` is found, otherwise return -1.  Examples: >>> jump_search([0, 1, 2, 3, 4, 5], 3) 3 >>> jump_search([-5, -2, -1], -1) 2 >>> jump_search([0, 5, 10, 20], 8) -1 >>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55) 10 >>> jump_search([""aa"", ""bb"", ""cc"", ""dd"", ""ee"", ""ff""], ""ee"") 4","len, int, math.sqrt, min, min"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\jump_search.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\linear_search.py","","linear_search","A pure Python implementation of a linear search algorithm  :param sequence: a collection with comparable items (as sorted items not required     in Linear Search) :param target: item value to search :return: index of found item or -1 if item is not found  Examples: >>> linear_search([0, 5, 7, 10, 15], 0) 0 >>> linear_search([0, 5, 7, 10, 15], 15) 4 >>> linear_search([0, 5, 7, 10, 15], 5) 1 >>> linear_search([0, 5, 7, 10, 15], 6) -1","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\linear_search.py","","rec_linear_search","A pure Python implementation of a recursive linear search algorithm  :param sequence: a collection with comparable items (as sorted items not required     in Linear Search) :param low: Lower bound of the array :param high: Higher bound of the array :param target: The element to be found :return: Index of the key or -1 if key not found  Examples: >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0) 0 >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700) 4 >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30) 1 >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6) -1","rec_linear_search, Exception, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\median_of_medians.py","","median_of_five","Return the median of the input list :param arr: Array to find median of :return: median of arr  >>> median_of_five([2, 4, 5, 7, 899]) 5 >>> median_of_five([5, 7, 899, 54, 32]) 32 >>> median_of_five([5, 4, 3, 2]) 4 >>> median_of_five([3, 5, 7, 10, 2]) 5","sorted, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\median_of_medians.py","","median_of_medians","Return a pivot to partition data on by calculating Median of medians of input data :param arr: The data to be checked (a list) :return: median of medians of input array  >>> median_of_medians([2, 4, 5, 7, 899, 54, 32]) 54 >>> median_of_medians([5, 7, 899, 54, 32]) 32 >>> median_of_medians([5, 4, 3, 2]) 4 >>> median_of_medians([3, 5, 7, 10, 2, 12]) 12","median_of_medians, len, median_of_five, len, len, medians.append, medians.append, median_of_five, median_of_five, .copy, .copy"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\median_of_medians.py","","quick_select","Two way partition the data into smaller and greater lists, in relationship to the pivot :param arr: The data to be searched (a list) :param target: The rank to be searched :return: element at rank target  >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5) 32 >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1) 2 >>> quick_select([5, 4, 3, 2], 2) 3 >>> quick_select([3, 5, 7, 10, 2, 12], 3) 5","median_of_medians, range, len, len, len, left.append, quick_select, right.append, quick_select, right.append"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\quick_select.py","","_partition","Three way partition the data into smaller, equal and greater lists, in relationship to the pivot :param data: The data to be sorted (a list) :param pivot: The value to partition the data on :return: Three list: smaller, equal and greater","less.append, greater.append, equal.append"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\quick_select.py","","quick_select",">>> quick_select([2, 4, 5, 7, 899, 54, 32], 5) 54 >>> quick_select([2, 4, 5, 7, 899, 54, 32], 1) 4 >>> quick_select([5, 4, 3, 2], 2) 4 >>> quick_select([3, 5, 7, 10, 2, 12], 3) 7","_partition, len, len, random.randint, len, quick_select, quick_select, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\quick_select.py","","median","One common application of Quickselect is finding the median, which is the middle element (or average of the two middle elements) in a sorted dataset. It works efficiently on unsorted lists by partially sorting the data without fully sorting the entire list.  >>> median([3, 2, 2, 9, 9]) 3  >>> median([2, 2, 9, 9, 9, 3]) 6.0","divmod, len, quick_select, quick_select, quick_select"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\sentinel_linear_search.py","","sentinel_linear_search","Pure implementation of sentinel linear search algorithm in Python  :param sequence: some sequence with comparable items :param target: item value to search :return: index of found item or None if item is not found  Examples: >>> sentinel_linear_search([0, 5, 7, 10, 15], 0) 0  >>> sentinel_linear_search([0, 5, 7, 10, 15], 15) 4  >>> sentinel_linear_search([0, 5, 7, 10, 15], 5) 1  >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)","sequence.append, sequence.pop, len"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\simple_binary_search.py","","binary_search",">>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42] >>> binary_search(test_list, 3) False >>> binary_search(test_list, 13) True >>> binary_search([4, 4, 5, 6, 7], 4) True >>> binary_search([4, 4, 5, 6, 7], -10) False >>> binary_search([-18, 2], -18) True >>> binary_search([5], 5) True >>> binary_search(['a', 'c', 'd'], 'c') True >>> binary_search(['a', 'c', 'd'], 'f') False >>> binary_search([], 1) False >>> binary_search([-.1, .1 , .8], .1) True >>> binary_search(range(-5000, 5000, 10), 80) True >>> binary_search(range(-5000, 5000, 10), 1255) False >>> binary_search(range(0, 10000, 5), 2) False","len, len, binary_search, binary_search"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\simulated_annealing.py","","simulated_annealing","Implementation of the simulated annealing algorithm. We start with a given state, find all its neighbors. Pick a random neighbor, if that neighbor improves the solution, we move in that direction, if that neighbor does not improve the solution, we generate a random real number between 0 and 1, if the number is within a certain range (calculated using temperature) we move in that direction, else we pick another neighbor randomly and repeat the process.  Args:     search_prob: The search state at the start.     find_max: If True, the algorithm should find the minimum else the minimum.     max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.     visualization: If True, a matplotlib graph is displayed.     start_temperate: the initial temperate of the system when the program starts.     rate_of_decrease: the rate at which the temperate decreases in each iteration.     threshold_temp: the threshold temperature below which we end the search Returns a search state having the maximum (or minimum) score.","current_state.score, scores.append, current_state.get_neighbors, plt.plot, plt.xlabel, plt.ylabel, plt.show, random.randint, neighbors.pop, range, best_state.score, picked_neighbor.score, len, random.random"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\simulated_annealing.py","","test_f1","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\simulated_annealing.py","","test_f2","",""
"C:/Users/Joseph Dania/Desktop/python_repo\searches\tabu_search.py","","generate_neighbours","Pure implementation of generating a dictionary of neighbors and the cost with each neighbor, given a path file that includes a graph.  :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt) :return dict_of_neighbours: Dictionary with key each node and value a list of lists     with the neighbors of the node and the cost (distance) for each neighbor.  Example of dict_of_neighbours: >>) dict_of_neighbours[a] [[b,20],[c,18],[d,22],[e,26]]  This indicates the neighbors of node (city) 'a', which has neighbor the node 'b' with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and the node 'e' with distance 26.","open, _list.append, .append, _list.append, .append, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split, line.split"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\tabu_search.py","","generate_first_solution","Pure implementation of generating the first solution for the Tabu search to start, with the redundant resolution strategy. That means that we start from the starting node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node (let's assume is node 'c'), then we go to the nearest city of the node 'c', etc. till we have visited all cities and return to the starting node.  :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt) :param dict_of_neighbours: Dictionary with key each node and value a list of lists     with the neighbors of the node and the cost (distance) for each neighbor. :return first_solution: The solution for the first iteration of Tabu search using     the redundant resolution strategy in a list. :return distance_of_first_solution: The total distance that Travelling Salesman     will travel, if he follows the path in first_solution.","first_solution.append, open, f.read, first_solution.append, int, int, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\tabu_search.py","","find_neighborhood","Pure implementation of generating the neighborhood (sorted by total distance of each solution from lowest to highest) of a solution with 1-1 exchange method, that means we exchange each node in a solution with each other node and generating a number of solution named neighborhood.  :param solution: The solution in which we want to find the neighborhood. :param dict_of_neighbours: Dictionary with key each node and value a list of lists     with the neighbors of the node and the cost (distance) for each neighbor. :return neighborhood_of_solution: A list that includes the solutions and the total     distance of each solution (in form of list) that are produced with 1-1 exchange     from the solution that the method took as an input  Example: >>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'], ...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']], ...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']], ...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']], ...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']], ...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]} ...                   )  # doctest: +NORMALIZE_WHITESPACE [['a', 'e', 'b', 'd', 'c', 'a', 90],  ['a', 'c', 'd', 'b', 'e', 'a', 90],  ['a', 'd', 'b', 'c', 'e', 'a', 93],  ['a', 'c', 'b', 'e', 'd', 'a', 102],  ['a', 'c', 'e', 'd', 'b', 'a', 113],  ['a', 'b', 'c', 'd', 'e', 'a', 119]]","neighborhood_of_solution.sort, solution.index, len, solution.index, copy.deepcopy, _tmp.append, neighborhood_of_solution.append, _tmp.index, int"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\tabu_search.py","","tabu_search","Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in Python.  :param first_solution: The solution for the first iteration of Tabu search using     the redundant resolution strategy in a list. :param distance_of_first_solution: The total distance that Travelling Salesman will     travel, if he follows the path in first_solution. :param dict_of_neighbours: Dictionary with key each node and value a list of lists     with the neighbors of the node and the cost (distance) for each neighbor. :param iters: The number of iterations that Tabu search will execute. :param size: The size of Tabu List. :return best_solution_ever: The solution with the lowest distance that occurred     during the execution of Tabu search. :return best_cost: The total distance that Travelling Salesman will travel, if he     follows the path in best_solution ever.","find_neighborhood, len, len, tabu_list.pop, len, tabu_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\tabu_search.py","","main","","generate_neighbours, generate_first_solution, tabu_search, print"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\ternary_search.py","","lin_search","Perform linear search in list. Returns -1 if element is not found.  Parameters ---------- left : int     left index bound. right : int     right index bound. array : List[int]     List of elements to be searched on target : int     Element that is searched  Returns ------- int     index of element that is looked for.  Examples -------- >>> lin_search(0, 4, [4, 5, 6, 7], 7) 3 >>> lin_search(0, 3, [4, 5, 6, 7], 7) -1 >>> lin_search(0, 2, [-18, 2], -18) 0 >>> lin_search(0, 1, [5], 5) 0 >>> lin_search(0, 3, ['a', 'c', 'd'], 'c') 1 >>> lin_search(0, 3, [.1, .4 , -.1], .1) 0 >>> lin_search(0, 3, [.1, .4 , -.1], -.1) 2","range"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\ternary_search.py","","ite_ternary_search","Iterative method of the ternary search algorithm. >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42] >>> ite_ternary_search(test_list, 3) -1 >>> ite_ternary_search(test_list, 13) 4 >>> ite_ternary_search([4, 5, 6, 7], 4) 0 >>> ite_ternary_search([4, 5, 6, 7], -10) -1 >>> ite_ternary_search([-18, 2], -18) 0 >>> ite_ternary_search([5], 5) 0 >>> ite_ternary_search(['a', 'c', 'd'], 'c') 1 >>> ite_ternary_search(['a', 'c', 'd'], 'f') -1 >>> ite_ternary_search([], 1) -1 >>> ite_ternary_search([.1, .4 , -.1], .1) 0","len, lin_search"
"C:/Users/Joseph Dania/Desktop/python_repo\searches\ternary_search.py","","rec_ternary_search","Recursive method of the ternary search algorithm.  >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42] >>> rec_ternary_search(0, len(test_list), test_list, 3) -1 >>> rec_ternary_search(4, len(test_list), test_list, 42) 8 >>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4) 0 >>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10) -1 >>> rec_ternary_search(0, 1, [-18, 2], -18) 0 >>> rec_ternary_search(0, 1, [5], 5) 0 >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c') 1 >>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f') -1 >>> rec_ternary_search(0, 0, [], 1) -1 >>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1) 0","lin_search, rec_ternary_search, rec_ternary_search, rec_ternary_search"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bead_sort.py","","bead_sort",">>> bead_sort([6, 11, 12, 4, 1, 5]) [1, 4, 5, 6, 11, 12]  >>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1]) [1, 2, 3, 4, 5, 6, 7, 8, 9]  >>> bead_sort([5, 0, 4, 3]) [0, 3, 4, 5]  >>> bead_sort([8, 2, 1]) [1, 2, 8]  >>> bead_sort([1, .9, 0.0, 0, -1, -.9]) Traceback (most recent call last):     ... TypeError: Sequence must be list of non-negative integers  >>> bead_sort(""Hello world"") Traceback (most recent call last):     ... TypeError: Sequence must be list of non-negative integers","any, range, TypeError, len, enumerate, zip, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\binary_insertion_sort.py","","binary_insertion_sort","Sorts a list using the binary insertion sort algorithm.  :param collection: A mutable ordered collection with comparable items. :return: The same collection ordered in ascending order.  Examples: >>> binary_insertion_sort([0, 4, 1234, 4, 1]) [0, 1, 4, 4, 1234] >>> binary_insertion_sort([]) == sorted([]) True >>> binary_insertion_sort([-1, -2, -3]) == sorted([-1, -2, -3]) True >>> lst = ['d', 'a', 'b', 'e', 'c'] >>> binary_insertion_sort(lst) == sorted(lst) True >>> import random >>> collection = random.sample(range(-50, 50), 100) >>> binary_insertion_sort(collection) == sorted(collection) True >>> import string >>> collection = random.choices(string.ascii_letters + string.digits, k=100) >>> binary_insertion_sort(collection) == sorted(collection) True","len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bitonic_sort.py","","comp_and_swap","Compare the value at given index1 and index2 of the array and swap them as per the given direction.  The parameter direction indicates the sorting direction, ASCENDING(1) or DESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are interchanged.  >>> arr = [12, 42, -21, 1] >>> comp_and_swap(arr, 1, 2, 1) >>> arr [12, -21, 42, 1]  >>> comp_and_swap(arr, 1, 2, 0) >>> arr [12, 42, -21, 1]  >>> comp_and_swap(arr, 0, 3, 1) >>> arr [1, 42, -21, 12]  >>> comp_and_swap(arr, 0, 3, 0) >>> arr [12, 42, -21, 1]",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bitonic_sort.py","","bitonic_merge","It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in descending if direction = 0. The sequence to be sorted starts at index position low, the parameter length is the number of elements to be sorted.  >>> arr = [12, 42, -21, 1] >>> bitonic_merge(arr, 0, 4, 1) >>> arr [-21, 1, 12, 42]  >>> bitonic_merge(arr, 0, 4, 0) >>> arr [42, 12, 1, -21]","int, range, bitonic_merge, bitonic_merge, comp_and_swap"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bitonic_sort.py","","bitonic_sort","This function first produces a bitonic sequence by recursively sorting its two halves in opposite sorting orders, and then calls bitonic_merge to make them in the same order.  >>> arr = [12, 34, 92, -23, 0, -121, -167, 145] >>> bitonic_sort(arr, 0, 8, 1) >>> arr [-167, -121, -23, 0, 12, 34, 92, 145]  >>> bitonic_sort(arr, 0, 8, 0) >>> arr [145, 92, 34, 12, 0, -23, -121, -167]","int, bitonic_sort, bitonic_sort, bitonic_merge"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bogo_sort.py","","bogo_sort","Pure implementation of the bogosort algorithm in Python :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending Examples: >>> bogo_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> bogo_sort([]) [] >>> bogo_sort([-2, -5, -45]) [-45, -5, -2]","range, is_sorted, random.shuffle, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bogo_sort.py","","is_sorted","","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bubble_sort.py","","bubble_sort_iterative","Pure implementation of bubble sort algorithm in Python  :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending  Examples: >>> bubble_sort_iterative([0, 5, 2, 3, 2]) [0, 2, 2, 3, 5] >>> bubble_sort_iterative([]) [] >>> bubble_sort_iterative([-2, -45, -5]) [-45, -5, -2] >>> bubble_sort_iterative([-23, 0, 6, -4, 34]) [-23, -4, 0, 6, 34] >>> bubble_sort_iterative([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2]) True >>> bubble_sort_iterative([]) == sorted([]) True >>> bubble_sort_iterative([-2, -45, -5]) == sorted([-2, -45, -5]) True >>> bubble_sort_iterative([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34]) True >>> bubble_sort_iterative(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e']) True >>> bubble_sort_iterative(['z', 'a', 'y', 'b', 'x', 'c']) ['a', 'b', 'c', 'x', 'y', 'z'] >>> bubble_sort_iterative([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6]) [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7] >>> bubble_sort_iterative([1, 3.3, 5, 7.7, 2, 4.4, 6]) [1, 2, 3.3, 4.4, 5, 6, 7.7] >>> import random >>> collection_arg = random.sample(range(-50, 50), 100) >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg) True >>> import string >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100) >>> bubble_sort_iterative(collection_arg) == sorted(collection_arg) True","len, reversed, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bubble_sort.py","","bubble_sort_recursive","It is similar iterative bubble sort but recursive.  :param collection: mutable ordered sequence of elements :return: the same list in ascending order  Examples: >>> bubble_sort_recursive([0, 5, 2, 3, 2]) [0, 2, 2, 3, 5] >>> bubble_sort_iterative([]) [] >>> bubble_sort_recursive([-2, -45, -5]) [-45, -5, -2] >>> bubble_sort_recursive([-23, 0, 6, -4, 34]) [-23, -4, 0, 6, 34] >>> bubble_sort_recursive([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2]) True >>> bubble_sort_recursive([]) == sorted([]) True >>> bubble_sort_recursive([-2, -45, -5]) == sorted([-2, -45, -5]) True >>> bubble_sort_recursive([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34]) True >>> bubble_sort_recursive(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e']) True >>> bubble_sort_recursive(['z', 'a', 'y', 'b', 'x', 'c']) ['a', 'b', 'c', 'x', 'y', 'z'] >>> bubble_sort_recursive([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6]) [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7] >>> bubble_sort_recursive([1, 3.3, 5, 7.7, 2, 4.4, 6]) [1, 2, 3.3, 4.4, 5, 6, 7.7] >>> bubble_sort_recursive(['a', 'Z', 'B', 'C', 'A', 'c']) ['A', 'B', 'C', 'Z', 'a', 'c'] >>> import random >>> collection_arg = random.sample(range(-50, 50), 100) >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg) True >>> import string >>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100) >>> bubble_sort_recursive(collection_arg) == sorted(collection_arg) True","len, range, bubble_sort_recursive"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\bucket_sort.py","","bucket_sort",">>> data = [-1, 2, -5, 0] >>> bucket_sort(data) == sorted(data) True >>> data = [9, 8, 7, 6, -12] >>> bucket_sort(data) == sorted(data) True >>> data = [.4, 1.2, .1, .2, -.9] >>> bucket_sort(data) == sorted(data) True >>> bucket_sort([]) == sorted([]) True >>> data = [-1e10, 1e10] >>> bucket_sort(data) == sorted(data) True >>> import random >>> collection = random.sample(range(-50, 50), 50) >>> bucket_sort(collection) == sorted(collection) True >>> data = [1, 2, 2, 1, 1, 3] >>> bucket_sort(data) == sorted(data) True >>> data = [5, 5, 5, 5, 5] >>> bucket_sort(data) == sorted(data) True >>> data = [1000, -1000, 500, -500, 0] >>> bucket_sort(data) == sorted(data) True >>> data = [5.5, 2.2, -1.1, 3.3, 0.0] >>> bucket_sort(data) == sorted(data) True >>> bucket_sort([1]) == [1] True >>> data = [-1.1, -1.5, -3.4, 2.5, 3.6, -3.3] >>> bucket_sort(data) == sorted(data) True >>> data = [9, 2, 7, 1, 5] >>> bucket_sort(data) == sorted(data) True","min, max, min, .append, len, range, int, sorted"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\circle_sort.py","","circle_sort","A pure Python implementation of circle sort algorithm  :param collection: a mutable collection of comparable items in any order :return: the same collection in ascending order  Examples: >>> circle_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> circle_sort([]) [] >>> circle_sort([-2, 5, 0, -45]) [-45, -2, 0, 5] >>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45]) >>> all(sorted(collection) == circle_sort(collection) for collection in collections) True","len, circle_sort_util, circle_sort_util, circle_sort_util, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\circle_sort.py","","circle_sort_util",">>> arr = [5,4,3,2,1] >>> circle_sort_util(lst, 0, 2) True >>> arr [3, 4, 5, 2, 1]","circle_sort_util, circle_sort_util, int"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\cocktail_shaker_sort.py","","cocktail_shaker_sort","Sorts a list using the Cocktail Shaker Sort algorithm.  :param arr: List of elements to be sorted. :return: Sorted list.  >>> cocktail_shaker_sort([4, 5, 2, 1, 2]) [1, 2, 2, 4, 5] >>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11]) [-4, 0, 1, 2, 5, 11] >>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2]) [-2.4, 0.1, 2.2, 4.4] >>> cocktail_shaker_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> cocktail_shaker_sort([-4, -5, -24, -7, -11]) [-24, -11, -7, -5, -4] >>> cocktail_shaker_sort([""elderberry"", ""banana"", ""date"", ""apple"", ""cherry""]) ['apple', 'banana', 'cherry', 'date', 'elderberry'] >>> cocktail_shaker_sort((-4, -5, -24, -7, -11)) Traceback (most recent call last):     ... TypeError: 'tuple' object does not support item assignment","range, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\comb_sort.py","","comb_sort","Pure implementation of comb sort algorithm in Python :param data: mutable collection with comparable items :return: the same collection in ascending order Examples: >>> comb_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> comb_sort([]) [] >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3]) [-15, -7, 0, 2, 3, 8, 45, 99]","len, int, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\counting_sort.py","","counting_sort","Pure implementation of counting sort algorithm in Python :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending Examples: >>> counting_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> counting_sort([]) [] >>> counting_sort([-2, -5, -45]) [-45, -5, -2]","len, max, min, range, reversed, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\counting_sort.py","","counting_sort_string",">>> counting_sort_string(""thisisthestring"") 'eghhiiinrsssttt'",".join, chr, counting_sort, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\cycle_sort.py","","cycle_sort",">>> cycle_sort([4, 3, 2, 1]) [1, 2, 3, 4]  >>> cycle_sort([-4, 20, 0, -50, 100, -1]) [-50, -4, -1, 0, 20, 100]  >>> cycle_sort([-.1, -.2, 1.3, -.8]) [-0.8, -0.2, -0.1, 1.3]  >>> cycle_sort([]) []","len, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\cyclic_sort.py","","cyclic_sort","Sorts the input list of n integers from 1 to n in-place using the Cyclic Sort algorithm.  :param nums: List of n integers from 1 to n to be sorted. :return: The same list sorted in ascending order.  Time complexity: O(n), where n is the number of integers in the list.  Examples: >>> cyclic_sort([]) [] >>> cyclic_sort([3, 5, 2, 1, 4]) [1, 2, 3, 4, 5]","len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\double_sort.py","","double_sort","This sorting algorithm sorts an array using the principle of bubble sort, but does it both from left to right and right to left. Hence, it's called ""Double sort"" :param collection: mutable ordered sequence of elements :return: the same collection in ascending order Examples: >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7]) [-7, -6, -5, -4, -3, -2, -1] >>> double_sort([]) [] >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6]) [-6, -5, -4, -3, -2, -1] >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29]) True","len, range, int, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\dutch_national_flag_sort.py","","dutch_national_flag_sort","A pure Python implementation of Dutch National Flag sort algorithm. :param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence :return: The same collection in ascending order  >>> dutch_national_flag_sort([]) [] >>> dutch_national_flag_sort([0]) [0] >>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2]) [0, 0, 1, 1, 2, 2] >>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1]) [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2] >>> dutch_national_flag_sort(""abacab"") Traceback (most recent call last):   ... ValueError: The elements inside the sequence must contains only (0, 1, 2) values >>> dutch_national_flag_sort(""Abacab"") Traceback (most recent call last):   ... ValueError: The elements inside the sequence must contains only (0, 1, 2) values >>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3]) Traceback (most recent call last):   ... ValueError: The elements inside the sequence must contains only (0, 1, 2) values >>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1]) Traceback (most recent call last):   ... ValueError: The elements inside the sequence must contains only (0, 1, 2) values >>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1]) Traceback (most recent call last):   ... ValueError: The elements inside the sequence must contains only (0, 1, 2) values","len, list, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\exchange_sort.py","","exchange_sort","Uses exchange sort to sort a list of numbers. Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort >>> exchange_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> exchange_sort([-1, -2, -3]) [-3, -2, -1] >>> exchange_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> exchange_sort([0, 10, -2, 5, 3]) [-2, 0, 3, 5, 10] >>> exchange_sort([]) []","len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","FileSplitter","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","NWayMerge","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","FilesArray","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","FileMerger","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","ExternalSort","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","parse_memory","",".lower, int, .lower, .lower, int, int, int"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","main","","argparse.ArgumentParser, parser.add_argument, parser.add_argument, parser.parse_args, ExternalSort, sorter.sort, parse_memory"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","write_block","","self.BLOCK_FILENAME_FORMAT.format, self.block_filenames.append, open, file.write"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","get_block_filenames","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","split","","open, file.readlines, self.write_block, lines.sort, lines.sort, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","cleanup","","map"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","select","","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","__init__","","set, len, dict.fromkeys, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","get_dict","","range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","refresh","","range, len, .readline, self.empty.add, .close"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","unshift","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","merge","","FilesArray, self.get_file_handles, open, buffers.refresh, self.merge_strategy.select, outfile.write, buffers.get_dict, buffers.unshift"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","get_file_handles","","range, len, open"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","sort","","self.get_number_blocks, FileSplitter, splitter.split, FileMerger, merger.merge, splitter.cleanup, NWayMerge, splitter.get_block_filenames"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\external_sort.py","","get_number_blocks","","os.stat"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\gnome_sort.py","","gnome_sort","Pure implementation of the gnome sort algorithm in Python  Take some mutable ordered collection with heterogeneous comparable items inside as arguments, return the same collection ordered by ascending.  Examples: >>> gnome_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]  >>> gnome_sort([]) []  >>> gnome_sort([-2, -5, -45]) [-45, -5, -2]  >>> """".join(gnome_sort(list(set(""Gnomes are stupid!"")))) ' !Gadeimnoprstu'","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\heap_sort.py","","heapify",":param unsorted: unsorted list containing integers numbers :param index: index :param heap_size: size of the heap :return: None >>> unsorted = [1, 4, 3, 5, 2] >>> heapify(unsorted, 0, len(unsorted)) >>> unsorted [4, 5, 3, 1, 2] >>> heapify(unsorted, 0, len(unsorted)) >>> unsorted [5, 4, 3, 1, 2]","heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\heap_sort.py","","heap_sort","A pure Python implementation of the heap sort algorithm  :param collection: a mutable ordered collection of heterogeneous comparable items :return: the same collection ordered by ascending  Examples: >>> heap_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> heap_sort([]) [] >>> heap_sort([-2, -5, -45]) [-45, -5, -2] >>> heap_sort([3, 7, 9, 28, 123, -5, 8, -30, -200, 0, 4]) [-200, -30, -5, 0, 3, 4, 7, 8, 9, 28, 123]","len, range, range, heapify, heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\insertion_sort.py","Comparable","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\insertion_sort.py","","insertion_sort","A pure Python implementation of the insertion sort algorithm  :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending  Examples: >>> insertion_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> insertion_sort([]) == sorted([]) True >>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45]) True >>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c']) True >>> import random >>> collection = random.sample(range(-50, 50), 100) >>> insertion_sort(collection) == sorted(collection) True >>> import string >>> collection = random.choices(string.ascii_letters + string.digits, k=100) >>> insertion_sort(collection) == sorted(collection) True","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\insertion_sort.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","insertion_sort",">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12] >>> insertion_sort(array, 0, len(array)) [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79] >>> array = [21, 15, 11, 45, -2, -11, 46] >>> insertion_sort(array, 0, len(array)) [-11, -2, 11, 15, 21, 45, 46] >>> array = [-2, 0, 89, 11, 48, 79, 12] >>> insertion_sort(array, 0, len(array)) [-2, 0, 11, 12, 48, 79, 89] >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o'] >>> insertion_sort(array, 0, len(array)) ['a', 'd', 'l', 'o', 'o', 'p', 'v', 'z'] >>> array = [73.568, 73.56, -45.03, 1.7, 0, 89.45] >>> insertion_sort(array, 0, len(array)) [-45.03, 0, 1.7, 73.56, 73.568, 89.45]","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","heapify",">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12] >>> heapify(array, len(array) // 2, len(array))","heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","heap_sort",">>> heap_sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]) [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79] >>> heap_sort([-2, -11, 0, 0, 0, 87, 45, -69, 78, 12, 10, 103, 89, 52]) [-69, -11, -2, 0, 0, 0, 10, 12, 45, 52, 78, 87, 89, 103] >>> heap_sort(['b', 'd', 'e', 'f', 'g', 'p', 'x', 'z', 'b', 's', 'e', 'u', 'v']) ['b', 'b', 'd', 'e', 'e', 'f', 'g', 'p', 's', 'u', 'v', 'x', 'z'] >>> heap_sort([6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7]) [-457.0, -45.54, 0, 1, 1.7, 2.879, 6.2, 11.7, 758.56, 8465.2]","len, range, range, heapify, heapify"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","median_of_3",">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12] >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1) 12 >>> array = [13, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12] >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1) 13 >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 15, 14, 27, 79, 23, 45, 14, 16] >>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1) 14",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","partition",">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12] >>> partition(array, 0, len(array), 12) 8 >>> array = [21, 15, 11, 45, -2, -11, 46] >>> partition(array, 0, len(array), 15) 3 >>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o'] >>> partition(array, 0, len(array), 'p') 5 >>> array = [6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7] >>> partition(array, 0, len(array), 2.879) 6",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","sort",":param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending  Examples: >>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]) [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79] >>> sort([-1, -5, -3, -13, -44]) [-44, -13, -5, -3, -1] >>> sort([]) [] >>> sort([5]) [5] >>> sort([-3, 0, -7, 6, 23, -34]) [-34, -7, -3, 0, 6, 23] >>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ]) [0.3, 1.0, 1.7, 2.1, 3.3] >>> sort(['d', 'a', 'b', 'e', 'c']) ['a', 'b', 'c', 'd', 'e']","intro_sort, len, math.ceil, len, math.log2, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\intro_sort.py","","intro_sort",">>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12] >>> max_depth = 2 * math.ceil(math.log2(len(array))) >>> intro_sort(array, 0, len(array), 16, max_depth) [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]","insertion_sort, median_of_3, partition, intro_sort, heap_sort"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\iterative_merge_sort.py","","merge","sorting left-half and right-half individually then merging them into result","result.append, .pop"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\iterative_merge_sort.py","","iter_merge_sort","Return a sorted copy of the input list  >>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7]) [1, 2, 5, 7, 7, 8, 9] >>> iter_merge_sort([1]) [1] >>> iter_merge_sort([2, 1]) [1, 2] >>> iter_merge_sort([2, 1, 3]) [1, 2, 3] >>> iter_merge_sort([4, 3, 2, 1]) [1, 2, 3, 4] >>> iter_merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> iter_merge_sort(['c', 'b', 'a']) ['a', 'b', 'c'] >>> iter_merge_sort([0.3, 0.2, 0.1]) [0.1, 0.2, 0.3] >>> iter_merge_sort(['dep', 'dang', 'trai']) ['dang', 'dep', 'trai'] >>> iter_merge_sort([6]) [6] >>> iter_merge_sort([]) [] >>> iter_merge_sort([-2, -9, -1, -4]) [-9, -4, -2, -1] >>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1]) [-1.1, -1, 0.0, 1, 1.1] >>> iter_merge_sort(['c', 'b', 'a']) ['a', 'b', 'c'] >>> iter_merge_sort('cba') ['a', 'b', 'c']","list, len, len, range, len, merge, len, merge, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\merge_insertion_sort.py","","binary_search_insertion",">>> binary_search_insertion([1, 2, 7, 9, 10], 4) [1, 2, 4, 7, 9, 10]","sorted_list.insert, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\merge_insertion_sort.py","","merge",">>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]]) [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]","result.append, result.append, left.pop, right.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\merge_insertion_sort.py","","sortlist_2d",">>> sortlist_2d([[9, 10], [1, 6], [7, 8], [2, 3], [4, 5]]) [[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]","len, merge, sortlist_2d, sortlist_2d"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\merge_insertion_sort.py","","merge_insertion_sort","Pure implementation of merge-insertion sort algorithm in Python  :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending  Examples: >>> merge_insertion_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]  >>> merge_insertion_sort([99]) [99]  >>> merge_insertion_sort([-2, -5, -45]) [-45, -5, -2]  Testing with all permutations on range(0,5): >>> import itertools >>> permutations = list(itertools.permutations([0, 1, 2, 3, 4])) >>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations) True","range, sortlist_2d, result.append, range, len, len, binary_search_insertion, len, len, two_paired_list.append, two_paired_list.append, binary_search_insertion, binary_search_insertion"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\merge_sort.py","","merge_sort","Sorts a list using the merge sort algorithm.  :param collection: A mutable ordered collection with comparable items. :return: The same collection ordered in ascending order.  Time Complexity: O(n log n) Space Complexity: O(n)  Examples: >>> merge_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> merge_sort([]) [] >>> merge_sort([-2, -5, -45]) [-45, -5, -2]","merge, result.extend, result.extend, len, len, merge_sort, merge_sort, result.append, left.pop, right.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\merge_sort.py","","merge","Merge two sorted lists into a single sorted list.  :param left: Left collection :param right: Right collection :return: Merged result","result.extend, result.extend, result.append, left.pop, right.pop"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\msd_radix_sort.py","","msd_radix_sort","Implementation of the MSD radix sort algorithm. Only works with positive integers :param list_of_ints: A list of integers :return: Returns the sorted list >>> msd_radix_sort([40, 12, 1, 100, 4]) [1, 4, 12, 40, 100] >>> msd_radix_sort([]) [] >>> msd_radix_sort([123, 345, 123, 80]) [80, 123, 123, 345] >>> msd_radix_sort([1209, 834598, 1, 540402, 45]) [1, 45, 1209, 540402, 834598] >>> msd_radix_sort([-1, 34, 45]) Traceback (most recent call last):     ... ValueError: All numbers must be positive","max, _msd_radix_sort, min, ValueError, len, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\msd_radix_sort.py","","_msd_radix_sort","Sort the given list based on the bit at bit_position. Numbers with a 0 at that position will be at the start of the list, numbers with a 1 at the end. :param list_of_ints: A list of integers :param bit_position: the position of the bit that gets compared :return: Returns a partially sorted list >>> _msd_radix_sort([45, 2, 32], 1) [2, 32, 45] >>> _msd_radix_sort([10, 4, 12], 2) [4, 12, 10]","_msd_radix_sort, _msd_radix_sort, res.extend, len, ones.append, zeros.append"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\msd_radix_sort.py","","msd_radix_sort_inplace","Inplace implementation of the MSD radix sort algorithm. Sorts based on the binary representation of the integers. >>> lst = [1, 345, 23, 89, 0, 3] >>> msd_radix_sort_inplace(lst) >>> lst == sorted(lst) True >>> lst = [1, 43, 0, 0, 0, 24, 3, 3] >>> msd_radix_sort_inplace(lst) >>> lst == sorted(lst) True >>> lst = [] >>> msd_radix_sort_inplace(lst) >>> lst == [] True >>> lst = [-1, 34, 23, 4, -42] >>> msd_radix_sort_inplace(lst) Traceback (most recent call last):     ... ValueError: All numbers must be positive","len, max, _msd_radix_sort_inplace, min, ValueError, len, bin"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\msd_radix_sort.py","","_msd_radix_sort_inplace","Sort the given list based on the bit at bit_position. Numbers with a 0 at that position will be at the start of the list, numbers with a 1 at the end. >>> lst = [45, 2, 32, 24, 534, 2932] >>> _msd_radix_sort_inplace(lst, 1, 0, 3) >>> lst == [32, 2, 45, 24, 534, 2932] True >>> lst = [0, 2, 1, 3, 12, 10, 4, 90, 54, 2323, 756] >>> _msd_radix_sort_inplace(lst, 2, 4, 7) >>> lst == [0, 2, 1, 3, 12, 4, 10, 90, 54, 2323, 756] True","_msd_radix_sort_inplace, _msd_radix_sort_inplace"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\natural_sort.py","","natural_sort","Sort the given list of strings in the way that humans expect.  The normal Python sort algorithm sorts lexicographically, so you might not get the results that you expect...  >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in'] >>> sorted(example1) ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in'] >>> # The natural sort algorithm sort based on meaning and not computer code point. >>> natural_sort(example1) ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']  >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9'] >>> sorted(example2) ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9'] >>> natural_sort(example2) ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']","sorted, s.isdigit, int, s.lower, re.split"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\natural_sort.py","","alphanum_key","","s.isdigit, int, s.lower, re.split"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\odd_even_sort.py","","odd_even_sort","Sort input with odd even sort.  This algorithm uses the same idea of bubblesort, but by first dividing in two phase (odd and even). Originally developed for use on parallel processors with local interconnections. :param collection: mutable ordered sequence of elements :return: same collection in ascending order Examples: >>> odd_even_sort([5 , 4 ,3 ,2 ,1]) [1, 2, 3, 4, 5] >>> odd_even_sort([]) [] >>> odd_even_sort([-10 ,-1 ,10 ,2]) [-10, -1, 2, 10] >>> odd_even_sort([1 ,2 ,3 ,4]) [1, 2, 3, 4]","range, range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\odd_even_transposition_parallel.py","","oe_process","","multiprocessing_context.Lock, range, .send, min, .send, .recv, max, .send, .recv"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\odd_even_transposition_parallel.py","","odd_even_transposition",">>> odd_even_transposition(list(range(10)[::-1])) == sorted(list(range(10)[::-1])) True >>> odd_even_transposition([""a"", ""x"", ""c""]) == sorted([""x"", ""a"", ""c""]) True >>> odd_even_transposition([1.9, 42.0, 2.8]) == sorted([1.9, 42.0, 2.8]) True >>> odd_even_transposition([False, True, False]) == sorted([False, False, True]) True >>> odd_even_transposition([1, 32.0, 9]) == sorted([False, False, True]) False >>> odd_even_transposition([1, 32.0, 9]) == sorted([1.0, 32, 9.0]) True >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429] >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list) True >>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429] >>> odd_even_transposition(unsorted_list) == sorted(unsorted_list + [1]) False","mp.get_context, multiprocessing_context.Pipe, multiprocessing_context.Pipe, process_array_.append, range, process_array_.append, range, result_pipe.append, multiprocessing_context.Process, multiprocessing_context.Pipe, multiprocessing_context.Pipe, process_array_.append, multiprocessing_context.Process, p.start, len, .recv, .join, multiprocessing_context.Pipe, len, multiprocessing_context.Process, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\odd_even_transposition_parallel.py","","main","","list, print, print, odd_even_transposition, print, print, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\odd_even_transposition_single_threaded.py","","odd_even_transposition",">>> odd_even_transposition([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5]  >>> odd_even_transposition([13, 11, 18, 0, -1]) [-1, 0, 11, 13, 18]  >>> odd_even_transposition([-.1, 1.1, .1, -2.9]) [-2.9, -0.1, 0.1, 1.1]","len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\pancake_sort.py","","pancake_sort","Sort Array with Pancake Sort. :param arr: Collection containing comparable items :return: Collection ordered in ascending order of items Examples: >>> pancake_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> pancake_sort([]) [] >>> pancake_sort([-2, -5, -45]) [-45, -5, -2]","len, arr.index, max, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\patience_sort.py","Stack","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\patience_sort.py","","patience_sort","A pure implementation of patience sort algorithm in Python  :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: the same collection ordered by ascending  Examples: >>> patience_sort([1, 9, 5, 21, 17, 6]) [1, 5, 6, 9, 17, 21]  >>> patience_sort([]) []  >>> patience_sort([-3, -17, -48]) [-48, -17, -3]","merge, Stack, bisect_left, len, .append, stacks.append, reversed"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\patience_sort.py","","__lt__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\patience_sort.py","","__eq__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\pigeonhole_sort.py","","pigeonhole_sort",">>> a = [8, 3, 2, 7, 4, 6, 8] >>> b = sorted(a)  # a nondestructive sort >>> pigeonhole_sort(a)  # a destructive sort >>> a == b True","min, max, range, isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\pigeonhole_sort.py","","main","","pigeonhole_sort, print, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\pigeon_sort.py","","pigeon_sort","Implementation of pigeon hole sort algorithm :param array: Collection of comparable items :return: Collection sorted in ascending order >>> pigeon_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> pigeon_sort([]) [] >>> pigeon_sort([-2, -5, -45]) [-45, -5, -2]","range, len, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\quick_sort.py","","quick_sort","A pure Python implementation of quicksort algorithm.  :param collection: a mutable collection of comparable items :return: the same collection ordered in ascending order  Examples: >>> quick_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> quick_sort([]) [] >>> quick_sort([-2, 5, 0, -45]) [-45, -2, 0, 5]","randrange, collection.pop, len, len, quick_sort, quick_sort"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\quick_sort_3_partition.py","","quick_sort_3partition",""" Python implementation of quick sort algorithm with 3-way partition. The idea of 3-way quick sort is based on ""Dutch National Flag algorithm"".  :param sorting: sort list :param left: left endpoint of sorting :param right: right endpoint of sorting :return: None  Examples: >>> array1 = [5, -1, -1, 5, 5, 24, 0] >>> quick_sort_3partition(array1, 0, 6) >>> array1 [-1, -1, 0, 5, 5, 5, 24] >>> array2 = [9, 0, 2, 6] >>> quick_sort_3partition(array2, 0, 3) >>> array2 [0, 2, 6, 9] >>> array3 = [] >>> quick_sort_3partition(array3, 0, 0) >>> array3 []","quick_sort_3partition, quick_sort_3partition"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\quick_sort_3_partition.py","","quick_sort_lomuto_partition","A pure Python implementation of quick sort algorithm(in-place) with Lomuto partition scheme: https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme  :param sorting: sort list :param left: left endpoint of sorting :param right: right endpoint of sorting :return: None  Examples: >>> nums1 = [0, 5, 3, 1, 2] >>> quick_sort_lomuto_partition(nums1, 0, 4) >>> nums1 [0, 1, 2, 3, 5] >>> nums2 = [] >>> quick_sort_lomuto_partition(nums2, 0, 0) >>> nums2 [] >>> nums3 = [-2, 5, 0, -4] >>> quick_sort_lomuto_partition(nums3, 0, 3) >>> nums3 [-4, -2, 0, 5]","lomuto_partition, quick_sort_lomuto_partition, quick_sort_lomuto_partition"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\quick_sort_3_partition.py","","lomuto_partition","Example: >>> lomuto_partition([1,5,7,6], 0, 3) 2","range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\quick_sort_3_partition.py","","three_way_radix_quicksort","Three-way radix quicksort: https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort First divide the list into three parts. Then recursively sort the ""less than"" and ""greater than"" partitions.  >>> three_way_radix_quicksort([]) [] >>> three_way_radix_quicksort([1]) [1] >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1]) [-5, -2, -2, 0, 1, 1] >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1]) [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]","len, three_way_radix_quicksort, three_way_radix_quicksort"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\radix_sort.py","","radix_sort","Examples: >>> radix_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]  >>> radix_sort(list(range(15))) == sorted(range(15)) True >>> radix_sort(list(range(14,-1,-1))) == sorted(range(15)) True >>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000]) True","max, range, int, .append, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\recursive_insertion_sort.py","","rec_insertion_sort","Given a collection of numbers and its length, sorts the collections in ascending order  :param collection: A mutable collection of comparable elements :param n: The length of collections  >>> col = [1, 2, 1] >>> rec_insertion_sort(col, len(col)) >>> col [1, 1, 2]  >>> col = [2, 1, 0, -1, -2] >>> rec_insertion_sort(col, len(col)) >>> col [-2, -1, 0, 1, 2]  >>> col = [1] >>> rec_insertion_sort(col, len(col)) >>> col [1]","insert_next, rec_insertion_sort, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\recursive_insertion_sort.py","","insert_next","Inserts the '(index-1)th' element into place  >>> col = [3, 2, 4, 2] >>> insert_next(col, 1) >>> col [2, 3, 4, 2]  >>> col = [3, 2, 3] >>> insert_next(col, 2) >>> col [3, 2, 3]  >>> col = [] >>> insert_next(col, 1) >>> col []","insert_next, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\recursive_mergesort_array.py","","merge","Return a sorted array. >>> merge([10,9,8,7,6,5,4,3,2,1]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge([1,2,3,4,5,6,7,8,9,10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge([10,22,1,2,3,9,15,23]) [1, 2, 3, 9, 10, 15, 22, 23] >>> merge([100]) [100] >>> merge([]) []","len, len, len, merge, merge, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\recursive_quick_sort.py","","quick_sort",">>> for data in ([2, 1, 0], [2.2, 1.1, 0], ""quick_sort""): ...     quick_sort(data) == sorted(data) True True True","len, quick_sort, quick_sort"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\selection_sort.py","","selection_sort","Sorts a list in ascending order using the selection sort algorithm.  :param collection: A list of integers to be sorted. :return: The sorted list.  Examples: >>> selection_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]  >>> selection_sort([]) []  >>> selection_sort([-2, -5, -45]) [-45, -5, -2]","len, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\shell_sort.py","","shell_sort","Pure implementation of shell sort algorithm in Python :param collection:  Some mutable ordered collection with heterogeneous comparable items inside :return:  the same collection ordered by ascending  >>> shell_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5] >>> shell_sort([]) [] >>> shell_sort([-2, -5, -45]) [-45, -5, -2]","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\shrink_shell_sort.py","","shell_sort","Implementation of shell sort algorithm in Python :param collection:  Some mutable ordered collection with heterogeneous comparable items inside :return:  the same collection ordered by ascending  >>> shell_sort([3, 2, 1]) [1, 2, 3] >>> shell_sort([]) [] >>> shell_sort([1]) [1]","len, int, range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\slowsort.py","","slowsort","Sorts sequence[start..end] (both inclusive) in-place. start defaults to 0 if not given. end defaults to len(sequence) - 1 if not given. It returns None. >>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq [1, 2, 3, 4, 4, 5, 5, 6] >>> seq = []; slowsort(seq); seq [] >>> seq = [2]; slowsort(seq); seq [2] >>> seq = [1, 2, 3, 4]; slowsort(seq); seq [1, 2, 3, 4] >>> seq = [4, 3, 2, 1]; slowsort(seq); seq [1, 2, 3, 4] >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq [9, 8, 2, 3, 4, 5, 6, 7, 1, 0] >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq [5, 6, 7, 8, 9, 4, 3, 2, 1, 0] >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]","slowsort, slowsort, slowsort, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\stalin_sort.py","","stalin_sort","Sorts a list using the Stalin sort algorithm.  >>> stalin_sort([4, 3, 5, 2, 1, 7]) [4, 5, 7]  >>> stalin_sort([1, 2, 3, 4]) [1, 2, 3, 4]  >>> stalin_sort([4, 5, 5, 2, 3]) [4, 5, 5]  >>> stalin_sort([6, 11, 12, 4, 1, 5]) [6, 11, 12]  >>> stalin_sort([5, 0, 4, 3]) [5]  >>> stalin_sort([5, 4, 3, 2, 1]) [5]  >>> stalin_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]  >>> stalin_sort([1, 2, 8, 7, 6]) [1, 2, 8]","result.append"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\stooge_sort.py","","stooge_sort","Examples: >>> stooge_sort([18.1, 0, -7.1, -1, 2, 2]) [-7.1, -1, 0, 2, 2, 18.1]  >>> stooge_sort([]) []","stooge, len"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\stooge_sort.py","","stooge","","int, stooge, stooge, stooge"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\strand_sort.py","","strand_sort","Strand sort implementation source: https://en.wikipedia.org/wiki/Strand_sort  :param arr: Unordered input list :param reverse: Descent ordering flag :param solution: Ordered items container  Examples: >>> strand_sort([4, 2, 5, 3, 0, 1]) [0, 1, 2, 3, 4, 5]  >>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True) [5, 4, 3, 2, 1, 0]","enumerate, strand_sort, arr.pop, _operator, solution.extend, sublist.append, arr.pop, sublist.pop, enumerate, solution.append, _operator, solution.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tim_sort.py","","binary_search","","binary_search, binary_search"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tim_sort.py","","insertion_sort","","len, range, binary_search"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tim_sort.py","","merge","","merge, merge"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tim_sort.py","","tim_sort",">>> tim_sort(""Python"") ['P', 'h', 'n', 'o', 't', 'y'] >>> tim_sort((1.1, 1, 0, -1, -1.1)) [-1.1, -1, 0, 1, 1.1] >>> tim_sort(list(reversed(list(range(7))))) [0, 1, 2, 3, 4, 5, 6] >>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1]) True >>> tim_sort([3, 2, 1]) == sorted([3, 2, 1]) True","len, runs.append, sorted_runs.append, merge, runs.append, new_run.append, insertion_sort"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tim_sort.py","","main","","tim_sort, print"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\topological_sort.py","","topological_sort","Perform topological sort on a directed acyclic graph.","visited.append, sort.append, len, len, topological_sort, topological_sort"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tree_sort.py","Node","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tree_sort.py","","tree_sort",">>> tree_sort([]) () >>> tree_sort((1,)) (1,) >>> tree_sort((1, 2)) (1, 2) >>> tree_sort([5, 2, 7]) (2, 5, 7) >>> tree_sort((5, -4, 9, 2, 7)) (-4, 2, 5, 7, 9) >>> tree_sort([5, 6, 1, -1, 4, 37, 2, 7]) (-1, 1, 2, 4, 5, 6, 7, 37)  # >>> tree_sort(range(10, -10, -1)) == tuple(sorted(range(10, -10, -1))) # True","Node, tuple, len, tuple, root.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tree_sort.py","","__iter__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tree_sort.py","","__len__","","sum"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\tree_sort.py","","insert","","Node, self.left.insert, Node, self.right.insert"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\unknown_sort.py","","merge_sort","Pure implementation of the fastest merge sort algorithm in Python  :param collection: some mutable ordered collection with heterogeneous comparable items inside :return: a collection ordered by ascending  Examples: >>> merge_sort([0, 5, 3, 2, 2]) [0, 2, 2, 3, 5]  >>> merge_sort([]) []  >>> merge_sort([-2, -5, -45]) [-45, -5, -2]","end.reverse, len, start.append, end.append, collection.remove, collection.remove, min, max"
"C:/Users/Joseph Dania/Desktop/python_repo\sorts\wiggle_sort.py","","wiggle_sort","Python implementation of wiggle. Example: >>> wiggle_sort([0, 5, 3, 2, 2]) [0, 5, 2, 3, 2] >>> wiggle_sort([]) [] >>> wiggle_sort([-2, -5, -45]) [-45, -2, -5] >>> wiggle_sort([-2.1, -5.68, -45.11]) [-45.11, -2.1, -5.68]","enumerate"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\aho_corasick.py","Automaton","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\aho_corasick.py","","__init__","","self.adlist.append, self.set_fail_transitions, self.add_keyword"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\aho_corasick.py","","find_next_state","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\aho_corasick.py","","add_keyword","",".append, self.find_next_state, self.adlist.append, .append, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\aho_corasick.py","","set_fail_transitions","","deque, q.append, q.popleft, q.append, self.find_next_state, self.find_next_state"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\aho_corasick.py","","search_in",">>> A = Automaton([""what"", ""hat"", ""ver"", ""er""]) >>> A.search_in(""whatever, err ... , wherever"") {'what': [0], 'hat': [1], 'ver': [5, 25], 'er': [6, 10, 22, 26]}","range, len, self.find_next_state, self.find_next_state, .append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\alternative_string_arrange.py","","alternative_string_arrange","Return the alternative arrangements of the two strings. :param first_str: :param second_str: :return: String >>> alternative_string_arrange(""ABCD"", ""XY"") 'AXBYCD' >>> alternative_string_arrange(""XY"", ""ABCD"") 'XAYBCD' >>> alternative_string_arrange(""AB"", ""XYZ"") 'AXBYZ' >>> alternative_string_arrange(""ABC"", """") 'ABC'","len, len, range, .join, output_list.append, output_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\anagrams.py","","signature","Return a word's frequency-based signature.  >>> signature(""test"") 'e1s1t2' >>> signature(""this is a test"") ' 3a1e1h1i2s3t3' >>> signature(""finaltest"") 'a1e1f1i1l1n1s1t2'","collections.Counter, .join, sorted, frequencies.items"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\anagrams.py","","anagram","Return every anagram of the given word from the dictionary.  >>> anagram('test') ['sett', 'stet', 'test'] >>> anagram('this is a test') [] >>> anagram('final') ['final']","signature"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","Trie","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","","autocomplete_using_trie",">>> trie = Trie() >>> for word in words: ...     trie.insert_word(word) ... >>> matches = autocomplete_using_trie(""de"") >>> ""detergent "" in matches True >>> ""dog "" in matches False","trie.find_word, tuple"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","","main","","print, autocomplete_using_trie"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","","insert_word","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","","find_word","","self._elements"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\autocomplete_using_trie.py","","_elements","","d.items, tuple, result.extend, self._elements"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\barcode_validator.py","","get_check_digit","Returns the last digit of barcode by excluding the last digit first and then computing to reach the actual last digit from the remaining 12 digits.  >>> get_check_digit(8718452538119) 9 >>> get_check_digit(87184523) 5 >>> get_check_digit(87193425381086) 9 >>> [get_check_digit(x) for x in range(0, 100, 10)] [0, 7, 4, 1, 8, 5, 2, 9, 6, 3]",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\barcode_validator.py","","is_valid","Checks for length of barcode and last-digit Returns boolean value of validity of barcode  >>> is_valid(8718452538119) True >>> is_valid(87184525) False >>> is_valid(87193425381089) False >>> is_valid(0) False >>> is_valid(dwefgiweuf) Traceback (most recent call last):     ... NameError: name 'dwefgiweuf' is not defined","len, get_check_digit, str"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\barcode_validator.py","","get_barcode","Returns the barcode as an integer  >>> get_barcode(""8718452538119"") 8718452538119 >>> get_barcode(""dwefgiweuf"") Traceback (most recent call last):     ... ValueError: Barcode 'dwefgiweuf' has alphabetic characters.",".isalpha, ValueError, str, int, ValueError, int"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\bitap_string_match.py","","bitap_string_match","Retrieves the index of the first occurrence of pattern in text.  Args:     text: A string consisting only of lowercase alphabetical characters.     pattern: A string consisting only of lowercase alphabetical characters.  Returns:     int: The index where pattern first occurs. Return -1  if not found.  >>> bitap_string_match('abdabababc', 'ababc') 5 >>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a') 0 >>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso') 0 >>> bitap_string_match('abdabababc', '') 0 >>> bitap_string_match('abdabababc', 'c') 9 >>> bitap_string_match('abdabababc', 'fofosdfo') -1 >>> bitap_string_match('abdab', 'fofosdfo') -1","len, enumerate, enumerate, len, ord, ord, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\boyer_moore_search.py","BoyerMooreSearch","","Example usage:      bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"")     positions = bms.bad_character_heuristic()  where 'positions' contain the locations where the pattern was matched.",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\boyer_moore_search.py","","__init__","","len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\boyer_moore_search.py","","match_in_pattern","Finds the index of char in pattern in reverse order.  Parameters :     char (chr): character to be searched  Returns :     i (int): index of char from last in pattern     -1 (int): if char is not found in pattern  >>> bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"") >>> bms.match_in_pattern(""B"") 1","range"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\boyer_moore_search.py","","mismatch_in_text","Find the index of mis-matched character in text when compared with pattern from last.  Parameters :     current_pos (int): current index position of text  Returns :     i (int): index of mismatched char from last in text     -1 (int): if there is no mismatch between pattern and text block  >>> bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"") >>> bms.mismatch_in_text(2) 3","range"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\boyer_moore_search.py","","bad_character_heuristic","Finds the positions of the pattern location.  >>> bms = BoyerMooreSearch(text=""ABAABA"", pattern=""AB"") >>> bms.bad_character_heuristic() [0, 3]","range, self.mismatch_in_text, positions.append, self.match_in_pattern"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\camel_case_to_snake_case.py","","camel_to_snake_case","Transforms a camelCase (or PascalCase) string to snake_case  >>> camel_to_snake_case(""someRandomString"") 'some_random_string'  >>> camel_to_snake_case(""SomeRandomStr#ng"") 'some_random_str_ng'  >>> camel_to_snake_case(""123someRandom123String123"") '123_some_random_123_string_123'  >>> camel_to_snake_case(""123SomeRandom123String123"") '123_some_random_123_string_123'  >>> camel_to_snake_case(123) Traceback (most recent call last):     ... ValueError: Expected string as input, found <class 'int'>","enumerate, isinstance, ValueError, char.isupper, type, char.lower, .isdigit, char.islower, .isalpha, char.isnumeric, char.lower, char.isalnum"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\can_string_be_rearranged_as_palindrome.py","","can_string_be_rearranged_as_palindrome_counter","A Palindrome is a String that reads the same forward as it does backwards. Examples of Palindromes mom, dad, malayalam >>> can_string_be_rearranged_as_palindrome_counter(""Momo"") True >>> can_string_be_rearranged_as_palindrome_counter(""Mother"") False >>> can_string_be_rearranged_as_palindrome_counter(""Father"") False >>> can_string_be_rearranged_as_palindrome_counter(""A man a plan a canal Panama"") True","sum, .values, Counter, .lower, input_str.replace"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\can_string_be_rearranged_as_palindrome.py","","can_string_be_rearranged_as_palindrome","A Palindrome is a String that reads the same forward as it does backwards. Examples of Palindromes mom, dad, malayalam >>> can_string_be_rearranged_as_palindrome(""Momo"") True >>> can_string_be_rearranged_as_palindrome(""Mother"") False >>> can_string_be_rearranged_as_palindrome(""Father"") False >>> can_string_be_rearranged_as_palindrome_counter(""A man a plan a canal Panama"") True",".lower, character_freq_dict.values, len, input_str.replace, character_freq_dict.get"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\can_string_be_rearranged_as_palindrome.py","","benchmark","Benchmark code for comparing above 2 functions","print, print, print, can_string_be_rearranged_as_palindrome_counter, timeit, can_string_be_rearranged_as_palindrome, timeit"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\capitalize.py","","capitalize","Capitalizes the first letter of a sentence or word.  >>> capitalize(""hello world"") 'Hello world' >>> capitalize(""123 hello world"") '123 hello world' >>> capitalize("" hello world"") ' hello world' >>> capitalize(""a"") 'A' >>> capitalize("""") ''",".upper"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\check_anagrams.py","","check_anagrams","Two strings are anagrams if they are made up of the same letters but are arranged differently (ignoring the case). >>> check_anagrams('Silent', 'Listen') True >>> check_anagrams('This is a string', 'Is this a string') True >>> check_anagrams('This is    a      string', 'Is     this a string') True >>> check_anagrams('There', 'Their') False",".strip, .strip, first_str.replace, second_str.replace, defaultdict, range, all, len, len, len, first_str.lower, second_str.lower, count.values"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\count_vowels.py","","count_vowels","Count the number of vowels in a given string.  :param s: Input string to count vowels in. :return: Number of vowels in the input string.  Examples: >>> count_vowels(""hello world"") 3 >>> count_vowels(""HELLO WORLD"") 3 >>> count_vowels(""123 hello world"") 3 >>> count_vowels("""") 0 >>> count_vowels(""a quick brown fox"") 5 >>> count_vowels(""the quick BROWN fox"") 5 >>> count_vowels(""PYTHON"") 1","sum, isinstance, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\credit_card_validator.py","","validate_initial_digits","Function to validate initial digits of a given credit card number. >>> valid = ""4111111111111111 41111111111111 34 35 37 412345 523456 634567"" >>> all(validate_initial_digits(cc) for cc in valid.split()) True >>> invalid = ""14 25 76 32323 36111111111111"" >>> all(validate_initial_digits(cc) is False for cc in invalid.split()) True","credit_card_number.startswith"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\credit_card_validator.py","","luhn_validation","Function to luhn algorithm validation for a given credit card number. >>> luhn_validation('4111111111111111') True >>> luhn_validation('36111111111111') True >>> luhn_validation('41111111111111') False","range, range, len, int, int, len, str"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\credit_card_validator.py","","validate_credit_card_number","Function to validate the given credit card number. >>> validate_credit_card_number('4111111111111111') 4111111111111111 is a valid credit card number. True >>> validate_credit_card_number('helloworld$') helloworld$ is an invalid credit card number because it has nonnumerical characters. False >>> validate_credit_card_number('32323') 32323 is an invalid credit card number because of its length. False >>> validate_credit_card_number('32323323233232332323') 32323323233232332323 is an invalid credit card number because of its length. False >>> validate_credit_card_number('36111111111111') 36111111111111 is an invalid credit card number because of its first two digits. False >>> validate_credit_card_number('41111111111111') 41111111111111 is an invalid credit card number because it fails the Luhn check. False","print, credit_card_number.isdigit, print, print, validate_initial_digits, print, luhn_validation, print, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\damerau_levenshtein_distance.py","","damerau_levenshtein_distance","Implements the Damerau-Levenshtein distance algorithm that measures the edit distance between two strings.  Parameters:     first_string: The first string to compare     second_string: The second string to compare  Returns:     distance: The edit distance between the first and second strings  >>> damerau_levenshtein_distance(""cat"", ""cut"") 1 >>> damerau_levenshtein_distance(""kitten"", ""sitting"") 3 >>> damerau_levenshtein_distance(""hello"", ""world"") 4 >>> damerau_levenshtein_distance(""book"", ""back"") 2 >>> damerau_levenshtein_distance(""container"", ""containment"") 3 >>> damerau_levenshtein_distance(""container"", ""containment"") 3","range, range, enumerate, enumerate, range, len, len, int, min, len, min, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\detecting_english_programmatically.py","","load_dictionary","","os.path.split, os.path.realpath, open, .split, dictionary_file.read"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\detecting_english_programmatically.py","","get_english_count","","message.upper, remove_non_letters, message.split, len, float, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\detecting_english_programmatically.py","","remove_non_letters",">>> remove_non_letters(""Hi! how are you?"") 'Hi how are you' >>> remove_non_letters(""P^y%t)h@o*n"") 'Python' >>> remove_non_letters(""1+1=2"") '' >>> remove_non_letters(""www.google.com/"") 'wwwgooglecom' >>> remove_non_letters("""") ''",".join"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\detecting_english_programmatically.py","","is_english",">>> is_english('Hello World') True >>> is_english('llold HorWd') False","len, remove_non_letters, get_english_count, float, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\dna.py","","dna","https://en.wikipedia.org/wiki/DNA Returns the second side of a DNA strand  >>> dna(""GCTA"") 'CGAT' >>> dna(""ATGC"") 'TACG' >>> dna(""CTGA"") 'GACT' >>> dna(""GFGG"") Traceback (most recent call last):     ... ValueError: Invalid Strand","dna.translate, len, len, ValueError, dna.maketrans, re.findall"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\edit_distance.py","","edit_distance","Edit distance algorithm is a string metric, i.e., it is a way of quantifying how dissimilar two strings are to one another. It is measured by counting the minimum number of operations required to transform one string into another.  This implementation assumes that the cost of operations (insertion, deletion and substitution) is always 1  Args: source: the initial string with respect to which we are calculating the edit     distance for the target target: the target string, formed after performing n operations on the source string  >>> edit_distance(""GATTIC"", ""GALTIC"") 1 >>> edit_distance(""NUM3"", ""HUM2"") 2 >>> edit_distance(""cap"", ""CAP"") 3 >>> edit_distance(""Cat"", """") 3 >>> edit_distance(""cat"", ""cat"") 0 >>> edit_distance("""", ""123456789"") 9 >>> edit_distance(""Be@uty"", ""Beautyyyy!"") 5 >>> edit_distance(""lstring"", ""lsstring"") 1","int, min, len, len, len, len, edit_distance, edit_distance, edit_distance"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\frequency_finder.py","","get_letter_count","","dict.fromkeys, message.upper"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\frequency_finder.py","","get_item_at_index_zero","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\frequency_finder.py","","get_frequency_order","Get the frequency order of the letters in the given string >>> get_frequency_order('Hello World') 'LOWDRHEZQXJKVBPYGFMUCSNIAT' >>> get_frequency_order('Hello@') 'LHOEZQXJKVBPYGFWMUCDRSNIAT' >>> get_frequency_order('h') 'HZQXJKVBPYGFWMUCLDRSNIOATE'","get_letter_count, list, freq_pairs.sort, .join, .append, .sort, .join, freq_to_letter_str.items, letter_to_freq.items"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\frequency_finder.py","","english_freq_match_score",">>> english_freq_match_score('Hello World') 1","get_frequency_order"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\hamming_distance.py","","hamming_distance","Calculate the Hamming distance between two equal length strings In information theory, the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different. https://en.wikipedia.org/wiki/Hamming_distance  Args:     string1 (str): Sequence 1     string2 (str): Sequence 2  Returns:     int: Hamming distance  >>> hamming_distance(""python"", ""python"") 0 >>> hamming_distance(""karolin"", ""kathrin"") 3 >>> hamming_distance(""00000"", ""11111"") 5 >>> hamming_distance(""karolin"", ""kath"") Traceback (most recent call last):   ... ValueError: String lengths must match!","zip, len, len, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\indian_phone_validator.py","","indian_phone_validator","Determine whether the string is a valid phone number or not :param phone: :return: Boolean >>> indian_phone_validator(""+91123456789"") False >>> indian_phone_validator(""+919876543210"") True >>> indian_phone_validator(""01234567896"") False >>> indian_phone_validator(""919876543218"") True >>> indian_phone_validator(""+91-1234567899"") False >>> indian_phone_validator(""+91-9876543218"") True","re.compile, re.search"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_contains_unique_chars.py","","is_contains_unique_chars","Check if all characters in the string is unique or not. >>> is_contains_unique_chars(""I_love.py"") True >>> is_contains_unique_chars(""I don't love Python"") False  Time complexity: O(n) Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode","ord, pow"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_isogram.py","","is_isogram","An isogram is a word in which no letter is repeated. Examples of isograms are uncopyrightable and ambidextrously. >>> is_isogram('Uncopyrightable') True >>> is_isogram('allowance') False >>> is_isogram('copy1') Traceback (most recent call last):  ... ValueError: String must only contain alphabetic characters.","sorted, all, ValueError, string.lower, len, len, set, x.isalpha"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_pangram.py","","is_pangram","A Pangram String contains all the alphabets at least once. >>> is_pangram(""The quick brown fox jumps over the lazy dog"") True >>> is_pangram(""Waltz, bad nymph, for quick jigs vex."") True >>> is_pangram(""Jived fox nymph grabs quick waltz."") True >>> is_pangram(""My name is Unknown"") False >>> is_pangram(""The quick brown fox jumps over the la_y dog"") False >>> is_pangram() True","set, input_str.replace, len, alpha.lower, frequency.add, alpha.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_pangram.py","","is_pangram_faster",">>> is_pangram_faster(""The quick brown fox jumps over the lazy dog"") True >>> is_pangram_faster(""Waltz, bad nymph, for quick jigs vex."") True >>> is_pangram_faster(""Jived fox nymph grabs quick waltz."") True >>> is_pangram_faster(""The quick brown fox jumps over the la_y dog"") False >>> is_pangram_faster() True","all, char.islower, char.isupper, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_pangram.py","","is_pangram_fastest",">>> is_pangram_fastest(""The quick brown fox jumps over the lazy dog"") True >>> is_pangram_fastest(""Waltz, bad nymph, for quick jigs vex."") True >>> is_pangram_fastest(""Jived fox nymph grabs quick waltz."") True >>> is_pangram_fastest(""The quick brown fox jumps over the la_y dog"") False >>> is_pangram_fastest() True","len, input_str.lower, char.isalpha"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_pangram.py","","benchmark","Benchmark code comparing different version.","print, print, print, timeit, timeit, timeit"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_polish_national_id.py","","is_polish_national_id","Verification of the correctness of the PESEL number. www-gov-pl.translate.goog/web/gov/czym-jest-numer-pesel?_x_tr_sl=auto&_x_tr_tl=en  PESEL can start with 0, that's why we take str as input, but convert it to int for some calculations.   >>> is_polish_national_id(123) Traceback (most recent call last):     ... ValueError: Expected str as input, found <class 'int'>  >>> is_polish_national_id(""abc"") Traceback (most recent call last):     ... ValueError: Expected number as input  >>> is_polish_national_id(""02070803628"") # correct PESEL True  >>> is_polish_national_id(""02150803629"") # wrong month False  >>> is_polish_national_id(""02075503622"") # wrong day False  >>> is_polish_national_id(""-99012212349"") # wrong range False  >>> is_polish_national_id(""990122123499999"") # wrong range False  >>> is_polish_national_id(""02070803621"") # wrong checksum False","int, int, enumerate, isinstance, ValueError, int, range, str, ValueError, range, range, range, range, range, type, int"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_spain_national_id.py","","is_spain_national_id","Spain National Id is a string composed by 8 numbers plus a letter The letter in fact is not part of the ID, it acts as a validator, checking you didn't do a mistake when entering it on a system or are giving a fake one.  https://en.wikipedia.org/wiki/Documento_Nacional_de_Identidad_(Spain)#Number  >>> is_spain_national_id(""12345678Z"") True >>> is_spain_national_id(""12345678z"")  # It is case-insensitive True >>> is_spain_national_id(""12345678x"") False >>> is_spain_national_id(""12345678I"") False >>> is_spain_national_id(""12345678-Z"")  # Some systems add a dash True >>> is_spain_national_id(""12345678"") Traceback (most recent call last):     ... ValueError: Input must be a string of 8 numbers plus letter >>> is_spain_national_id(""123456709"") Traceback (most recent call last):     ... ValueError: Input must be a string of 8 numbers plus letter >>> is_spain_national_id(""1234567--Z"") Traceback (most recent call last):     ... ValueError: Input must be a string of 8 numbers plus letter >>> is_spain_national_id(""1234Z"") Traceback (most recent call last):     ... ValueError: Input must be a string of 8 numbers plus letter >>> is_spain_national_id(""1234ZzZZ"") Traceback (most recent call last):     ... ValueError: Input must be a string of 8 numbers plus letter >>> is_spain_national_id(12345678) Traceback (most recent call last):     ... TypeError: Expected string as input, found int",".upper, letter.isdigit, isinstance, TypeError, len, ValueError, int, ValueError, spanish_id.replace, ValueError, type"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_srilankan_phone_number.py","","is_sri_lankan_phone_number","Determine whether the string is a valid sri lankan mobile phone number or not References: https://aye.sh/blog/sri-lankan-phone-number-regex  >>> is_sri_lankan_phone_number(""+94773283048"") True >>> is_sri_lankan_phone_number(""+9477-3283048"") True >>> is_sri_lankan_phone_number(""0718382399"") True >>> is_sri_lankan_phone_number(""0094702343221"") True >>> is_sri_lankan_phone_number(""075 3201568"") True >>> is_sri_lankan_phone_number(""07779209245"") False >>> is_sri_lankan_phone_number(""0957651234"") False","re.compile, bool, re.search"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\is_valid_email_address.py","","is_valid_email_address","Returns True if the passed email address is valid.  The local part of the email precedes the singular @ symbol and is associated with a display-name. For example, ""john.smith"" The domain is stricter than the local part and follows the @ symbol.  Global email checks:  1. There can only be one @ symbol in the email address. Technically if the     @ symbol is quoted in the local-part, then it is valid, however this     implementation ignores """" for now.     (See https://en.wikipedia.org/wiki/Email_address#:~:text=If%20quoted,)  2. The local-part and the domain are limited to a certain number of octets. With     unicode storing a single character in one byte, each octet is equivalent to     a character. Hence, we can just check the length of the string. Checks for the local-part:  3. The local-part may contain: upper and lowercase latin letters, digits 0 to 9,     and printable characters (!#$%&'*+-/=?^_`{|}~)  4. The local-part may also contain a ""."" in any place that is not the first or     last character, and may not have more than one ""."" consecutively.  Checks for the domain:  5. The domain may contain: upper and lowercase latin letters and digits 0 to 9  6. Hyphen ""-"", provided that it is not the first or last character  7. The domain may also contain a ""."" in any place that is not the first or     last character, and may not have more than one ""."" consecutively.  >>> for email, valid in email_tests: ...     assert is_valid_email_address(email) == valid","email.split, any, any, email.count, local_part.startswith, local_part.endswith, domain.startswith, domain.endswith, len, len, domain.startswith, domain.endswith"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\jaro_winkler.py","","jaro_winkler","Jaro-Winkler distance is a string metric measuring an edit distance between two sequences. Output value is between 0.0 and 1.0.  >>> jaro_winkler(""martha"", ""marhta"") 0.9611111111111111 >>> jaro_winkler(""CRATE"", ""TRACE"") 0.7333333333333334 >>> jaro_winkler(""test"", ""dbdbdbdb"") 0.0 >>> jaro_winkler(""test"", ""test"") 1.0 >>> jaro_winkler(""hello world"", ""HeLLo W0rlD"") 0.6363636363636364 >>> jaro_winkler(""test"", """") 0.0 >>> jaro_winkler(""hello"", ""world"") 0.4666666666666666 >>> jaro_winkler(""hell**o"", ""*world"") 0.4365079365079365","get_matched_characters, get_matched_characters, len, zip, enumerate, .join, len, min, int, int, len, len, max, min, matched.append, len, zip, len, len, _str2.index, _str2.index"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\jaro_winkler.py","","get_matched_characters","","enumerate, .join, min, int, int, len, len, max, min, matched.append, len, _str2.index, _str2.index"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\join.py","","join","Joins a list of strings using a separator and returns the result.  :param separator: Separator to be used             for joining the strings. :param separated: List of strings to be joined.  :return: Joined string with the specified separator.  Examples:  >>> join("""", [""a"", ""b"", ""c"", ""d""]) 'abcd' >>> join(""#"", [""a"", ""b"", ""c"", ""d""]) 'a#b#c#d' >>> join(""#"", ""a"") 'a' >>> join("" "", [""You"", ""are"", ""amazing!""]) 'You are amazing!' >>> join("","", ["""", """", """"]) ',,'  This example should raise an exception for non-string elements: >>> join(""#"", [""a"", ""b"", ""c"", 1]) Traceback (most recent call last):     ... Exception: join() accepts only strings  Additional test case with a different separator: >>> join(""-"", [""apple"", ""banana"", ""cherry""]) 'apple-banana-cherry'","len, isinstance, Exception"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\knuth_morris_pratt.py","","knuth_morris_pratt","The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text with complexity O(n + m)  1) Preprocess pattern to identify any suffixes that are identical to prefixes      This tells us where to continue from if we get a mismatch between a character     in our pattern and the text.  2) Step through the text one character at a time and compare it to a character in     the pattern updating our location within the pattern if necessary  >>> kmp = ""knuth_morris_pratt"" >>> all( ...    knuth_morris_pratt(kmp, s) == kmp.find(s) ...    for s in (""kn"", ""h_m"", ""rr"", ""tt"", ""not there"") ... ) True","get_failure_array, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\knuth_morris_pratt.py","","get_failure_array","Calculates the new index we should go to if we fail a comparison :param pattern: :return:","len, failure.append"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\levenshtein_distance.py","","levenshtein_distance","Implementation of the Levenshtein distance in Python. :param first_word: the first word to measure the difference. :param second_word: the second word to measure the difference. :return: the levenshtein distance between the two words. Examples: >>> levenshtein_distance(""planet"", ""planetary"") 3 >>> levenshtein_distance("""", ""test"") 4 >>> levenshtein_distance(""book"", ""back"") 2 >>> levenshtein_distance(""book"", ""book"") 0 >>> levenshtein_distance(""test"", """") 4 >>> levenshtein_distance("""", """") 0 >>> levenshtein_distance(""orchestration"", ""container"") 10","list, enumerate, len, len, levenshtein_distance, len, len, range, enumerate, current_row.append, len, min"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\levenshtein_distance.py","","levenshtein_distance_optimized","Compute the Levenshtein distance between two words (strings). The function is optimized for efficiency by modifying rows in place. :param first_word: the first word to measure the difference. :param second_word: the second word to measure the difference. :return: the Levenshtein distance between the two words. Examples: >>> levenshtein_distance_optimized(""planet"", ""planetary"") 3 >>> levenshtein_distance_optimized("""", ""test"") 4 >>> levenshtein_distance_optimized(""book"", ""back"") 2 >>> levenshtein_distance_optimized(""book"", ""book"") 0 >>> levenshtein_distance_optimized(""test"", """") 4 >>> levenshtein_distance_optimized("""", """") 0 >>> levenshtein_distance_optimized(""orchestration"", ""container"") 10","list, enumerate, len, len, levenshtein_distance_optimized, len, len, range, enumerate, min, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\levenshtein_distance.py","","benchmark_levenshtein_distance","Benchmark the Levenshtein distance function. :param str: The name of the function being benchmarked. :param func: The function to be benchmarked.","timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\lower.py","","lower","Will convert the entire string to lowercase letters  >>> lower(""wow"") 'wow' >>> lower(""HellZo"") 'hellzo' >>> lower(""WHAT"") 'what' >>> lower(""wh[]32"") 'wh[]32' >>> lower(""whAT"") 'what'",".join, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\manacher.py","","palindromic_string",">>> palindromic_string('abbbaba') 'abbba' >>> palindromic_string('ababa') 'ababa'  Manacher's algorithm which finds Longest palindromic Substring in linear time.  1. first this convert input_string(""xyx"") into new_string(""x|y|x"") where odd     positions are actual input characters. 2. for each character in new_string it find corresponding length and     store the length and left,right to store previously calculated info.     (please look the explanation for details)  3. return corresponding output_string by removing all ""|""","range, len, range, min, len, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\min_cost_string_conversion.py","","compute_transform_tables","Finds the most cost efficient sequence for converting one string into another.  >>> costs, operations = compute_transform_tables(""cat"", ""cut"", 1, 2, 3, 3) >>> costs[0][:4] [0, 3, 6, 9] >>> costs[2][:4] [6, 4, 3, 6] >>> operations[0][:4] ['0', 'Ic', 'Iu', 'It'] >>> operations[3][:4] ['Dt', 'Dt', 'Rtu', 'Ct']  >>> compute_transform_tables("""", """", 1, 2, 3, 3) ([[0]], [['0']])","list, list, len, len, range, range, range, range, range, range, range, range, str"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\min_cost_string_conversion.py","","assemble_transformation","Assembles the transformations based on the ops table.  >>> ops = [['0', 'Ic', 'Iu', 'It'], ...        ['Dc', 'Cc', 'Iu', 'It'], ...        ['Da', 'Da', 'Rau', 'Rat'], ...        ['Dt', 'Dt', 'Rtu', 'Ct']] >>> x = len(ops) - 1 >>> y = len(ops[0]) - 1 >>> assemble_transformation(ops, x, y) ['Cc', 'Rau', 'Ct']  >>> ops1 = [['0']] >>> x1 = len(ops1) - 1 >>> y1 = len(ops1[0]) - 1 >>> assemble_transformation(ops1, x1, y1) []  >>> ops2 = [['0', 'I1', 'I2', 'I3'], ...         ['D1', 'C1', 'I2', 'I3'], ...         ['D2', 'D2', 'R23', 'R23']] >>> x2 = len(ops2) - 1 >>> y2 = len(ops2[0]) - 1 >>> assemble_transformation(ops2, x2, y2) ['C1', 'I2', 'R23']","assemble_transformation, seq.append, assemble_transformation, seq.append, assemble_transformation, seq.append"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\naive_string_search.py","","naive_pattern_search",">>> naive_pattern_search(""ABAAABCDBBABCDDEBCABC"", ""ABC"") [4, 10, 18] >>> naive_pattern_search(""ABC"", ""ABAAABCDBBABCDDEBCABC"") [] >>> naive_pattern_search("""", ""ABC"") [] >>> naive_pattern_search(""TEST"", ""TEST"") [0] >>> naive_pattern_search(""ABCDEGFTEST"", ""TEST"") [7]","len, range, range, position.append, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\ngram.py","","create_ngram","Create ngrams from a sentence  >>> create_ngram(""I am a sentence"", 2) ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce'] >>> create_ngram(""I am an NLPer"", 2) ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er'] >>> create_ngram(""This is short"", 50) []","range, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\palindrome.py","","is_palindrome","Return True if s is a palindrome otherwise return False.  >>> all(is_palindrome(key) is value for key, value in test_data.items()) True","len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\palindrome.py","","is_palindrome_traversal","Return True if s is a palindrome otherwise return False.  >>> all(is_palindrome_traversal(key) is value for key, value in test_data.items()) True","len, all, len, range"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\palindrome.py","","is_palindrome_recursive","Return True if s is a palindrome otherwise return False.  >>> all(is_palindrome_recursive(key) is value for key, value in test_data.items()) True","len, is_palindrome_recursive, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\palindrome.py","","is_palindrome_slice","Return True if s is a palindrome otherwise return False.  >>> all(is_palindrome_slice(key) is value for key, value in test_data.items()) True",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\palindrome.py","","benchmark_function","","timeit, print"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\pig_latin.py","","pig_latin","Compute the piglatin of a given string.  https://en.wikipedia.org/wiki/Pig_Latin  Usage examples: >>> pig_latin(""pig"") 'igpay' >>> pig_latin(""latin"") 'atinlay' >>> pig_latin(""banana"") 'ananabay' >>> pig_latin(""friends"") 'iendsfray' >>> pig_latin(""smile"") 'ilesmay' >>> pig_latin(""string"") 'ingstray' >>> pig_latin(""eat"") 'eatway' >>> pig_latin(""omelet"") 'omeletway' >>> pig_latin(""are"") 'areway' >>> pig_latin("" "") '' >>> pig_latin(None) ''","word.lower, enumerate, .strip"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\prefix_function.py","","prefix_function","For the given string this function computes value for each index(i), which represents the longest coincidence of prefix and suffix for given substring (input_str[0...i])  For the value of the first element the algorithm always returns 0  >>> prefix_function(""aabcdaabc"") [0, 1, 0, 0, 0, 1, 2, 3, 4] >>> prefix_function(""asdasdad"") [0, 0, 0, 1, 2, 3, 4, 0]","range, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\prefix_function.py","","longest_prefix","Prefix-function use case Finding longest prefix which is suffix as well  >>> longest_prefix(""aabcdaabc"") 4 >>> longest_prefix(""asdasdad"") 4 >>> longest_prefix(""abcab"") 2","max, prefix_function"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\rabin_karp.py","","rabin_karp","The Rabin-Karp Algorithm for finding a pattern within a piece of text with complexity O(nm), most efficient when it is used with multiple patterns as it is able to check if any of a set of patterns match a section of text in o(1) given the precomputed hashes.  This will be the simple version which only assumes one pattern is being searched for but it's not hard to modify  1) Calculate pattern hash  2) Step through the text one character at a time passing a window with the same     length as the pattern     calculating the hash of the text within the window compare it with the hash     of the pattern. Only testing equality if the hashes match","len, len, range, range, ord, ord, ord, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\rabin_karp.py","","test_rabin_karp",">>> test_rabin_karp() Success.","rabin_karp, rabin_karp, rabin_karp, rabin_karp, rabin_karp, print, rabin_karp, rabin_karp"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\remove_duplicate.py","","remove_duplicates","Remove duplicates from sentence >>> remove_duplicates(""Python is great and Java is also great"") 'Java Python also and great is' >>> remove_duplicates(""Python   is      great and Java is also great"") 'Java Python also and great is'",".join, sorted, set, sentence.split"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\reverse_letters.py","","reverse_letters","Reverse all words that are longer than the given length of characters in a sentence. If unspecified, length is taken as 0  >>> reverse_letters(""Hey wollef sroirraw"", 3) 'Hey fellow warriors' >>> reverse_letters(""nohtyP is nohtyP"", 2) 'Python is Python' >>> reverse_letters(""1 12 123 1234 54321 654321"", 0) '1 21 321 4321 12345 123456' >>> reverse_letters(""racecar"") 'racecar'",".join, .join, sentence.split, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\reverse_words.py","","reverse_words","Reverses words in a given string >>> reverse_words(""I love Python"") 'Python love I' >>> reverse_words(""I     Love          Python"") 'Python Love I'",".join, input_str.split"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\snake_case_to_camel_pascal_case.py","","snake_to_camel_case","Transforms a snake_case given string to camelCase (or PascalCase if indicated) (defaults to not use Pascal)  >>> snake_to_camel_case(""some_random_string"") 'someRandomString'  >>> snake_to_camel_case(""some_random_string"", use_pascal=True) 'SomeRandomString'  >>> snake_to_camel_case(""some_random_string_with_numbers_123"") 'someRandomStringWithNumbers123'  >>> snake_to_camel_case(""some_random_string_with_numbers_123"", use_pascal=True) 'SomeRandomStringWithNumbers123'  >>> snake_to_camel_case(123) Traceback (most recent call last):     ... ValueError: Expected string as input, found <class 'int'>  >>> snake_to_camel_case(""some_string"", use_pascal=""True"") Traceback (most recent call last):     ... ValueError: Expected boolean as use_pascal parameter, found <class 'str'>","input_str.split, .join, isinstance, ValueError, isinstance, ValueError, .upper, type, type"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\split.py","","split","Will split the string up into all the values separated by the separator (defaults to spaces)  >>> split(""apple#banana#cherry#orange"",separator='#') ['apple', 'banana', 'cherry', 'orange']  >>> split(""Hello there"") ['Hello', 'there']  >>> split(""11/22/63"",separator = '/') ['11', '22', '63']  >>> split(""12:43:39"",separator = "":"") ['12', '43', '39']  >>> split("";abbb;;c;"", separator=';') ['', 'abbb', '', 'c', '']","enumerate, split_words.append, len, split_words.append"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","split_input",">>> split_input(""one two 31235three4four"") [['one', 'two', '31235three4four']]","char.split, re.split"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","to_simple_case",">>> to_simple_case(""one two 31235three4four"") 'OneTwo31235three4four' >>> to_simple_case(""This should be combined"") 'ThisShouldBeCombined' >>> to_simple_case(""The first letters are capitalized, then string is merged"") 'TheFirstLettersAreCapitalizedThenStringIsMerged' >>> to_simple_case(""special characters :, ', %, ^, $, are ignored"") 'SpecialCharactersAreIgnored'","split_input, .join, .join, char.capitalize"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","to_complex_case","Returns the string concatenated with the delimiter we provide.  Parameters: @text: The string on which we want to perform operation @upper: Boolean value to determine whether we want capitalized result or not @separator: The delimiter with which we want to concatenate words  Examples: >>> to_complex_case(""one two 31235three4four"", True, ""_"") 'ONE_TWO_31235THREE4FOUR' >>> to_complex_case(""one two 31235three4four"", False, ""-"") 'one-two-31235three4four'","split_input, .join, .join, separator.join, separator.join, char.upper, char.lower"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","to_pascal_case",">>> to_pascal_case(""one two 31235three4four"") 'OneTwo31235three4four'","to_simple_case"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","to_camel_case",">>> to_camel_case(""one two 31235three4four"") 'oneTwo31235three4four'","to_simple_case, .lower"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","to_snake_case",">>> to_snake_case(""one two 31235three4four"", True) 'ONE_TWO_31235THREE4FOUR' >>> to_snake_case(""one two 31235three4four"", False) 'one_two_31235three4four'","to_complex_case"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\string_switch_case.py","","to_kebab_case",">>> to_kebab_case(""one two 31235three4four"", True) 'ONE-TWO-31235THREE4FOUR' >>> to_kebab_case(""one two 31235three4four"", False) 'one-two-31235three4four'","to_complex_case"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\strip.py","","strip","Remove leading and trailing characters (whitespace by default) from a string.  Args:     user_string (str): The input string to be stripped.     characters (str, optional): Optional characters to be removed             (default is whitespace).  Returns:     str: The stripped string.  Examples:     >>> strip(""   hello   "")     'hello'     >>> strip(""...world..."", ""."")     'world'     >>> strip(""123hello123"", ""123"")     'hello'     >>> strip("""")     ''","len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\text_justification.py","","text_justification","Will format the string such that each line has exactly (max_width) characters and is fully (left and right) justified, and return the list of justified text.  example 1: string = ""This is an example of text justification."" max_width = 16  output = ['This    is    an',           'example  of text',           'justification.  ']  >>> text_justification(""This is an example of text justification."", 16) ['This    is    an', 'example  of text', 'justification.  ']  example 2: string = ""Two roads diverged in a yellow wood"" max_width = 16 output = ['Two        roads',           'diverged   in  a',           'yellow wood     ']  >>> text_justification(""Two roads diverged in a yellow wood"", 16) ['Two        roads', 'diverged   in  a', 'yellow wood     ']  Time complexity: O(m*n) Space complexity: O(m*n)","word.split, answer.append, len, len, len, range, range, aligned_words_list.append, .join, line.append, len, answer.append, .join, aligned_words_list.append, aligned_words_list.append, len, justify, len, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\text_justification.py","","justify","","len, len, range, range, aligned_words_list.append, .join, aligned_words_list.append, aligned_words_list.append"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\title.py","","to_title_case","Converts a string to capitalized case, preserving the input as is  >>> to_title_case(""Aakash"") 'Aakash'  >>> to_title_case(""aakash"") 'Aakash'  >>> to_title_case(""AAKASH"") 'Aakash'  >>> to_title_case(""aAkAsH"") 'Aakash'","range, len, chr, ord, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\title.py","","sentence_to_title_case","Converts a string to title case, preserving the input as is  >>> sentence_to_title_case(""Aakash Giri"") 'Aakash Giri'  >>> sentence_to_title_case(""aakash giri"") 'Aakash Giri'  >>> sentence_to_title_case(""AAKASH GIRI"") 'Aakash Giri'  >>> sentence_to_title_case(""aAkAsH gIrI"") 'Aakash Giri'",".join, to_title_case, input_str.split"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\top_k_frequent_words.py","WordCount","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\top_k_frequent_words.py","","top_k_frequent_words","Returns the `k_value` most frequently occurring words, in non-increasing order of occurrence. In this context, a word is defined as an element in the provided list.  In case `k_value` is greater than the number of distinct words, a value of k equal to the number of distinct words will be considered, instead.  >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3) ['c', 'a', 'b'] >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2) ['c', 'a'] >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1) ['c'] >>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0) [] >>> top_k_frequent_words([], 1) [] >>> top_k_frequent_words(['a', 'a'], 2) ['a']","Heap, Counter, heap.build_max_heap, WordCount, heap.extract_max, range, count_by_word.items, min, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\top_k_frequent_words.py","","__init__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\strings\top_k_frequent_words.py","","__eq__",">>> WordCount('a', 1).__eq__(WordCount('b', 1)) True >>> WordCount('a', 1).__eq__(WordCount('a', 1)) True >>> WordCount('a', 1).__eq__(WordCount('a', 2)) False >>> WordCount('a', 1).__eq__(WordCount('b', 2)) False >>> WordCount('a', 1).__eq__(1) NotImplemented","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\top_k_frequent_words.py","","__lt__",">>> WordCount('a', 1).__lt__(WordCount('b', 1)) False >>> WordCount('a', 1).__lt__(WordCount('a', 1)) False >>> WordCount('a', 1).__lt__(WordCount('a', 2)) True >>> WordCount('a', 1).__lt__(WordCount('b', 2)) True >>> WordCount('a', 2).__lt__(WordCount('a', 1)) False >>> WordCount('a', 2).__lt__(WordCount('b', 1)) False >>> WordCount('a', 1).__lt__(1) NotImplemented","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\upper.py","","upper","Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII letters and subtracting 32 from their integer representation to get the uppercase letter.  >>> upper(""wow"") 'WOW' >>> upper(""Hello"") 'HELLO' >>> upper(""WHAT"") 'WHAT' >>> upper(""wh[]32"") 'WH[]32'",".join, chr, ord"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\wave_string.py","","wave","Returns a so called 'wave' of a given string >>> wave('cat') ['Cat', 'cAt', 'caT'] >>> wave('one') ['One', 'oNe', 'onE'] >>> wave('book') ['Book', 'bOok', 'boOk', 'booK']","range, .isalpha, .upper, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\wildcard_pattern_matching.py","","match_pattern","uses bottom-up dynamic programming solution for matching the input string with a given pattern.  Runtime: O(len(input_string)*len(pattern))  Arguments -------- input_string: str, any string which should be compared with the pattern pattern: str, the string that represents a pattern and may contain '.' for single character matches and '*' for zero or more of preceding character matches  Note ---- the pattern cannot start with a '*', because there should be at least one character before *  Returns ------- A Boolean denoting whether the given string follows the pattern  Examples ------- >>> match_pattern(""aab"", ""c*a*b"") True >>> match_pattern(""dabc"", ""*abc"") False >>> match_pattern(""aaa"", ""aa"") False >>> match_pattern(""aaa"", ""a.a"") True >>> match_pattern(""aaab"", ""aa*"") False >>> match_pattern(""aaab"", "".*"") True >>> match_pattern(""a"", ""bbbb"") False >>> match_pattern("""", ""bbbb"") False >>> match_pattern(""a"", """") False >>> match_pattern("""", """") True","range, range, range, bool, len, len, range, range, range"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\word_occurrence.py","","word_occurrence",">>> from collections import Counter >>> SENTENCE = ""a b A b c b d b d e f e g e h e i e j e 0"" >>> occurence_dict = word_occurrence(SENTENCE) >>> all(occurence_dict[word] == count for word, count ...     in Counter(SENTENCE.split()).items()) True >>> dict(word_occurrence(""Two  spaces"")) {'Two': 1, 'spaces': 1}","defaultdict, sentence.split"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\word_patterns.py","","get_word_pattern","Returns numerical pattern of character appearances in given word >>> get_word_pattern("""") '' >>> get_word_pattern("" "") '0' >>> get_word_pattern(""pattern"") '0.1.2.2.3.4.5' >>> get_word_pattern(""word pattern"") '0.1.2.3.4.5.6.7.7.8.2.9' >>> get_word_pattern(""get word pattern"") '0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10' >>> get_word_pattern() Traceback (most recent call last): ... TypeError: get_word_pattern() missing 1 required positional argument: 'word' >>> get_word_pattern(1) Traceback (most recent call last): ... AttributeError: 'int' object has no attribute 'upper' >>> get_word_pattern(1.1) Traceback (most recent call last): ... AttributeError: 'float' object has no attribute 'upper' >>> get_word_pattern([]) Traceback (most recent call last): ... AttributeError: 'list' object has no attribute 'upper'","word.upper, .join, word_pattern.append, str"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\z_function.py","","z_function","For the given string this function computes value for each index, which represents the maximal length substring starting from the index and is the same as the prefix of the same size  e.x.  for string 'abab' for second index value would be 2  For the value of the first element the algorithm always returns 0  >>> z_function(""abracadabra"") [0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1] >>> z_function(""aaaa"") [0, 3, 2, 1] >>> z_function(""zxxzxxz"") [0, 0, 0, 4, 0, 0, 1]","range, len, go_next, range, min, len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\z_function.py","","go_next","Check if we have to move forward to the next characters or not","len"
"C:/Users/Joseph Dania/Desktop/python_repo\strings\z_function.py","","find_pattern","Example of using z-function for pattern occurrence Given function returns the number of times 'pattern' appears in 'input_str' as a substring  >>> find_pattern(""abr"", ""abracadabra"") 2 >>> find_pattern(""a"", ""aaaa"") 4 >>> find_pattern(""xz"", ""zxxzxxz"") 2","z_function, len"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\co2_emission.py","","fetch_last_half_hour","",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\co2_emission.py","","fetch_from_to","",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\covid_stats_via_xpath.py","CovidData","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\covid_stats_via_xpath.py","","covid_stats","",".xpath, CovidData, .raise_for_status, len, print, print, CovidData, print, CovidData, html.fromstring, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\crawl_google_scholar_citation.py","","get_citation","Return the citation number.","BeautifulSoup, soup.find, .find_all, .get_text, httpx.get, div.find"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\currency_converter.py","","convert_currency","https://www.amdoren.com/currency-api/","locals, params.pop, .json, str, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\current_stock_price.py","","stock_price",">>> stock_price(""EEEE"") 'No <fin-streamer> tag with the specified data-testid attribute found.' >>> isinstance(float(stock_price(""GOOG"")),float) True","BeautifulSoup, httpx.get, soup.find, specific_fin_streamer_tag.get_text"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\current_weather.py","","current_weather",">>> current_weather(""location"") Traceback (most recent call last):     ... ValueError: No API keys provided or no valid data returned.","httpx.get, weather_data.append, httpx.get, weather_data.append, ValueError, response_openweathermap.json, response_weatherstack.json"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\daily_horoscope.py","","horoscope","","BeautifulSoup, httpx.get, soup.find"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\download_images_from_google_query.py","","download_images_from_google_query","Searches google using the provided query term and downloads the images in a folder.  Args:      query : The image search term to be provided by the user. Defaults to     ""dhaka"".     image_numbers : [description]. Defaults to 5.  Returns:     The number of images successfully downloaded.  # Comment out slow (4.20s call) doctests # >>> download_images_from_google_query() 5 # >>> download_images_from_google_query(""potato"") 5","min, httpx.get, BeautifulSoup, .join, json.dumps, json.loads, re.findall, re.sub, re.findall, enumerate, re.findall, str, .decode, .decode, urllib.request.build_opener, urllib.request.install_opener, urllib.request.urlretrieve, str, os.path.exists, os.makedirs, soup.select, bytes, bytes, query.replace"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\emails_from_url.py","Parser","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\emails_from_url.py","","get_domain_name","This function get the main domain name  >>> get_domain_name(""https://a.b.c.d/e/f?g=h,i=j#k"") 'c.d' >>> get_domain_name(""Not a URL!"") ''",".join, .split, get_sub_domain_name"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\emails_from_url.py","","get_sub_domain_name",">>> get_sub_domain_name(""https://a.b.c.d/e/f?g=h,i=j#k"") 'a.b.c.d' >>> get_sub_domain_name(""Not a URL!"") ''","parse.urlparse"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\emails_from_url.py","","emails_from_url","This function takes url and return all valid urls","get_domain_name, Parser, sorted, httpx.get, parser.feed, set, SystemExit, link.startswith, httpx.get, re.findall, link.startswith, link.startswith, parse.urljoin, valid_emails.add"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\emails_from_url.py","","__init__","",".__init__, super"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\emails_from_url.py","","handle_starttag","This function parse html to take takes url from tags","parse.urljoin, self.urls.append"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_anime_and_play.py","","search_scraper","[summary]  Take an url and return list of anime after scraping the site.  >>> type(search_scraper(""demon_slayer"")) <class 'list'>  Args:     anime_name (str): [Name of anime]  Raises:     e: [Raises exception on failure]  Returns:     [list]: [List of animes]","httpx.get, response.raise_for_status, BeautifulSoup, soup.find, isinstance, ValueError, isinstance, anime.find, anime.find, anime_list.append, isinstance, isinstance, UserAgent"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_anime_and_play.py","","search_anime_episode_list","[summary]  Take an url and return list of episodes after scraping the site for an url.  >>> type(search_anime_episode_list(""/anime/kimetsu-no-yaiba"")) <class 'list'>  Args:     episode_endpoint (str): [Endpoint of episode]  Raises:     e: [description]  Returns:     [list]: [List of episodes]","httpx.get, response.raise_for_status, BeautifulSoup, soup.find, isinstance, ValueError, isinstance, episode.find, episode.find, episode_list.append, isinstance, isinstance, UserAgent, title.text.replace"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_anime_and_play.py","","get_anime_episode","[summary]  Get click url and download url from episode url  >>> type(get_anime_episode(""/watch/kimetsu-no-yaiba/1"")) <class 'list'>  Args:     episode_endpoint (str): [Endpoint of episode]  Raises:     e: [description]  Returns:     [list]: [List of download and watch url]","httpx.get, response.raise_for_status, BeautifulSoup, soup.find, isinstance, RuntimeError, isinstance, RuntimeError, episode_url.replace, UserAgent"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_bbc_news.py","","fetch_bbc_news","",".json, enumerate, print, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_github_info.py","","fetch_github_info","Fetch GitHub info of a user using the httpx module",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_jobs.py","","fetch_jobs","","BeautifulSoup, soup.find_all, .text.strip, .text.strip, httpx.get, job.find, job.find"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_quotes.py","","quote_of_the_day","",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_quotes.py","","random_quotes","",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\fetch_well_rx_price.py","","fetch_pharmacy_and_price_list","[summary]  This function will take input of drug name and zipcode, then request to the BASE_URL site. Get the page data and scrape it to generate the list of the lowest prices for the prescription drug.  Args:     drug_name (str): [Drug name]     zip_code(str): [Zip code]  Returns:     list: [List of pharmacy name and price]  >>> print(fetch_pharmacy_and_price_list(None, None)) None >>> print(fetch_pharmacy_and_price_list(None, 30303)) None >>> print(fetch_pharmacy_and_price_list(""eliquis"", None)) None","BASE_URL.format, .raise_for_status, BeautifulSoup, soup.find_all, httpx.get, len, pharmacy_price_list.append, grid.find, grid.find"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_amazon_product_data.py","","get_amazon_product_data","Take a product name or category as input and return product information from Amazon including title, URL, price, ratings, and the discount available.","BeautifulSoup, DataFrame, zip_longest, soup.find_all, soup.find_all, httpx.get, str, item.find, float, len, item.find, float, .text.split, float, float, float, .replace, item.find, .replace, .replace, product_mrp.strip, product_mrp.strip, product_price.strip"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_imdb_top_250_movies_csv.py","","get_imdb_top_250_movies","","BeautifulSoup, soup.find_all, soup.find_all, float, httpx.get, zip"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_imdb_top_250_movies_csv.py","","write_movies","","get_imdb_top_250_movies, open, csv.writer, writer.writerow, movies.items, writer.writerow"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_ip_geolocation.py","","get_ip_geolocation","","httpx.get, response.raise_for_status, response.json"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_top_billionaires.py","","years_old","Calculate the age in years based on the given birth date.  Only the year, month, and day are used in the calculation.  The time of day is ignored.  Args:     birth_timestamp: The date of birth.     today: (useful for writing tests) or if None then datetime.date.today().  Returns:     int: The age in years.  Examples: >>> today = date(2024, 1, 12) >>> years_old(birth_timestamp=datetime(1959, 11, 20).timestamp(), today=today) 64 >>> years_old(birth_timestamp=datetime(1970, 2, 13).timestamp(), today=today) 53 >>> all( ...     years_old(datetime(today.year - i, 1, 12).timestamp(), today=today) == i ...     for i in range(1, 111) ... ) True",".date, TODAY.date, datetime.fromtimestamp"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_top_billionaires.py","","get_forbes_real_time_billionaires","Get the top 10 real-time billionaires using Forbes API.  Returns:     List of top 10 realtime billionaires data.",".json, httpx.get, str, years_old"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_top_billionaires.py","","display_billionaires","Display Forbes real-time billionaires in a rich table.  Args:     forbes_billionaires (list): Forbes top 10 real-time billionaires","rich_table.Table, .print, table.add_column, table.add_row, rich_console.Console, billionaire.values"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_top_hn_posts.py","","get_hackernews_story","",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_top_hn_posts.py","","hackernews_top_stories","Get the top max_stories posts from HackerNews - https://news.ycombinator.com/",".json, get_hackernews_story, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\get_top_hn_posts.py","","hackernews_top_stories_as_markdown","","hackernews_top_stories, .join, .format"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\giphy.py","","get_gifs","Get a list of URLs of GIFs based on a given query..",".join, query.split, .json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","extract_user_profile","May raise json.decoder.JSONDecodeError","json.loads, data.find"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","InstagramUser","","Class Instagram crawl instagram user information  Usage: (doctest failing on GitHub Actions) # >>> instagram_user = InstagramUser(""github"") # >>> instagram_user.is_verified True # >>> instagram_user.biography 'Built for developers.'",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","test_instagram_user","A self running doctest >>> test_instagram_user()","os.environ.get, InstagramUser, isinstance, instagram_user.profile_picture_url.startswith"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","__init__","","self.get_json"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","get_json","Return a dict of user information",".find_all, httpx.get, extract_user_profile, BeautifulSoup, extract_user_profile"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","__repr__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","__str__","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","username","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","fullname","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","biography","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","email","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","website","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","number_of_followers","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","number_of_followings","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","number_of_posts","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","profile_picture_url","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","is_verified","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_crawler.py","","is_private","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_pic.py","","download_image","Download an image from a given URL by scraping the 'og:image' meta tag.  Parameters:     url: The URL to scrape.  Returns:     A message indicating the result of the operation.","BeautifulSoup, soup.find, image_meta_tag.get, httpx.get, response.raise_for_status, open, out_file.write, httpx.get, .astimezone, datetime.now"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\instagram_video.py","","download_video","","httpx.get, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\nasa_data.py","","get_apod_data","Get the APOD(Astronomical Picture of the day) data Get your API Key from: https://api.nasa.gov/",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\nasa_data.py","","save_apod","","get_apod_data, httpx.get, img_url.split, open, img_file.write"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\nasa_data.py","","get_archive_data","Get the data of a particular query from NASA archives",".json, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\random_anime_character.py","","save_image","Saves the image of anime character","httpx.get, open, file.write"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\random_anime_character.py","","random_anime_character","Returns the Title, Description, and Image Title of a random anime character .","BeautifulSoup, .get_text, os.path.splitext, .replace, save_image, os.path.basename, httpx.get, soup.find, soup.find, soup.find, title.strip"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\recaptcha_verification.py","","login_using_recaptcha","","request.POST.get, request.POST.get, request.POST.get, httpx.post, .get, render, render, authenticate, response.json, login, redirect"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\reddit.py","","get_subreddit_data","subreddit : Subreddit to query limit : Number of posts to fetch age : [""new"", ""top"", ""hot""] wanted_data : Get only the required data in the list","httpx.get, response.raise_for_status, response.json, range, .join, ValueError, httpx.HTTPError, sorted, range, set"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\search_books_by_isbn.py","","get_openlibrary_data","Given an 'isbn/0140328726', return book data from Open Library as a Python dict. Given an '/authors/OL34184A', return authors data as a Python dict. This code must work for olids with or without a leading slash ('/').  # Comment out doctests if they take too long or have results that may change # >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS {'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ... # >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS {'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ...",".strip, .json, new_olid.count, ValueError, olid.strip, httpx.get"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\search_books_by_isbn.py","","summarize_book","Given Open Library book data, return a summary as a Python dict.","data.items, isinstance, desired_keys.items, get_openlibrary_data, .join"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\slack_message.py","","send_slack_message","","httpx.post, ValueError"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\test_fetch_github_info.py","","test_fetch_github_info","","monkeypatch.setattr, fetch_github_info, .startswith, FakeResponse, isinstance, json.loads"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\test_fetch_github_info.py","FakeResponse","","",""
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\test_fetch_github_info.py","","mock_response","",".startswith, FakeResponse"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\test_fetch_github_info.py","","__init__","","isinstance"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\test_fetch_github_info.py","","json","","json.loads"
"C:/Users/Joseph Dania/Desktop/python_repo\web_programming\world_covid19_stats.py","","world_covid19_stats","Return a dict of current worldwide COVID-19 statistics","BeautifulSoup, soup.find_all, soup.find_all, soup.find_all, soup.find_all, key.text.strip, value.text.strip, httpx.get, zip"
